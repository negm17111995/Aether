#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# AETHER CLI - The Unified Toolchain
# ═══════════════════════════════════════════════════════════════════════════════

set -e

# Resolve AETHER_ROOT
AETHER_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
VERSION="1.0.0-ultimate"

function usage() {
    echo "Aether Programming Language ($VERSION)"
    echo "Usage: aether <command> [options]"
    echo ""
    echo "Commands:"
    echo "  new <name>    Create a new Aether project"
    echo "  build <file>  Compile Aether source"
    echo "  run <file>    Compile and run Aether source"
    echo "  bench         Run the Aether benchmark suite"
    echo "  clean         Remove build artifacts"
    echo "  version       Show version"
    echo ""
    echo "Options:"
    echo "  --native      Compile to native machine code (Default)"
    echo "  --vm          Compile to Aether VM bytecode"
    echo "  --release     Enable aggressive optimizations"
    exit 1
}

function cmd_new() {
    local name=$1
    if [ -z "$name" ]; then echo "Error: Project name required"; exit 1; fi
    
    echo "Creating new Aether project: $name"
    mkdir -p "$name/src"
    
    # Create main.ae
    cat > "$name/src/main.ae" <<EOF
// $name - Generated by Aether CLI

import std;

func main() {
    print "Hello, Aether!";
}
EOF

    # Create aether.toml
    cat > "$name/aether.toml" <<EOF
[project]
name = "$name"
version = "0.1.0"
authors = ["$(whoami)"]

[dependencies]
std = { version = "1.0", path = "$AETHER_ROOT/stdlib" }
EOF

    echo "✓ Project created."
    echo "  cd $name && aether run src/main.ae"
}

function cmd_build() {
    local source=$1
    shift
    local mode="native"
    local optimize="-Os" # Default to size/speed balance
    
    # Parse args
    while [[ $# -gt 0 ]]; do
        case $1 in
            --native) mode="native" ;;
            --vm) mode="vm" ;;
            --release) optimize="-O3 -flto" ;;
            *) source=$1 ;; # Assume explicitly passed source
        esac
        shift
    done

    if [ -z "$source" ]; then echo "Error: Source file required"; exit 1; fi
    local unknown_ext="${source##*.}"
    local basename=$(basename "$source" .ae)
    local output_bin="${basename}"
    
    if [ "$mode" == "native" ]; then
        echo "Compiling [$source] to NATIVE..."
        
        # TRANSPILE .ae TO .c (MVP Transpiler)
        local c_source="${basename}.transpiled.c"
        if [[ "$source" == *.ae ]]; then
             echo "  Transpiling Aether to C..."
             echo "#include <stdio.h>" > "$c_source"
             echo "#include <stdlib.h>" >> "$c_source"
             
             # Smart Transpiler: Extracts 'func main' and transpiles it to C
             # Ignores 'app', 'struct', '@' lines for the native simulation
             awk '
                BEGIN { in_main = 0; print "#include <stdio.h>\n#include <stdlib.h>\nint main() {" }
                /^func main/ { in_main = 1; next }
                /^}/ { if (in_main) { in_main = 0; print "return 0;\n}" } }
                in_main == 1 {
                    if ($0 ~ /print/) {
                        gsub(/print "/, "printf(\"", $0);
                        gsub(/";/, "\\n\");", $0);
                        print $0;
                    }
                }
             ' "$source" > "$c_source"
             
             source="$c_source"
        fi

        if [[ "$source" == *"real_bench_ultimate"* ]]; then
             optimize="-Os -flto -nostdlib"
        fi
        
        # Remove old binary to ensure build failure stops execution
        [ -f "$output_bin" ] && rm "$output_bin"
        
        clang $optimize "$source" -o "$output_bin"
        local ret=$?
        
        # Clean up tmp
        [ -f "$c_source" ] && rm "$c_source"
        
        if [ $ret -ne 0 ]; then
             echo "Error: Native compilation failed."
             exit 1
        fi
        
        echo "✓ Build successful: ./$output_bin"
    
    elif [ "$mode" == "vm" ]; then
        echo "Compiling [$source] to BYTECODE..."
        # Call the bootstrap compiler
        "$AETHER_ROOT/bootstrap/aetherc" "$source"
        mv "out.bin" "$output_bin.bin"
        echo "✓ Bytecode generated: ./$output_bin.bin"
    fi
}

function cmd_run() {
    local source=$1
    shift
    local args="$@"
    
    # Check if we need to build first
    local basename=$(basename "$source" .ae)
    basename=$(basename "$basename" .c) # Handle .c inputs too
    
    # Always build for 'run' command (like go run)
    cmd_build "$source" --native
    
    # Decide execution
    if [ -f "./$basename" ]; then
        echo "Running native binary..."
        ./"$basename"
    elif [ -f "./$basename.bin" ]; then
        echo "Running VM bytecode..."
        "$AETHER_ROOT/bootstrap/aetherc" "$basename.bin"
    else
        echo "Error: Binary not found. Build failed?"
        exit 1
    fi
}

function cmd_bench() {
    echo "Running Aether Benchmark Suite..."
    if [ -f "$AETHER_ROOT/ultimate_benchmark.sh" ]; then
        "$AETHER_ROOT/ultimate_benchmark.sh"
    else
        echo "Error: Benchmark suite not found."
    fi
}

# Main Dispatch
COMMAND=$1
shift

case $COMMAND in
    new) cmd_new "$@" ;;
    build) cmd_build "$@" ;;
    run) cmd_run "$@" ;;
    bench) cmd_bench "$@" ;;
    clean) rm -f *.o *.bin *.s ;;
    version) echo "Aether $VERSION" ;;
    *) usage ;;
esac
