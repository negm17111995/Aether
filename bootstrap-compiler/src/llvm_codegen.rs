// AETHER LLVM IR CODE GENERATOR
// Generates LLVM IR from Aether AST for cross-platform compilation
// Supports: macOS, Linux, Windows on x86_64 and ARM64

use crate::parser::{Module, Decl, Func, Stmt, Expr, BinOp, UnaryOp};
use std::collections::HashMap;

/// Target platform for LLVM IR generation
#[derive(Clone, Copy, Debug)]
pub enum Target {
    // macOS
    MacosArm64,
    MacosX64,
    // Linux
    LinuxArm64,
    LinuxX64,
    // Windows
    WindowsX64,
    // WebAssembly
    Wasm32,
}

impl Target {
    /// Detect the current host platform
    pub fn detect() -> Self {
        #[cfg(all(target_os = "macos", target_arch = "aarch64"))]
        { Target::MacosArm64 }
        #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
        { Target::MacosX64 }
        #[cfg(all(target_os = "linux", target_arch = "aarch64"))]
        { Target::LinuxArm64 }
        #[cfg(all(target_os = "linux", target_arch = "x86_64"))]
        { Target::LinuxX64 }
        #[cfg(all(target_os = "windows", target_arch = "x86_64"))]
        { Target::WindowsX64 }
        #[cfg(not(any(
            all(target_os = "macos", target_arch = "aarch64"),
            all(target_os = "macos", target_arch = "x86_64"),
            all(target_os = "linux", target_arch = "aarch64"),
            all(target_os = "linux", target_arch = "x86_64"),
            all(target_os = "windows", target_arch = "x86_64"),
        )))]
        { Target::LinuxX64 } // Default fallback
    }
    
    /// Parse target from string (for --target flag)
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "macos-arm64" | "aarch64-apple-darwin" | "arm64-apple-macos" => Some(Target::MacosArm64),
            "macos-x64" | "x86_64-apple-darwin" | "x86_64-apple-macos" => Some(Target::MacosX64),
            "linux-arm64" | "aarch64-unknown-linux-gnu" | "aarch64-linux" => Some(Target::LinuxArm64),
            "linux-x64" | "x86_64-unknown-linux-gnu" | "x86_64-linux" => Some(Target::LinuxX64),
            "windows-x64" | "x86_64-pc-windows-msvc" | "x86_64-windows" => Some(Target::WindowsX64),
            "wasm32" | "wasm32-unknown-unknown" => Some(Target::Wasm32),
            _ => None,
        }
    }
    
    /// Get the LLVM target triple
    pub fn triple(&self) -> &'static str {
        match self {
            Target::MacosArm64 => "arm64-apple-macosx14.0.0",
            Target::MacosX64 => "x86_64-apple-macosx14.0.0",
            Target::LinuxArm64 => "aarch64-unknown-linux-gnu",
            Target::LinuxX64 => "x86_64-unknown-linux-gnu",
            Target::WindowsX64 => "x86_64-pc-windows-msvc",
            Target::Wasm32 => "wasm32-unknown-unknown",
        }
    }
    
    /// Get data layout for this target
    pub fn data_layout(&self) -> &'static str {
        match self {
            Target::MacosArm64 | Target::LinuxArm64 => 
                "e-m:o-i64:64-i128:128-n32:64-S128",
            Target::MacosX64 | Target::LinuxX64 => 
                "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
            Target::WindowsX64 => 
                "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
            Target::Wasm32 =>
                "e-m:e-p:32:32-i64:64-n32:64-S128",
        }
    }
    
    /// Get list of all supported targets
    pub fn all() -> Vec<Self> {
        vec![
            Target::MacosArm64,
            Target::MacosX64,
            Target::LinuxArm64,
            Target::LinuxX64,
            Target::WindowsX64,
            Target::Wasm32,
        ]
    }
}

pub struct LLVMGen {
    output: String,
    string_counter: usize,
    label_counter: usize,
    locals: HashMap<String, String>,
    local_counter: usize,
    target: Target,
}

impl LLVMGen {
    pub fn new() -> Self {
        LLVMGen {
            output: String::new(),
            string_counter: 0,
            label_counter: 0,
            locals: HashMap::new(),
            local_counter: 0,
            target: Target::detect(),
        }
    }
    
    pub fn with_target(target: Target) -> Self {
        LLVMGen {
            output: String::new(),
            string_counter: 0,
            label_counter: 0,
            locals: HashMap::new(),
            local_counter: 0,
            target,
        }
    }
    
    fn emit(&mut self, line: &str) {
        self.output.push_str(line);
        self.output.push('\n');
    }
    
    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("L{}", self.label_counter)
    }
    
    fn new_local(&mut self) -> String {
        self.local_counter += 1;
        format!("%t{}", self.local_counter)
    }
    
    fn emit_header(&mut self) {
        self.emit("; Aether LLVM IR - Generated by aether_bootstrap");
        self.emit("; Cross-platform compatible - works on any OS with LLVM/Clang");
        self.emit("");
        self.emit(&format!("target datalayout = \"{}\"", self.target.data_layout()));
        self.emit(&format!("target triple = \"{}\"", self.target.triple()));
        self.emit("");
        self.emit("; External declarations (libc)");
        self.emit("declare i32 @putchar(i32)");
        self.emit("declare i8* @malloc(i64)");
        self.emit("declare void @free(i8*)");
        self.emit("declare void @exit(i32)");
        self.emit("declare i64 @write(i32, i8*, i64)");
        self.emit("declare i64 @read(i32, i8*, i64)");
        self.emit("");
    }
    
    fn emit_expr(&mut self, expr: &Expr) -> String {
        match expr {
            Expr::IntLit(n) => {
                format!("{}", n)
            }
            Expr::StrLit(s) => {
                self.string_counter += 1;
                let str_name = format!("@.str.{}", self.string_counter);
                format!("getelementptr inbounds ([{} x i8], [{} x i8]* {}, i64 0, i64 0)", 
                        s.len() + 1, s.len() + 1, str_name)
            }
            Expr::Ident(name) => {
                let ptr_opt = self.locals.get(name).cloned();
                if let Some(ptr) = ptr_opt {
                    let val = self.new_local();
                    self.emit(&format!("  {} = load i64, i64* {}", val, ptr));
                    val
                } else {
                    "0".to_string()
                }
            }
            Expr::Binary(left, op, right) => {
                let l = self.emit_expr(left);
                let r = self.emit_expr(right);
                let result = self.new_local();
                
                let op_str = match op {
                    BinOp::Add => "add",
                    BinOp::Sub => "sub",
                    BinOp::Mul => "mul",
                    BinOp::Div => "sdiv",
                    BinOp::Mod => "srem",
                    BinOp::Eq => { 
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp eq i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Ne => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp ne i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Lt => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp slt i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Le => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp sle i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Gt => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp sgt i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Ge => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp sge i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::And => "and",
                    BinOp::Or => "or",
                    BinOp::BitAnd => "and",
                    BinOp::BitOr => "or",
                    BinOp::BitXor => "xor",
                };
                
                self.emit(&format!("  {} = {} i64 {}, {}", result, op_str, l, r));
                result
            }
            Expr::Unary(op, inner) => {
                let val = self.emit_expr(inner);
                let result = self.new_local();
                
                match op {
                    UnaryOp::Neg => {
                        self.emit(&format!("  {} = sub i64 0, {}", result, val));
                    }
                    UnaryOp::Not => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp eq i64 {}, 0", cmp, val));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                    }
                    UnaryOp::BitNot => {
                        self.emit(&format!("  {} = xor i64 {}, -1", result, val));
                    }
                }
                result
            }
            Expr::Call(name, args) => {
                let mut arg_vals = Vec::new();
                for arg in args {
                    arg_vals.push(self.emit_expr(arg));
                }
                let result = self.new_local();
                let args_str = arg_vals.iter().map(|a| format!("i64 {}", a)).collect::<Vec<_>>().join(", ");
                self.emit(&format!("  {} = call i64 @{}({})", result, name, args_str));
                result
            }
            Expr::BuiltinCall(name, args) => {
                if name == "__builtin_print" && !args.is_empty() {
                    let ch = self.emit_expr(&args[0]);
                    let trunc = self.new_local();
                    self.emit(&format!("  {} = trunc i64 {} to i32", trunc, ch));
                    self.emit(&format!("  call i32 @putchar(i32 {})", trunc));
                    "0".to_string()
                } else if name == "__builtin_exit" && !args.is_empty() {
                    let code = self.emit_expr(&args[0]);
                    let trunc = self.new_local();
                    self.emit(&format!("  {} = trunc i64 {} to i32", trunc, code));
                    self.emit(&format!("  call void @exit(i32 {})", trunc));
                    self.emit("  unreachable");
                    "0".to_string()
                } else if name == "__builtin_malloc" && !args.is_empty() {
                    let size = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    let result = self.new_local();
                    self.emit(&format!("  {} = call i8* @malloc(i64 {})", ptr, size));
                    self.emit(&format!("  {} = ptrtoint i8* {} to i64", result, ptr));
                    result
                } else if name == "__builtin_free" && !args.is_empty() {
                    let addr = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i8*", ptr, addr));
                    self.emit(&format!("  call void @free(i8* {})", ptr));
                    "0".to_string()
                } else if name == "__builtin_store8" && args.len() >= 2 {
                    let addr = self.emit_expr(&args[0]);
                    let val = self.emit_expr(&args[1]);
                    let ptr = self.new_local();
                    let trunc = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i8*", ptr, addr));
                    self.emit(&format!("  {} = trunc i64 {} to i8", trunc, val));
                    self.emit(&format!("  store i8 {}, i8* {}", trunc, ptr));
                    "0".to_string()
                } else if name == "__builtin_load8" && !args.is_empty() {
                    let addr = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    let val = self.new_local();
                    let result = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i8*", ptr, addr));
                    self.emit(&format!("  {} = load i8, i8* {}", val, ptr));
                    self.emit(&format!("  {} = zext i8 {} to i64", result, val));
                    result
                } else if name == "__builtin_store64" && args.len() >= 2 {
                    let addr = self.emit_expr(&args[0]);
                    let val = self.emit_expr(&args[1]);
                    let ptr = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i64*", ptr, addr));
                    self.emit(&format!("  store i64 {}, i64* {}", val, ptr));
                    "0".to_string()
                } else if name == "__builtin_load64" && !args.is_empty() {
                    let addr = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    let result = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i64*", ptr, addr));
                    self.emit(&format!("  {} = load i64, i64* {}", result, ptr));
                    result
                } else {
                    "0".to_string()
                }
            }
        }
    }
    
    fn emit_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let { name, init } => {
                let ptr = format!("%{}", name);
                self.emit(&format!("  {} = alloca i64", ptr));
                self.locals.insert(name.clone(), ptr.clone());
                
                if let Some(expr) = init {
                    let val = self.emit_expr(expr);
                    self.emit(&format!("  store i64 {}, i64* {}", val, ptr));
                }
            }
            Stmt::Assign { target, value } => {
                let val = self.emit_expr(value);
                let ptr_opt = self.locals.get(target).cloned();
                if let Some(ptr) = ptr_opt {
                    self.emit(&format!("  store i64 {}, i64* {}", val, ptr));
                }
            }
            Stmt::Return(expr) => {
                let val = if let Some(e) = expr {
                    self.emit_expr(e)
                } else {
                    "0".to_string()
                };
                self.emit(&format!("  ret i64 {}", val));
            }
            Stmt::If { cond, then_block, else_block } => {
                let cond_val = self.emit_expr(cond);
                let cmp = self.new_local();
                self.emit(&format!("  {} = icmp ne i64 {}, 0", cmp, cond_val));
                
                let then_label = self.new_label();
                let else_label = self.new_label();
                let end_label = self.new_label();
                
                if else_block.is_some() {
                    self.emit(&format!("  br i1 {}, label %{}, label %{}", cmp, then_label, else_label));
                } else {
                    self.emit(&format!("  br i1 {}, label %{}, label %{}", cmp, then_label, end_label));
                }
                
                self.emit(&format!("{}:", then_label));
                for s in then_block {
                    self.emit_stmt(s);
                }
                self.emit(&format!("  br label %{}", end_label));
                
                if let Some(else_stmts) = else_block {
                    self.emit(&format!("{}:", else_label));
                    for s in else_stmts {
                        self.emit_stmt(s);
                    }
                    self.emit(&format!("  br label %{}", end_label));
                }
                
                self.emit(&format!("{}:", end_label));
            }
            Stmt::While { cond, body } => {
                let cond_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                self.emit(&format!("  br label %{}", cond_label));
                self.emit(&format!("{}:", cond_label));
                
                let cond_val = self.emit_expr(cond);
                let cmp = self.new_local();
                self.emit(&format!("  {} = icmp ne i64 {}, 0", cmp, cond_val));
                self.emit(&format!("  br i1 {}, label %{}, label %{}", cmp, body_label, end_label));
                
                self.emit(&format!("{}:", body_label));
                for s in body {
                    self.emit_stmt(s);
                }
                self.emit(&format!("  br label %{}", cond_label));
                
                self.emit(&format!("{}:", end_label));
            }
            Stmt::Expr(e) => {
                self.emit_expr(e);
            }
        }
    }
    
    fn emit_func(&mut self, func: &Func) {
        self.locals.clear();
        self.local_counter = 0;
        
        let params_str = func.params.iter()
            .map(|p| format!("i64 %{}", p.name))
            .collect::<Vec<_>>()
            .join(", ");
        
        self.emit(&format!("define i64 @{}({}) {{", func.name, params_str));
        self.emit("entry:");
        
        for param in &func.params {
            let ptr = format!("%{}.addr", param.name);
            self.emit(&format!("  {} = alloca i64", ptr));
            self.emit(&format!("  store i64 %{}, i64* {}", param.name, ptr));
            self.locals.insert(param.name.clone(), ptr);
        }
        
        let mut has_return = false;
        for stmt in &func.body {
            if matches!(stmt, Stmt::Return(_)) {
                has_return = true;
            }
            self.emit_stmt(stmt);
        }
        
        if !has_return {
            self.emit("  ret i64 0");
        }
        
        self.emit("}");
        self.emit("");
    }
    
    pub fn generate(&mut self, module: &Module) -> String {
        self.emit_header();
        
        for decl in &module.decls {
            if let Decl::Func(f) = decl {
                self.emit_func(f);
            }
        }
        
        self.output.clone()
    }
}

/// Generate LLVM IR for the host platform
pub fn generate_llvm(module: &Module) -> String {
    let mut llvmgen = LLVMGen::new();
    llvmgen.generate(module)
}

/// Generate LLVM IR for a specific target platform
pub fn generate_llvm_for_target(module: &Module, target: Target) -> String {
    let mut llvmgen = LLVMGen::with_target(target);
    llvmgen.generate(module)
}
