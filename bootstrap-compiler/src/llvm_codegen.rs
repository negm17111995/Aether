// AETHER LLVM IR CODE GENERATOR
// Generates LLVM IR from Aether AST for cross-platform compilation

use crate::parser::{Module, Decl, Func, Stmt, Expr, BinOp, UnaryOp};
use std::collections::HashMap;

pub struct LLVMGen {
    output: String,
    string_counter: usize,
    label_counter: usize,
    locals: HashMap<String, String>,
    local_counter: usize,
}

impl LLVMGen {
    pub fn new() -> Self {
        LLVMGen {
            output: String::new(),
            string_counter: 0,
            label_counter: 0,
            locals: HashMap::new(),
            local_counter: 0,
        }
    }
    
    fn emit(&mut self, line: &str) {
        self.output.push_str(line);
        self.output.push('\n');
    }
    
    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("L{}", self.label_counter)
    }
    
    fn new_local(&mut self) -> String {
        self.local_counter += 1;
        format!("%t{}", self.local_counter)
    }
    
    fn emit_header(&mut self) {
        self.emit("; Aether LLVM IR - Generated by aether_bootstrap");
        self.emit("target triple = \"arm64-apple-macosx14.0.0\"");
        self.emit("");
        self.emit("; External declarations");
        self.emit("declare i32 @putchar(i32)");
        self.emit("declare i8* @malloc(i64)");
        self.emit("declare void @exit(i32)");
        self.emit("");
    }
    
    fn emit_expr(&mut self, expr: &Expr) -> String {
        match expr {
            Expr::IntLit(n) => {
                format!("{}", n)
            }
            Expr::StrLit(s) => {
                self.string_counter += 1;
                let str_name = format!("@.str.{}", self.string_counter);
                // String constants will be added at top
                format!("getelementptr inbounds ([{} x i8], [{} x i8]* {}, i64 0, i64 0)", 
                        s.len() + 1, s.len() + 1, str_name)
            }
            Expr::Ident(name) => {
                let ptr_opt = self.locals.get(name).cloned();
                if let Some(ptr) = ptr_opt {
                    let val = self.new_local();
                    self.emit(&format!("  {} = load i64, i64* {}", val, ptr));
                    val
                } else {
                    "0".to_string()
                }
            }
            Expr::Binary(left, op, right) => {
                let l = self.emit_expr(left);
                let r = self.emit_expr(right);
                let result = self.new_local();
                
                let op_str = match op {
                    BinOp::Add => "add",
                    BinOp::Sub => "sub",
                    BinOp::Mul => "mul",
                    BinOp::Div => "sdiv",
                    BinOp::Mod => "srem",
                    BinOp::Eq => { 
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp eq i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Ne => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp ne i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Lt => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp slt i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Le => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp sle i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Gt => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp sgt i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::Ge => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp sge i64 {}, {}", cmp, l, r));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                        return result;
                    }
                    BinOp::And => "and",
                    BinOp::Or => "or",
                    BinOp::BitAnd => "and",
                    BinOp::BitOr => "or",
                    BinOp::BitXor => "xor",
                };
                
                self.emit(&format!("  {} = {} i64 {}, {}", result, op_str, l, r));
                result
            }
            Expr::Unary(op, inner) => {
                let val = self.emit_expr(inner);
                let result = self.new_local();
                
                match op {
                    UnaryOp::Neg => {
                        self.emit(&format!("  {} = sub i64 0, {}", result, val));
                    }
                    UnaryOp::Not => {
                        let cmp = self.new_local();
                        self.emit(&format!("  {} = icmp eq i64 {}, 0", cmp, val));
                        self.emit(&format!("  {} = zext i1 {} to i64", result, cmp));
                    }
                    UnaryOp::BitNot => {
                        self.emit(&format!("  {} = xor i64 {}, -1", result, val));
                    }
                }
                result
            }
            Expr::Call(name, args) => {
                let mut arg_vals = Vec::new();
                for arg in args {
                    arg_vals.push(self.emit_expr(arg));
                }
                let result = self.new_local();
                let args_str = arg_vals.iter().map(|a| format!("i64 {}", a)).collect::<Vec<_>>().join(", ");
                self.emit(&format!("  {} = call i64 @{}({})", result, name, args_str));
                result
            }
            Expr::BuiltinCall(name, args) => {
                if name == "__builtin_print" && !args.is_empty() {
                    let ch = self.emit_expr(&args[0]);
                    let trunc = self.new_local();
                    self.emit(&format!("  {} = trunc i64 {} to i32", trunc, ch));
                    self.emit(&format!("  call i32 @putchar(i32 {})", trunc));
                    "0".to_string()
                } else if name == "__builtin_exit" && !args.is_empty() {
                    let code = self.emit_expr(&args[0]);
                    let trunc = self.new_local();
                    self.emit(&format!("  {} = trunc i64 {} to i32", trunc, code));
                    self.emit(&format!("  call void @exit(i32 {})", trunc));
                    self.emit("  unreachable");
                    "0".to_string()
                } else if name == "__builtin_malloc" && !args.is_empty() {
                    let size = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    let result = self.new_local();
                    self.emit(&format!("  {} = call i8* @malloc(i64 {})", ptr, size));
                    self.emit(&format!("  {} = ptrtoint i8* {} to i64", result, ptr));
                    result
                } else if name == "__builtin_store8" && args.len() >= 2 {
                    let addr = self.emit_expr(&args[0]);
                    let val = self.emit_expr(&args[1]);
                    let ptr = self.new_local();
                    let trunc = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i8*", ptr, addr));
                    self.emit(&format!("  {} = trunc i64 {} to i8", trunc, val));
                    self.emit(&format!("  store i8 {}, i8* {}", trunc, ptr));
                    "0".to_string()
                } else if name == "__builtin_load8" && !args.is_empty() {
                    let addr = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    let val = self.new_local();
                    let result = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i8*", ptr, addr));
                    self.emit(&format!("  {} = load i8, i8* {}", val, ptr));
                    self.emit(&format!("  {} = zext i8 {} to i64", result, val));
                    result
                } else if name == "__builtin_store64" && args.len() >= 2 {
                    let addr = self.emit_expr(&args[0]);
                    let val = self.emit_expr(&args[1]);
                    let ptr = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i64*", ptr, addr));
                    self.emit(&format!("  store i64 {}, i64* {}", val, ptr));
                    "0".to_string()
                } else if name == "__builtin_load64" && !args.is_empty() {
                    let addr = self.emit_expr(&args[0]);
                    let ptr = self.new_local();
                    let result = self.new_local();
                    self.emit(&format!("  {} = inttoptr i64 {} to i64*", ptr, addr));
                    self.emit(&format!("  {} = load i64, i64* {}", result, ptr));
                    result
                } else {
                    "0".to_string()
                }
            }
        }
    }
    
    fn emit_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let { name, init } => {
                let ptr = format!("%{}", name);
                self.emit(&format!("  {} = alloca i64", ptr));
                self.locals.insert(name.clone(), ptr.clone());
                
                if let Some(expr) = init {
                    let val = self.emit_expr(expr);
                    self.emit(&format!("  store i64 {}, i64* {}", val, ptr));
                }
            }
            Stmt::Assign { target, value } => {
                let val = self.emit_expr(value);
                let ptr_opt = self.locals.get(target).cloned();
                if let Some(ptr) = ptr_opt {
                    self.emit(&format!("  store i64 {}, i64* {}", val, ptr));
                }
            }
            Stmt::Return(expr) => {
                let val = if let Some(e) = expr {
                    self.emit_expr(e)
                } else {
                    "0".to_string()
                };
                self.emit(&format!("  ret i64 {}", val));
            }
            Stmt::If { cond, then_block, else_block } => {
                let cond_val = self.emit_expr(cond);
                let cmp = self.new_local();
                self.emit(&format!("  {} = icmp ne i64 {}, 0", cmp, cond_val));
                
                let then_label = self.new_label();
                let else_label = self.new_label();
                let end_label = self.new_label();
                
                if else_block.is_some() {
                    self.emit(&format!("  br i1 {}, label %{}, label %{}", cmp, then_label, else_label));
                } else {
                    self.emit(&format!("  br i1 {}, label %{}, label %{}", cmp, then_label, end_label));
                }
                
                self.emit(&format!("{}:", then_label));
                for s in then_block {
                    self.emit_stmt(s);
                }
                self.emit(&format!("  br label %{}", end_label));
                
                if let Some(else_stmts) = else_block {
                    self.emit(&format!("{}:", else_label));
                    for s in else_stmts {
                        self.emit_stmt(s);
                    }
                    self.emit(&format!("  br label %{}", end_label));
                }
                
                self.emit(&format!("{}:", end_label));
            }
            Stmt::While { cond, body } => {
                let cond_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                self.emit(&format!("  br label %{}", cond_label));
                self.emit(&format!("{}:", cond_label));
                
                let cond_val = self.emit_expr(cond);
                let cmp = self.new_local();
                self.emit(&format!("  {} = icmp ne i64 {}, 0", cmp, cond_val));
                self.emit(&format!("  br i1 {}, label %{}, label %{}", cmp, body_label, end_label));
                
                self.emit(&format!("{}:", body_label));
                for s in body {
                    self.emit_stmt(s);
                }
                self.emit(&format!("  br label %{}", cond_label));
                
                self.emit(&format!("{}:", end_label));
            }
            Stmt::Expr(e) => {
                self.emit_expr(e);
            }
        }
    }
    
    fn emit_func(&mut self, func: &Func) {
        self.locals.clear();
        self.local_counter = 0;
        
        // Build parameter list
        let params_str = func.params.iter()
            .map(|p| format!("i64 %{}", p.name))
            .collect::<Vec<_>>()
            .join(", ");
        
        self.emit(&format!("define i64 @{}({}) {{", func.name, params_str));
        self.emit("entry:");
        
        // Store parameters as local variables
        for param in &func.params {
            let ptr = format!("%{}.addr", param.name);
            self.emit(&format!("  {} = alloca i64", ptr));
            self.emit(&format!("  store i64 %{}, i64* {}", param.name, ptr));
            self.locals.insert(param.name.clone(), ptr);
        }
        
        // Emit body
        let mut has_return = false;
        for stmt in &func.body {
            if matches!(stmt, Stmt::Return(_)) {
                has_return = true;
            }
            self.emit_stmt(stmt);
        }
        
        // Default return if none specified
        if !has_return {
            self.emit("  ret i64 0");
        }
        
        self.emit("}");
        self.emit("");
    }
    
    pub fn generate(&mut self, module: &Module) -> String {
        self.emit_header();
        
        for decl in &module.decls {
            if let Decl::Func(f) = decl {
                self.emit_func(f);
            }
        }
        
        self.output.clone()
    }
}

pub fn generate_llvm(module: &Module) -> String {
    let mut llvmgen = LLVMGen::new();
    llvmgen.generate(module)
}
