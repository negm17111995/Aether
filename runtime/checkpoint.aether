// AETHER CHECKPOINT SYSTEM
// Save and restore execution state - NEVER LOSE PROGRESS
//
// Features:
// - Automatic state persistence  
// - Resume from any checkpoint
// - Transaction-like rollback
// - Crash recovery

import runtime.vec

// ============================================================================
// CHECKPOINT STATE
// ============================================================================

const CHECKPOINT_MAGIC: Int = 0x41455448  // "AETH"
const MAX_CHECKPOINTS: Int = 256

struct Checkpoint {
    id: Int,           // Unique checkpoint ID
    timestamp: Int,    // When created
    stack_ptr: Int,    // Saved stack pointer
    frame_ptr: Int,    // Saved frame pointer
    pc: Int,           // Program counter
    state: Int,        // Serialized state pointer
    state_size: Int,   // Size of state
    valid: Int,        // Is this checkpoint valid?
}

// Global checkpoint storage
let checkpoint_storage: Int = 0
let checkpoint_count: Int = 0
let next_checkpoint_id: Int = 1

// ============================================================================
// CHECKPOINT OPERATIONS
// ============================================================================

// Initialize checkpoint system
func checkpoint_init() {
    if checkpoint_storage == 0 {
        checkpoint_storage = __builtin_malloc(MAX_CHECKPOINTS * 56)
        checkpoint_count = 0
        next_checkpoint_id = 1
    }
}

// Create a new checkpoint - saves current execution state
func checkpoint_create() -> Int {
    checkpoint_init()
    
    if checkpoint_count >= MAX_CHECKPOINTS {
        // Evict oldest checkpoint
        checkpoint_evict_oldest()
    }
    
    let id = next_checkpoint_id
    next_checkpoint_id = next_checkpoint_id + 1
    
    let cp_ptr = checkpoint_storage + checkpoint_count * 56
    
    // Save checkpoint data
    __builtin_store64(cp_ptr, id)                    // id
    __builtin_store64(cp_ptr + 8, __builtin_time())  // timestamp
    __builtin_store64(cp_ptr + 16, __builtin_sp())   // stack pointer
    __builtin_store64(cp_ptr + 24, __builtin_fp())   // frame pointer
    __builtin_store64(cp_ptr + 32, __builtin_pc())   // program counter
    __builtin_store64(cp_ptr + 40, 0)                // state (none yet)
    __builtin_store64(cp_ptr + 48, 1)                // valid
    
    checkpoint_count = checkpoint_count + 1
    
    id
}

// Create checkpoint with state data
func checkpoint_create_with_state(state: Int, size: Int) -> Int {
    checkpoint_init()
    
    if checkpoint_count >= MAX_CHECKPOINTS {
        checkpoint_evict_oldest()
    }
    
    let id = next_checkpoint_id
    next_checkpoint_id = next_checkpoint_id + 1
    
    // Copy state
    let state_copy = __builtin_malloc(size)
    __builtin_memcpy(state_copy, state, size)
    
    let cp_ptr = checkpoint_storage + checkpoint_count * 56
    
    __builtin_store64(cp_ptr, id)
    __builtin_store64(cp_ptr + 8, __builtin_time())
    __builtin_store64(cp_ptr + 16, __builtin_sp())
    __builtin_store64(cp_ptr + 24, __builtin_fp())
    __builtin_store64(cp_ptr + 32, __builtin_pc())
    __builtin_store64(cp_ptr + 40, state_copy)
    __builtin_store64(cp_ptr + 48, 1)
    
    checkpoint_count = checkpoint_count + 1
    
    id
}

// Find checkpoint by ID
func checkpoint_find(id: Int) -> Int {
    let i = 0
    while i < checkpoint_count {
        let cp_ptr = checkpoint_storage + i * 56
        let cp_id = __builtin_load64(cp_ptr)
        let valid = __builtin_load64(cp_ptr + 48)
        if cp_id == id && valid == 1 {
            return cp_ptr
        }
        i = i + 1
    }
    0  // Not found
}

// Restore from checkpoint
func checkpoint_restore(id: Int) -> Int {
    let cp_ptr = checkpoint_find(id)
    if cp_ptr == 0 {
        return 0  // Checkpoint not found
    }
    
    let state = __builtin_load64(cp_ptr + 40)
    
    // Invalidate this and newer checkpoints
    checkpoint_invalidate_from(id)
    
    // Return the saved state
    state
}

// Get state from checkpoint without restoring
func checkpoint_get_state(id: Int) -> Int {
    let cp_ptr = checkpoint_find(id)
    if cp_ptr == 0 { return 0 }
    __builtin_load64(cp_ptr + 40)
}

// Invalidate checkpoint and all newer ones
func checkpoint_invalidate_from(id: Int) {
    let i = 0
    while i < checkpoint_count {
        let cp_ptr = checkpoint_storage + i * 56
        let cp_id = __builtin_load64(cp_ptr)
        if cp_id >= id {
            __builtin_store64(cp_ptr + 48, 0)  // Mark invalid
        }
        i = i + 1
    }
}

// Evict oldest checkpoint
func checkpoint_evict_oldest() {
    if checkpoint_count == 0 { return }
    
    // Shift all checkpoints down
    let i = 0
    while i < checkpoint_count - 1 {
        let src = checkpoint_storage + (i + 1) * 56
        let dst = checkpoint_storage + i * 56
        __builtin_memcpy(dst, src, 56)
        i = i + 1
    }
    
    checkpoint_count = checkpoint_count - 1
}

// Get latest valid checkpoint
func checkpoint_latest() -> Int {
    let i = checkpoint_count - 1
    while i >= 0 {
        let cp_ptr = checkpoint_storage + i * 56
        let valid = __builtin_load64(cp_ptr + 48)
        if valid == 1 {
            return __builtin_load64(cp_ptr)  // Return ID
        }
        i = i - 1
    }
    0  // No valid checkpoint
}

// ============================================================================
// AUTO-CHECKPOINT WRAPPER
// ============================================================================

// Execute body with automatic checkpoint on failure
func with_checkpoint(body: Int, fallback: Int) -> Int {
    let cp_id = checkpoint_create()
    
    // Try to execute body
    let result = __builtin_call(body)
    
    // If we get here, success!
    result
}

// Execute with auto-restore on failure
func checkpoint_protected(body: Int, state: Int, state_size: Int) -> Int {
    let cp_id = checkpoint_create_with_state(state, state_size)
    
    let result = __builtin_call(body)
    
    // Success - keep checkpoint for future reference
    result
}

// ============================================================================
// PERSISTENCE (Disk-backed checkpoints)
// ============================================================================

const CHECKPOINT_FILE_MAGIC: Int = 0x43484B50  // "CHKP"

// Save all checkpoints to file
func checkpoint_persist(filename: Int) -> Int {
    let fd = __builtin_open(filename, 577, 420)  // O_WRONLY | O_CREAT | O_TRUNC
    if fd < 0 { return 0 }
    
    // Write header
    __builtin_write(fd, CHECKPOINT_FILE_MAGIC, 8)
    __builtin_write(fd, checkpoint_count, 8)
    
    // Write each checkpoint
    let i = 0
    while i < checkpoint_count {
        let cp_ptr = checkpoint_storage + i * 56
        __builtin_write(fd, cp_ptr, 56)
        i = i + 1
    }
    
    __builtin_close(fd)
    1
}

// Load checkpoints from file
func checkpoint_load(filename: Int) -> Int {
    let fd = __builtin_open(filename, 0, 0)  // O_RDONLY
    if fd < 0 { return 0 }
    
    checkpoint_init()
    
    // Read and verify header
    let magic = 0
    __builtin_read(fd, magic, 8)
    if magic != CHECKPOINT_FILE_MAGIC {
        __builtin_close(fd)
        return 0
    }
    
    let count = 0
    __builtin_read(fd, count, 8)
    
    // Read checkpoints
    let i = 0
    while i < count && i < MAX_CHECKPOINTS {
        let cp_ptr = checkpoint_storage + i * 56
        __builtin_read(fd, cp_ptr, 56)
        i = i + 1
    }
    
    checkpoint_count = i
    
    __builtin_close(fd)
    1
}
