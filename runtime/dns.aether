// AETHER DNS - Pure Aether DNS Resolution
// Query DNS servers for hostname to IP resolution
// No external dependencies - 100% Pure Aether

// ============================================================================
// DNS CONSTANTS
// ============================================================================

const AF_INET: Int = 2
const SOCK_DGRAM: Int = 2
const DNS_PORT: Int = 53

// DNS record types
const DNS_A: Int = 1        // IPv4 address
const DNS_AAAA: Int = 28    // IPv6 address
const DNS_CNAME: Int = 5    // Canonical name

// DNS classes
const DNS_IN: Int = 1       // Internet

// Google Public DNS
const DNS_SERVER_A: Int = 8
const DNS_SERVER_B: Int = 8
const DNS_SERVER_C: Int = 8
const DNS_SERVER_D: Int = 8

// Cloudflare DNS (backup)
const DNS_SERVER2_A: Int = 1
const DNS_SERVER2_B: Int = 1
const DNS_SERVER2_C: Int = 1
const DNS_SERVER2_D: Int = 1

// ============================================================================
// DNS RESULT STRUCTURE
// [success, ip_a, ip_b, ip_c, ip_d]
// ============================================================================

func dns_result_new() -> Int {
    let result = __builtin_malloc(40)
    __builtin_store64(result, 0)      // success = false
    __builtin_store64(result + 8, 0)  // ip_a
    __builtin_store64(result + 16, 0) // ip_b
    __builtin_store64(result + 24, 0) // ip_c
    __builtin_store64(result + 32, 0) // ip_d
    result
}

func dns_result_success(r: Int) -> Int { __builtin_load64(r) }
func dns_result_ip_a(r: Int) -> Int { __builtin_load64(r + 8) }
func dns_result_ip_b(r: Int) -> Int { __builtin_load64(r + 16) }
func dns_result_ip_c(r: Int) -> Int { __builtin_load64(r + 24) }
func dns_result_ip_d(r: Int) -> Int { __builtin_load64(r + 32) }

// ============================================================================
// BUILD DNS QUERY
// ============================================================================

func dns_build_query(hostname: Int, query: Int) -> Int {
    let pos = 0
    
    // Transaction ID (random-ish)
    __builtin_store8(query + pos, 0xAB)
    pos = pos + 1
    __builtin_store8(query + pos, 0xCD)
    pos = pos + 1
    
    // Flags: Standard query, recursion desired
    __builtin_store8(query + pos, 0x01)
    pos = pos + 1
    __builtin_store8(query + pos, 0x00)
    pos = pos + 1
    
    // Questions: 1
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, 1)
    pos = pos + 1
    
    // Answers, Authority, Additional: 0
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    
    // Question: hostname in DNS format (labels)
    let host_pos = 0
    while __builtin_load8(hostname + host_pos) != 0 {
        // Find next dot or end
        let label_start = host_pos
        while __builtin_load8(hostname + host_pos) != 0 && __builtin_load8(hostname + host_pos) != 46 {
            host_pos = host_pos + 1
        }
        let label_len = host_pos - label_start
        
        // Write label length
        __builtin_store8(query + pos, label_len)
        pos = pos + 1
        
        // Write label
        let i = 0
        while i < label_len {
            __builtin_store8(query + pos, __builtin_load8(hostname + label_start + i))
            pos = pos + 1
            i = i + 1
        }
        
        // Skip dot
        if __builtin_load8(hostname + host_pos) == 46 {
            host_pos = host_pos + 1
        }
    }
    
    // Null terminator for name
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    
    // Type: A (IPv4)
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, DNS_A)
    pos = pos + 1
    
    // Class: IN (Internet)
    __builtin_store8(query + pos, 0)
    pos = pos + 1
    __builtin_store8(query + pos, DNS_IN)
    pos = pos + 1
    
    pos
}

// ============================================================================
// PARSE DNS RESPONSE
// ============================================================================

func dns_parse_response(response: Int, len: Int, result: Int) {
    // Skip header (12 bytes)
    let pos = 12
    
    // Skip question section
    while __builtin_load8(response + pos) != 0 {
        let label_len = __builtin_load8(response + pos)
        pos = pos + label_len + 1
    }
    pos = pos + 1  // Skip null
    pos = pos + 4  // Skip QTYPE and QCLASS
    
    // Parse answer section
    // Check answer count from header
    let ancount = __builtin_load8(response + 6) * 256 + __builtin_load8(response + 7)
    
    let ans = 0
    while ans < ancount && pos < len {
        // Check for pointer (compression)
        if (__builtin_load8(response + pos) & 0xC0) == 0xC0 {
            pos = pos + 2  // Skip pointer
        } else {
            // Skip name labels
            while __builtin_load8(response + pos) != 0 {
                let label_len = __builtin_load8(response + pos)
                pos = pos + label_len + 1
            }
            pos = pos + 1  // Skip null
        }
        
        // Read TYPE
        let rtype = __builtin_load8(response + pos) * 256 + __builtin_load8(response + pos + 1)
        pos = pos + 2
        
        // Skip CLASS
        pos = pos + 2
        
        // Skip TTL
        pos = pos + 4
        
        // Read RDLENGTH
        let rdlen = __builtin_load8(response + pos) * 256 + __builtin_load8(response + pos + 1)
        pos = pos + 2
        
        // If type A and length 4, we have an IP
        if rtype == DNS_A && rdlen == 4 {
            __builtin_store64(result, 1)  // success
            __builtin_store64(result + 8, __builtin_load8(response + pos))
            __builtin_store64(result + 16, __builtin_load8(response + pos + 1))
            __builtin_store64(result + 24, __builtin_load8(response + pos + 2))
            __builtin_store64(result + 32, __builtin_load8(response + pos + 3))
            return
        }
        
        pos = pos + rdlen
        ans = ans + 1
    }
}

// ============================================================================
// DNS RESOLVE
// ============================================================================

func dns_resolve(hostname: Int) -> Int {
    let result = dns_result_new()
    
    // Check for localhost
    if dns_is_localhost(hostname) {
        __builtin_store64(result, 1)
        __builtin_store64(result + 8, 127)
        __builtin_store64(result + 16, 0)
        __builtin_store64(result + 24, 0)
        __builtin_store64(result + 32, 1)
        return result
    }
    
    // Create UDP socket
    let fd = __builtin_socket(AF_INET, SOCK_DGRAM, 0)
    if fd < 0 { return result }
    
    // Build sockaddr for DNS server
    let addr = __builtin_malloc(16)
    __builtin_store8(addr, 16)
    __builtin_store8(addr + 1, 2)
    __builtin_store8(addr + 2, 0)    // port 53 high
    __builtin_store8(addr + 3, 53)   // port 53 low
    __builtin_store8(addr + 4, DNS_SERVER_A)
    __builtin_store8(addr + 5, DNS_SERVER_B)
    __builtin_store8(addr + 6, DNS_SERVER_C)
    __builtin_store8(addr + 7, DNS_SERVER_D)
    __builtin_store64(addr + 8, 0)
    
    // Connect (for UDP this sets default destination)
    let conn_result = __builtin_connect(fd, addr, 16)
    if conn_result < 0 {
        __builtin_close(fd)
        return result
    }
    
    // Build and send query
    let query = __builtin_malloc(512)
    let query_len = dns_build_query(hostname, query)
    __builtin_write(fd, query, query_len)
    
    // Receive response (with timeout - simplified)
    let response = __builtin_malloc(512)
    let resp_len = __builtin_read(fd, response, 512)
    
    __builtin_close(fd)
    
    if resp_len > 12 {
        dns_parse_response(response, resp_len, result)
    }
    
    result
}

func dns_is_localhost(hostname: Int) -> Int {
    // Check if hostname is "localhost"
    if __builtin_load8(hostname) != 108 { return 0 }     // l
    if __builtin_load8(hostname + 1) != 111 { return 0 } // o
    if __builtin_load8(hostname + 2) != 99 { return 0 }  // c
    if __builtin_load8(hostname + 3) != 97 { return 0 }  // a
    if __builtin_load8(hostname + 4) != 108 { return 0 } // l
    if __builtin_load8(hostname + 5) != 104 { return 0 } // h
    if __builtin_load8(hostname + 6) != 111 { return 0 } // o
    if __builtin_load8(hostname + 7) != 115 { return 0 } // s
    if __builtin_load8(hostname + 8) != 116 { return 0 } // t
    if __builtin_load8(hostname + 9) != 0 { return 0 }
    1
}

// ============================================================================
// HIGH-LEVEL API
// ============================================================================

func dns_lookup(hostname: Int) -> Int {
    dns_resolve(hostname)
}

func tcp_connect_hostname(hostname: Int, port: Int) -> Int {
    let result = dns_resolve(hostname)
    if dns_result_success(result) == 0 {
        return 0 - 1
    }
    
    let ip_a = dns_result_ip_a(result)
    let ip_b = dns_result_ip_b(result)
    let ip_c = dns_result_ip_c(result)
    let ip_d = dns_result_ip_d(result)
    
    // Create and connect socket
    let fd = __builtin_socket(AF_INET, 1, 0)  // SOCK_STREAM = 1
    if fd < 0 { return fd }
    
    let addr = __builtin_malloc(16)
    __builtin_store8(addr, 16)
    __builtin_store8(addr + 1, 2)
    __builtin_store8(addr + 2, port / 256)
    __builtin_store8(addr + 3, port % 256)
    __builtin_store8(addr + 4, ip_a)
    __builtin_store8(addr + 5, ip_b)
    __builtin_store8(addr + 6, ip_c)
    __builtin_store8(addr + 7, ip_d)
    __builtin_store64(addr + 8, 0)
    
    let conn = __builtin_connect(fd, addr, 16)
    if conn < 0 {
        __builtin_close(fd)
        return 0 - 1
    }
    
    fd
}
