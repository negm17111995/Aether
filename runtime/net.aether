// AETHER NETWORKING - Pure Aether TCP/UDP Implementation
// Uses __builtin_socket/connect/bind/listen/accept/sendto/recvfrom syscalls
// No external dependencies - Real networking!

// ============================================================================
// CONSTANTS
// ============================================================================

const AF_INET: Int = 2           // IPv4
const AF_INET6: Int = 30         // IPv6 (macOS)/10 (Linux)
const SOCK_STREAM: Int = 1       // TCP
const SOCK_DGRAM: Int = 2        // UDP
const SOL_SOCKET: Int = 0xFFFF   // Socket level (macOS)
const SO_REUSEADDR: Int = 4      // Reuse address option

// ============================================================================
// SOCKET CREATION
// ============================================================================

// Create a TCP socket - returns fd or -1 on error
func tcp_socket() -> Int {
    __builtin_socket(AF_INET, SOCK_STREAM, 0)
}

// Create a UDP socket - returns fd or -1 on error
func udp_socket() -> Int {
    __builtin_socket(AF_INET, SOCK_DGRAM, 0)
}

// ============================================================================
// SOCKADDR_IN STRUCTURE BUILDING
// ============================================================================

// Build sockaddr_in structure for IPv4
// sockaddr_in layout (16 bytes):
//   0: sin_len (1 byte) + sin_family (1 byte) - macOS specific
//   2: sin_port (2 bytes, big-endian)
//   4: sin_addr (4 bytes, big-endian)
//   8: sin_zero (8 bytes padding)
func sockaddr_in_new(ip_a: Int, ip_b: Int, ip_c: Int, ip_d: Int, port: Int) -> Int {
    let addr = __builtin_malloc(16)
    // sin_len (macOS) + sin_family
    __builtin_store8(addr, 16)      // sin_len = 16
    __builtin_store8(addr + 1, 2)   // sin_family = AF_INET
    // sin_port (big-endian)
    __builtin_store8(addr + 2, port / 256)
    __builtin_store8(addr + 3, port % 256)
    // sin_addr (a.b.c.d)
    __builtin_store8(addr + 4, ip_a)
    __builtin_store8(addr + 5, ip_b)
    __builtin_store8(addr + 6, ip_c)
    __builtin_store8(addr + 7, ip_d)
    // sin_zero (padding)
    __builtin_store64(addr + 8, 0)
    addr
}

// Build sockaddr_in for any interface (0.0.0.0)
func sockaddr_in_any(port: Int) -> Int {
    sockaddr_in_new(0, 0, 0, 0, port)
}

// Build sockaddr_in for localhost (127.0.0.1)
func sockaddr_in_localhost(port: Int) -> Int {
    sockaddr_in_new(127, 0, 0, 1, port)
}

// ============================================================================
// TCP CLIENT
// ============================================================================

// Connect to a TCP server - returns fd or -1 on error
func tcp_connect_ip(ip_a: Int, ip_b: Int, ip_c: Int, ip_d: Int, port: Int) -> Int {
    let fd = tcp_socket()
    if fd < 0 { return fd }
    
    let addr = sockaddr_in_new(ip_a, ip_b, ip_c, ip_d, port)
    let result = __builtin_connect(fd, addr, 16)
    
    if result < 0 {
        __builtin_close(fd)
        return 0 - 1
    }
    
    fd
}

// Send data on a connected socket - returns bytes sent or -1
func tcp_send(fd: Int, buf: Int, len: Int) -> Int {
    __builtin_write(fd, buf, len)
}

// Receive data on a connected socket - returns bytes received or -1
func tcp_recv(fd: Int, buf: Int, max_len: Int) -> Int {
    __builtin_read(fd, buf, max_len)
}

// Close a socket
func tcp_close(fd: Int) {
    __builtin_close(fd)
}

// ============================================================================
// TCP SERVER
// ============================================================================

// Create, bind and listen on a TCP port - returns fd or -1
func tcp_listen(port: Int, backlog: Int) -> Int {
    let fd = tcp_socket()
    if fd < 0 { return fd }
    
    // Set SO_REUSEADDR
    let optval = __builtin_malloc(4)
    __builtin_store32(optval, 1)
    __builtin_setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, optval, 4)
    
    // Bind to all interfaces
    let addr = sockaddr_in_any(port)
    let result = __builtin_bind(fd, addr, 16)
    if result < 0 {
        __builtin_close(fd)
        return 0 - 1
    }
    
    // Start listening
    result = __builtin_listen(fd, backlog)
    if result < 0 {
        __builtin_close(fd)
        return 0 - 1
    }
    
    fd
}

// Accept an incoming connection - returns new fd or -1
func tcp_accept(server_fd: Int) -> Int {
    // Accept with NULL for client address (we don't need it)
    __builtin_accept(server_fd, 0, 0)
}

// ============================================================================
// HTTP HELPERS (Simple GET request)
// ============================================================================

// Build HTTP GET request string
// Returns pointer to request string
func http_get_request(host: Int, path: Int) -> Int {
    // Allocate buffer for request
    let buf = __builtin_malloc(1024)
    let pos = 0
    
    // "GET "
    __builtin_store8(buf + pos, 71)  // G
    pos = pos + 1
    __builtin_store8(buf + pos, 69)  // E
    pos = pos + 1
    __builtin_store8(buf + pos, 84)  // T
    pos = pos + 1
    __builtin_store8(buf + pos, 32)  // space
    pos = pos + 1
    
    // path
    let i = 0
    while __builtin_load8(path + i) != 0 {
        __builtin_store8(buf + pos, __builtin_load8(path + i))
        pos = pos + 1
        i = i + 1
    }
    
    // " HTTP/1.1\r\nHost: "
    __builtin_store8(buf + pos, 32)   // space
    pos = pos + 1
    __builtin_store8(buf + pos, 72)   // H
    pos = pos + 1
    __builtin_store8(buf + pos, 84)   // T
    pos = pos + 1
    __builtin_store8(buf + pos, 84)   // T
    pos = pos + 1
    __builtin_store8(buf + pos, 80)   // P
    pos = pos + 1
    __builtin_store8(buf + pos, 47)   // /
    pos = pos + 1
    __builtin_store8(buf + pos, 49)   // 1
    pos = pos + 1
    __builtin_store8(buf + pos, 46)   // .
    pos = pos + 1
    __builtin_store8(buf + pos, 49)   // 1
    pos = pos + 1
    __builtin_store8(buf + pos, 13)   // \r
    pos = pos + 1
    __builtin_store8(buf + pos, 10)   // \n
    pos = pos + 1
    __builtin_store8(buf + pos, 72)   // H
    pos = pos + 1
    __builtin_store8(buf + pos, 111)  // o
    pos = pos + 1
    __builtin_store8(buf + pos, 115)  // s
    pos = pos + 1
    __builtin_store8(buf + pos, 116)  // t
    pos = pos + 1
    __builtin_store8(buf + pos, 58)   // :
    pos = pos + 1
    __builtin_store8(buf + pos, 32)   // space
    pos = pos + 1
    
    // host
    i = 0
    while __builtin_load8(host + i) != 0 {
        __builtin_store8(buf + pos, __builtin_load8(host + i))
        pos = pos + 1
        i = i + 1
    }
    
    // "\r\nConnection: close\r\n\r\n"
    __builtin_store8(buf + pos, 13)   // \r
    pos = pos + 1
    __builtin_store8(buf + pos, 10)   // \n
    pos = pos + 1
    __builtin_store8(buf + pos, 67)   // C
    pos = pos + 1
    __builtin_store8(buf + pos, 111)  // o
    pos = pos + 1
    __builtin_store8(buf + pos, 110)  // n
    pos = pos + 1
    __builtin_store8(buf + pos, 110)  // n
    pos = pos + 1
    __builtin_store8(buf + pos, 101)  // e
    pos = pos + 1
    __builtin_store8(buf + pos, 99)   // c
    pos = pos + 1
    __builtin_store8(buf + pos, 116)  // t
    pos = pos + 1
    __builtin_store8(buf + pos, 105)  // i
    pos = pos + 1
    __builtin_store8(buf + pos, 111)  // o
    pos = pos + 1
    __builtin_store8(buf + pos, 110)  // n
    pos = pos + 1
    __builtin_store8(buf + pos, 58)   // :
    pos = pos + 1
    __builtin_store8(buf + pos, 32)   // space
    pos = pos + 1
    __builtin_store8(buf + pos, 99)   // c
    pos = pos + 1
    __builtin_store8(buf + pos, 108)  // l
    pos = pos + 1
    __builtin_store8(buf + pos, 111)  // o
    pos = pos + 1
    __builtin_store8(buf + pos, 115)  // s
    pos = pos + 1
    __builtin_store8(buf + pos, 101)  // e
    pos = pos + 1
    __builtin_store8(buf + pos, 13)   // \r
    pos = pos + 1
    __builtin_store8(buf + pos, 10)   // \n
    pos = pos + 1
    __builtin_store8(buf + pos, 13)   // \r
    pos = pos + 1
    __builtin_store8(buf + pos, 10)   // \n
    pos = pos + 1
    __builtin_store8(buf + pos, 0)    // null terminator
    
    buf
}

// Perform HTTP GET and return response body
// Returns pointer to response buffer or 0 on error
func http_get(ip_a: Int, ip_b: Int, ip_c: Int, ip_d: Int, port: Int, host: Int, path: Int) -> Int {
    let fd = tcp_connect_ip(ip_a, ip_b, ip_c, ip_d, port)
    if fd < 0 { return 0 }
    
    // Build and send request
    let request = http_get_request(host, path)
    let req_len = str_len_net(request)
    tcp_send(fd, request, req_len)
    
    // Read response (up to 64KB)
    let response = __builtin_malloc(65536)
    let total = 0
    let done = 0
    
    while done == 0 {
        let n = tcp_recv(fd, response + total, 65536 - total)
        if n <= 0 { done = 1 }
        else { total = total + n }
    }
    
    __builtin_store8(response + total, 0)
    tcp_close(fd)
    
    response
}

// Helper: string length
func str_len_net(s: Int) -> Int {
    let i = 0
    while __builtin_load8(s + i) != 0 { i = i + 1 }
    i
}
