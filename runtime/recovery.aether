// AETHER CRASH RECOVERY SYSTEM
// NEVER LOSE WORK - Automatic crash detection and recovery
//
// Features:
// - Pre-crash state capture
// - Automatic recovery on restart
// - Operation journaling
// - Idempotent replay

import runtime.checkpoint
import runtime.temporal

// ============================================================================
// RECOVERY CONSTANTS
// ============================================================================

const RECOVERY_MAGIC: Int = 0x52454356  // "RECV"
const RECOVERY_VERSION: Int = 1

const RECOVERY_STATE_CLEAN: Int = 0
const RECOVERY_STATE_RUNNING: Int = 1
const RECOVERY_STATE_CRASHED: Int = 2
const RECOVERY_STATE_RECOVERING: Int = 3

// Journal operation types  
const JOURNAL_OP_START: Int = 0
const JOURNAL_OP_CHECKPOINT: Int = 1
const JOURNAL_OP_COMPLETE: Int = 2
const JOURNAL_OP_FAILED: Int = 3

// ============================================================================
// RECOVERY STATE
// ============================================================================

struct RecoveryState {
    magic: Int,
    version: Int,
    state: Int,
    last_checkpoint: Int,
    journal_ptr: Int,
    journal_len: Int,
}

let recovery_file: Int = 0  // Path to recovery file
let recovery_state: Int = 0

// ============================================================================
// RECOVERY INITIALIZATION
// ============================================================================

// Initialize recovery system
func recovery_init(path: Int) -> Int {
    recovery_file = path
    
    // Try to load existing recovery state
    if recovery_load() == 1 {
        // Check if we crashed
        let state = __builtin_load64(recovery_state + 16)
        if state == RECOVERY_STATE_RUNNING {
            // We crashed! Mark for recovery
            __builtin_store64(recovery_state + 16, RECOVERY_STATE_CRASHED)
            recovery_save()
            return RECOVERY_STATE_CRASHED
        }
        return state
    }
    
    // Create new recovery state
    recovery_state = __builtin_malloc(48)
    __builtin_store64(recovery_state, RECOVERY_MAGIC)
    __builtin_store64(recovery_state + 8, RECOVERY_VERSION)
    __builtin_store64(recovery_state + 16, RECOVERY_STATE_CLEAN)
    __builtin_store64(recovery_state + 24, 0)  // no checkpoint
    __builtin_store64(recovery_state + 32, 0)  // no journal
    __builtin_store64(recovery_state + 40, 0)  // journal len
    
    recovery_save()
    RECOVERY_STATE_CLEAN
}

// ============================================================================
// RECOVERY FILE I/O
// ============================================================================

// Save recovery state to disk
func recovery_save() -> Int {
    if recovery_file == 0 { return 0 }
    
    let fd = __builtin_open(recovery_file, 577, 420)  // O_WRONLY | O_CREAT | O_TRUNC
    if fd < 0 { return 0 }
    
    __builtin_write(fd, recovery_state, 48)
    __builtin_close(fd)
    1
}

// Load recovery state from disk
func recovery_load() -> Int {
    if recovery_file == 0 { return 0 }
    
    let fd = __builtin_open(recovery_file, 0, 0)  // O_RDONLY
    if fd < 0 { return 0 }
    
    if recovery_state == 0 {
        recovery_state = __builtin_malloc(48)
    }
    
    __builtin_read(fd, recovery_state, 48)
    __builtin_close(fd)
    
    // Verify magic
    let magic = __builtin_load64(recovery_state)
    if magic != RECOVERY_MAGIC { return 0 }
    
    1
}

// ============================================================================
// RECOVERY OPERATIONS
// ============================================================================

// Mark operation start
func recovery_begin() {
    if recovery_state == 0 { return }
    
    __builtin_store64(recovery_state + 16, RECOVERY_STATE_RUNNING)
    
    // Create checkpoint
    let cp = checkpoint_create()
    __builtin_store64(recovery_state + 24, cp)
    
    // Journal: start
    recovery_journal_append(JOURNAL_OP_START, cp)
    
    recovery_save()
}

// Mark operation complete
func recovery_end() {
    if recovery_state == 0 { return }
    
    __builtin_store64(recovery_state + 16, RECOVERY_STATE_CLEAN)
    
    // Journal: complete
    recovery_journal_append(JOURNAL_OP_COMPLETE, 0)
    
    recovery_save()
}

// Recover from crash
func recovery_recover() -> Int {
    if recovery_state == 0 { return 0 }
    
    let state = __builtin_load64(recovery_state + 16)
    if state != RECOVERY_STATE_CRASHED { return 0 }
    
    __builtin_store64(recovery_state + 16, RECOVERY_STATE_RECOVERING)
    recovery_save()
    
    // Get last checkpoint
    let cp = __builtin_load64(recovery_state + 24)
    if cp != 0 {
        // Restore from checkpoint
        let restored = checkpoint_restore(cp)
        
        __builtin_store64(recovery_state + 16, RECOVERY_STATE_CLEAN)
        recovery_save()
        
        return restored
    }
    
    __builtin_store64(recovery_state + 16, RECOVERY_STATE_CLEAN)
    recovery_save()
    0
}

// Check if recovery is needed
func recovery_needed() -> Int {
    if recovery_state == 0 { return 0 }
    
    let state = __builtin_load64(recovery_state + 16)
    if state == RECOVERY_STATE_CRASHED { return 1 }
    0
}

// ============================================================================
// OPERATION JOURNALING
// ============================================================================

const MAX_JOURNAL_ENTRIES: Int = 1024

struct JournalEntry {
    op: Int,
    data: Int,
    timestamp: Int,
}

let journal_storage: Int = 0
let journal_count: Int = 0

// Initialize journal
func recovery_journal_init() {
    if journal_storage == 0 {
        journal_storage = __builtin_malloc(MAX_JOURNAL_ENTRIES * 24)
        journal_count = 0
    }
}

// Append to journal
func recovery_journal_append(op: Int, data: Int) {
    recovery_journal_init()
    
    if journal_count >= MAX_JOURNAL_ENTRIES {
        // Compact journal
        journal_count = 0
    }
    
    let entry = journal_storage + journal_count * 24
    __builtin_store64(entry, op)
    __builtin_store64(entry + 8, data)
    __builtin_store64(entry + 16, __builtin_time())
    
    journal_count = journal_count + 1
}

// Get journal length
func recovery_journal_len() -> Int {
    journal_count
}

// Get journal entry
func recovery_journal_get(idx: Int) -> Int {
    if idx < 0 || idx >= journal_count { return 0 }
    journal_storage + idx * 24
}

// ============================================================================
// IDEMPOTENT OPERATIONS
// ============================================================================

// Operation tracking for idempotency
const MAX_OPERATIONS: Int = 256

struct OperationRecord {
    id: Int,
    hash: Int,
    result: Int,
    completed: Int,
}

let operation_table: Int = 0
let operation_count: Int = 0

// Check if operation was already completed
func operation_check(op_id: Int, op_hash: Int) -> Int {
    if operation_table == 0 { return -1 }  // Not found
    
    let i = 0
    while i < operation_count {
        let record = operation_table + i * 32
        let rid = __builtin_load64(record)
        let rhash = __builtin_load64(record + 8)
        let completed = __builtin_load64(record + 24)
        
        if rid == op_id && rhash == op_hash && completed == 1 {
            // Already completed - return cached result
            return __builtin_load64(record + 16)
        }
        i = i + 1
    }
    -1  // Not found
}

// Record operation completion
func operation_complete(op_id: Int, op_hash: Int, result: Int) {
    if operation_table == 0 {
        operation_table = __builtin_malloc(MAX_OPERATIONS * 32)
        operation_count = 0
    }
    
    if operation_count >= MAX_OPERATIONS {
        // Evict oldest
        operation_count = 0
    }
    
    let record = operation_table + operation_count * 32
    __builtin_store64(record, op_id)
    __builtin_store64(record + 8, op_hash)
    __builtin_store64(record + 16, result)
    __builtin_store64(record + 24, 1)  // completed
    
    operation_count = operation_count + 1
}

// Execute operation idempotently
func idempotent(op_id: Int, op_hash: Int, body: Int) -> Int {
    // Check if already completed
    let cached = operation_check(op_id, op_hash)
    if cached != -1 {
        return cached
    }
    
    // Execute
    let result = __builtin_call(body)
    
    // Record completion
    operation_complete(op_id, op_hash, result)
    
    result
}

// ============================================================================
// SAFE WRAPPER
// ============================================================================

// Execute with full crash recovery
func crash_safe(body: Int) -> Int {
    // Check for pending recovery
    if recovery_needed() == 1 {
        let recovered = recovery_recover()
        if recovered != 0 {
            return recovered
        }
    }
    
    // Start protected execution
    recovery_begin()
    
    let result = __builtin_call(body)
    
    // Mark complete
    recovery_end()
    
    result
}
