// AETHER PROFILER - Lightweight Execution Profiling
// Tracks function call counts and execution times for hot path detection
// Memory: <4KB for 1000 functions | Overhead: <1% CPU
//
// This module is essential for the "Living Binary" feature.
// The compiler inserts profiler_enter/exit calls at function boundaries.
// A background thread periodically queries hot paths for JIT recompilation.

import runtime.vec

// ============================================================================
// PROFILER CONSTANTS
// ============================================================================

const MAX_TRACKED_FUNCTIONS: Int = 1024
const HOT_THRESHOLD_CALLS: Int = 10000      // Calls before considered "hot"
const HOT_THRESHOLD_TIME_US: Int = 100000   // 100ms total time before "hot"
const PROFILER_MAGIC: Int = 0x50524F46      // "PROF"

// ============================================================================
// FUNCTION PROFILE ENTRY
// Layout: [func_id, call_count, total_time_us, last_entry_time, flags]
// Size: 40 bytes per entry
// ============================================================================

const PROFILE_ENTRY_SIZE: Int = 40

func profile_entry_func_id(entry: Int) -> Int { __builtin_load64(entry) }
func profile_entry_call_count(entry: Int) -> Int { __builtin_load64(entry + 8) }
func profile_entry_total_time(entry: Int) -> Int { __builtin_load64(entry + 16) }
func profile_entry_last_entry(entry: Int) -> Int { __builtin_load64(entry + 24) }
func profile_entry_flags(entry: Int) -> Int { __builtin_load64(entry + 32) }

func profile_entry_set_call_count(entry: Int, count: Int) { __builtin_store64(entry + 8, count) }
func profile_entry_set_total_time(entry: Int, time: Int) { __builtin_store64(entry + 16, time) }
func profile_entry_set_last_entry(entry: Int, time: Int) { __builtin_store64(entry + 24, time) }
func profile_entry_set_flags(entry: Int, flags: Int) { __builtin_store64(entry + 32, flags) }

// Flags
const PROFILE_FLAG_HOT: Int = 1         // Function is hot
const PROFILE_FLAG_OPTIMIZED: Int = 2   // Already JIT-optimized
const PROFILE_FLAG_BLACKLIST: Int = 4   // Don't optimize (e.g., intrinsics)

// ============================================================================
// GLOBAL PROFILER STATE
// ============================================================================

let profiler_storage: Int = 0
let profiler_count: Int = 0
let profiler_enabled: Int = 0
let profiler_sample_rate: Int = 1       // 1 = every call, 10 = every 10th call

// ============================================================================
// PROFILER INITIALIZATION
// ============================================================================

// Initialize the profiler system
func profiler_init() {
    if profiler_storage == 0 {
        // Allocate storage for function profiles
        profiler_storage = __builtin_malloc(MAX_TRACKED_FUNCTIONS * PROFILE_ENTRY_SIZE)
        
        // Zero-initialize all entries
        let i = 0
        while i < MAX_TRACKED_FUNCTIONS * PROFILE_ENTRY_SIZE {
            __builtin_store8(profiler_storage + i, 0)
            i = i + 1
        }
        
        profiler_count = 0
        profiler_enabled = 1
    }
}

// Enable profiling
func profiler_enable() {
    profiler_enabled = 1
}

// Disable profiling (for benchmarking without overhead)
func profiler_disable() {
    profiler_enabled = 0
}

// Set sample rate (1 = all, N = every Nth call)
func profiler_set_sample_rate(rate: Int) {
    if rate < 1 { rate = 1 }
    profiler_sample_rate = rate
}

// ============================================================================
// FUNCTION REGISTRATION AND LOOKUP
// ============================================================================

// Find or create profile entry for a function
func profiler_get_entry(func_id: Int) -> Int {
    // Linear scan for existing entry
    let i = 0
    while i < profiler_count {
        let entry = profiler_storage + i * PROFILE_ENTRY_SIZE
        if profile_entry_func_id(entry) == func_id {
            return entry
        }
        i = i + 1
    }
    
    // Not found - create new entry
    if profiler_count >= MAX_TRACKED_FUNCTIONS {
        // Storage full - evict coldest function
        profiler_evict_coldest()
    }
    
    let entry = profiler_storage + profiler_count * PROFILE_ENTRY_SIZE
    __builtin_store64(entry, func_id)           // func_id
    __builtin_store64(entry + 8, 0)             // call_count
    __builtin_store64(entry + 16, 0)            // total_time
    __builtin_store64(entry + 24, 0)            // last_entry
    __builtin_store64(entry + 32, 0)            // flags
    
    profiler_count = profiler_count + 1
    entry
}

// Evict the coldest (least called) function to make room
func profiler_evict_coldest() {
    if profiler_count == 0 { return }
    
    let min_calls = 999999999
    let min_idx = 0
    
    let i = 0
    while i < profiler_count {
        let entry = profiler_storage + i * PROFILE_ENTRY_SIZE
        let calls = profile_entry_call_count(entry)
        let flags = profile_entry_flags(entry)
        
        // Don't evict hot or optimized functions
        if (flags & (PROFILE_FLAG_HOT | PROFILE_FLAG_OPTIMIZED)) == 0 {
            if calls < min_calls {
                min_calls = calls
                min_idx = i
            }
        }
        i = i + 1
    }
    
    // Shift all entries after min_idx down
    i = min_idx
    while i < profiler_count - 1 {
        let dst = profiler_storage + i * PROFILE_ENTRY_SIZE
        let src = profiler_storage + (i + 1) * PROFILE_ENTRY_SIZE
        __builtin_memcpy(dst, src, PROFILE_ENTRY_SIZE)
        i = i + 1
    }
    
    profiler_count = profiler_count - 1
}

// ============================================================================
// PROFILING HOOKS (Called by compiler-inserted code)
// ============================================================================

// Called at function entry
// Returns: timestamp for pairing with profiler_exit
func profiler_enter(func_id: Int) -> Int {
    if profiler_enabled == 0 { return 0 }
    
    let entry = profiler_get_entry(func_id)
    
    // Increment call count
    let count = profile_entry_call_count(entry) + 1
    profile_entry_set_call_count(entry, count)
    
    // Record entry time (microseconds)
    let now = __builtin_time_us()
    profile_entry_set_last_entry(entry, now)
    
    // Check if function became hot
    if count >= HOT_THRESHOLD_CALLS {
        let flags = profile_entry_flags(entry)
        if (flags & PROFILE_FLAG_HOT) == 0 {
            profile_entry_set_flags(entry, flags | PROFILE_FLAG_HOT)
        }
    }
    
    now
}

// Called at function exit
func profiler_exit(func_id: Int, entry_time: Int) {
    if profiler_enabled == 0 { return }
    if entry_time == 0 { return }
    
    let entry = profiler_get_entry(func_id)
    
    // Calculate elapsed time
    let now = __builtin_time_us()
    let elapsed = now - entry_time
    
    // Add to total time
    let total = profile_entry_total_time(entry) + elapsed
    profile_entry_set_total_time(entry, total)
    
    // Check if function became hot by time
    if total >= HOT_THRESHOLD_TIME_US {
        let flags = profile_entry_flags(entry)
        if (flags & PROFILE_FLAG_HOT) == 0 {
            profile_entry_set_flags(entry, flags | PROFILE_FLAG_HOT)
        }
    }
}

// ============================================================================
// HOT PATH DETECTION
// ============================================================================

// Get all hot functions that haven't been optimized yet
// Returns: Vector of func_ids
func profiler_get_hot_paths() -> Int {
    let hot_funcs = vec_new()
    
    let i = 0
    while i < profiler_count {
        let entry = profiler_storage + i * PROFILE_ENTRY_SIZE
        let flags = profile_entry_flags(entry)
        
        // Hot but not yet optimized and not blacklisted
        if (flags & PROFILE_FLAG_HOT) != 0 {
            if (flags & PROFILE_FLAG_OPTIMIZED) == 0 {
                if (flags & PROFILE_FLAG_BLACKLIST) == 0 {
                    let func_id = profile_entry_func_id(entry)
                    vec_push(hot_funcs, func_id)
                }
            }
        }
        i = i + 1
    }
    
    hot_funcs
}

// Get number of hot functions pending optimization
func profiler_hot_count() -> Int {
    let count = 0
    
    let i = 0
    while i < profiler_count {
        let entry = profiler_storage + i * PROFILE_ENTRY_SIZE
        let flags = profile_entry_flags(entry)
        
        if (flags & PROFILE_FLAG_HOT) != 0 {
            if (flags & PROFILE_FLAG_OPTIMIZED) == 0 {
                if (flags & PROFILE_FLAG_BLACKLIST) == 0 {
                    count = count + 1
                }
            }
        }
        i = i + 1
    }
    
    count
}

// Mark a function as optimized (prevent re-optimization)
func profiler_mark_optimized(func_id: Int) {
    let entry = profiler_get_entry(func_id)
    let flags = profile_entry_flags(entry)
    profile_entry_set_flags(entry, flags | PROFILE_FLAG_OPTIMIZED)
}

// Blacklist a function from optimization (e.g., intrinsics)
func profiler_blacklist(func_id: Int) {
    let entry = profiler_get_entry(func_id)
    let flags = profile_entry_flags(entry)
    profile_entry_set_flags(entry, flags | PROFILE_FLAG_BLACKLIST)
}

// ============================================================================
// STATISTICS AND DEBUGGING
// ============================================================================

// Get profile data for a function
func profiler_get_stats(func_id: Int) -> Int {
    let entry = profiler_get_entry(func_id)
    
    // Return pointer to a stats struct
    // [call_count, total_time_us, avg_time_us, is_hot]
    let stats = __builtin_malloc(32)
    let calls = profile_entry_call_count(entry)
    let total = profile_entry_total_time(entry)
    let avg = 0
    if calls > 0 { avg = total / calls }
    let flags = profile_entry_flags(entry)
    let is_hot = 0
    if (flags & PROFILE_FLAG_HOT) != 0 { is_hot = 1 }
    
    __builtin_store64(stats, calls)
    __builtin_store64(stats + 8, total)
    __builtin_store64(stats + 16, avg)
    __builtin_store64(stats + 24, is_hot)
    
    stats
}

// Reset all profile data
func profiler_reset() {
    profiler_count = 0
    
    // Zero storage
    let i = 0
    while i < MAX_TRACKED_FUNCTIONS * PROFILE_ENTRY_SIZE {
        __builtin_store8(profiler_storage + i, 0)
        i = i + 1
    }
}

// Get total tracked functions
func profiler_tracked_count() -> Int {
    profiler_count
}

// Dump profile data for debugging
func profiler_dump() {
    let i = 0
    while i < profiler_count {
        let entry = profiler_storage + i * PROFILE_ENTRY_SIZE
        let func_id = profile_entry_func_id(entry)
        let calls = profile_entry_call_count(entry)
        let total = profile_entry_total_time(entry)
        let flags = profile_entry_flags(entry)
        
        // Print: func_id, calls, total_us, flags
        __builtin_print(func_id)
        __builtin_print(calls)
        __builtin_print(total)
        __builtin_print(flags)
        
        i = i + 1
    }
}

// ============================================================================
// COMPILER INTRINSICS (Implemented by bootstrap compiler)
// ============================================================================

// High-resolution time in microseconds - wraps the native __builtin_time
func __builtin_time_us() -> Int { __builtin_time() * 1000 }
