; LLVM IR generated by Aether Compiler
target triple = "arm64-apple-macosx14.0.0"

declare i8* @malloc(i64)
declare void @free(i8*)
declare i64 @write(i32, i8*, i64)
declare i64 @read(i32, i8*, i64)
declare i64 @open(i8*, i32, i32)
declare i64 @close(i32)
declare i8* @mmap(i8*, i64, i32, i32, i32, i64)
declare i32 @pthread_create(i64*, i8*, i8* (i8*)*, i8*)
declare i32 @pthread_join(i64, i8**)

define i64 @power2(i64 %n) {
entry:
  %n.addr = alloca i64
  store i64 %n, i64* %n.addr
  %result.addr = alloca i64
  store i64 1, i64* %result.addr
  %i.addr = alloca i64
  store i64 0, i64* %i.addr
  br label %L0
L0:
  %t0 = load i64, i64* %i.addr
  %t1 = load i64, i64* %n.addr
  %t2 = icmp slt i64 %t0, %t1
  %t3 = zext i1 %t2 to i64
  %t4 = icmp ne i64 %t3, 0
  br i1 %t4, label %L1, label %L2
L1:
  %t5 = load i64, i64* %result.addr
  %t6 = mul i64 %t5, 2
  store i64 %t6, i64* %result.addr
  %t7 = load i64, i64* %i.addr
  %t8 = add i64 %t7, 1
  store i64 %t8, i64* %i.addr
  br label %L0
L2:
  %t9 = load i64, i64* %result.addr
  ret i64 0
}

define i64 @test_crypto() {
entry:
  %buf.addr = alloca i64
  %t0 = call i8* @malloc(i64 64)
  %t1 = ptrtoint i8* %t0 to i64
  store i64 %t1, i64* %buf.addr
  %t2 = load i64, i64* %buf.addr
  %t3 = icmp eq i64 %t2, 0
  %t4 = zext i1 %t3 to i64
  %t5 = icmp ne i64 %t4, 0
  br i1 %t5, label %L3, label %L4
L3:
  ret i64 1
  br label %L5
L4:
  br label %L5
L5:
  %t6 = load i64, i64* %buf.addr
  %t7 = inttoptr i64 %t6 to i32*
  %t8 = trunc i64 305419896 to i32
  store i32 %t8, i32* %t7
  %v.addr = alloca i64
  %t9 = load i64, i64* %buf.addr
  %t10 = inttoptr i64 %t9 to i32*
  %t11 = load i32, i32* %t10
  %t12 = zext i32 %t11 to i64
  store i64 %t12, i64* %v.addr
  %t13 = load i64, i64* %v.addr
  %t14 = icmp ne i64 %t13, 305419896
  %t15 = zext i1 %t14 to i64
  %t16 = icmp ne i64 %t15, 0
  br i1 %t16, label %L6, label %L7
L6:
  ret i64 2
  br label %L8
L7:
  br label %L8
L8:
  %x.addr = alloca i64
  store i64 100, i64* %x.addr
  %y.addr = alloca i64
  %t17 = load i64, i64* %x.addr
  %t18 = mul i64 %t17, 2
  store i64 %t18, i64* %y.addr
  %t19 = load i64, i64* %y.addr
  %t20 = icmp ne i64 %t19, 200
  %t21 = zext i1 %t20 to i64
  %t22 = icmp ne i64 %t21, 0
  br i1 %t22, label %L9, label %L10
L9:
  ret i64 3
  br label %L11
L10:
  br label %L11
L11:
  %p.addr = alloca i64
  %t23 = call i64 @power2(i64 8)
  store i64 %t23, i64* %p.addr
  %t24 = load i64, i64* %p.addr
  %t25 = icmp ne i64 %t24, 256
  %t26 = zext i1 %t25 to i64
  %t27 = icmp ne i64 %t26, 0
  br i1 %t27, label %L12, label %L13
L12:
  ret i64 4
  br label %L14
L13:
  br label %L14
L14:
  %m.addr = alloca i64
  %t28 = srem i64 1000, 256
  store i64 %t28, i64* %m.addr
  %t29 = load i64, i64* %m.addr
  %t30 = icmp ne i64 %t29, 232
  %t31 = zext i1 %t30 to i64
  %t32 = icmp ne i64 %t31, 0
  br i1 %t32, label %L15, label %L16
L15:
  ret i64 5
  br label %L17
L16:
  br label %L17
L17:
  ret i64 0
}

define i64 @main() {
entry:
  %t0 = call i64 @test_crypto()
  ret i64 0
}

