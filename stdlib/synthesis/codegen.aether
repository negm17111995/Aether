// AETHER CODEGEN - Source Code Generation
// Generates valid Aether source from a Plan
// The "hands" of the Synthesis Engine
//
// Takes a plan (list of modules) and generates:
// 1. Import statements for all dependencies
// 2. Main function boilerplate
// 3. Basic wiring based on module APIs

import runtime.vec
import runtime.str
import stdlib.synthesis.knowledge_graph
import stdlib.synthesis.planner

// ============================================================================
// CODE BUFFER
// Accumulates generated code with proper indentation
// ============================================================================

const BUFFER_INITIAL_SIZE: Int = 4096

func buffer_new() -> Int {
    let buf = __builtin_malloc(24)
    __builtin_store64(buf, __builtin_malloc(BUFFER_INITIAL_SIZE))  // data
    __builtin_store64(buf + 8, 0)                                   // len
    __builtin_store64(buf + 16, BUFFER_INITIAL_SIZE)               // cap
    buf
}

func buffer_data(buf: Int) -> Int { __builtin_load64(buf) }
func buffer_len(buf: Int) -> Int { __builtin_load64(buf + 8) }
func buffer_cap(buf: Int) -> Int { __builtin_load64(buf + 16) }

func buffer_set_len(buf: Int, len: Int) { __builtin_store64(buf + 8, len) }

// Ensure capacity
func buffer_ensure(buf: Int, needed: Int) {
    let cap = buffer_cap(buf)
    let len = buffer_len(buf)
    
    if len + needed > cap {
        // Grow buffer
        let new_cap = cap * 2
        while new_cap < len + needed {
            new_cap = new_cap * 2
        }
        
        let new_data = __builtin_malloc(new_cap)
        __builtin_memcpy(new_data, buffer_data(buf), len)
        __builtin_free(buffer_data(buf))
        __builtin_store64(buf, new_data)
        __builtin_store64(buf + 16, new_cap)
    }
}

// Append string to buffer
func buffer_append(buf: Int, s: Int) {
    let slen = str_len(s)
    buffer_ensure(buf, slen)
    
    let data = buffer_data(buf)
    let pos = buffer_len(buf)
    
    let i = 0
    while i < slen {
        ae_store8(data + pos + i, ae_load8(s + i))
        i = i + 1
    }
    
    buffer_set_len(buf, pos + slen)
}

// Append newline
func buffer_newline(buf: Int) {
    buffer_ensure(buf, 1)
    let data = buffer_data(buf)
    let pos = buffer_len(buf)
    ae_store8(data + pos, 10)  // '\n'
    buffer_set_len(buf, pos + 1)
}

// Append indentation (4 spaces per level)
func buffer_indent(buf: Int, level: Int) {
    let spaces = level * 4
    buffer_ensure(buf, spaces)
    
    let data = buffer_data(buf)
    let pos = buffer_len(buf)
    
    let i = 0
    while i < spaces {
        ae_store8(data + pos + i, 32)  // ' '
        i = i + 1
    }
    
    buffer_set_len(buf, pos + spaces)
}

// Get buffer as null-terminated string
func buffer_to_string(buf: Int) -> Int {
    let len = buffer_len(buf)
    buffer_ensure(buf, 1)
    
    let data = buffer_data(buf)
    ae_store8(data + len, 0)  // Null terminator
    
    data
}

// ============================================================================
// CODE GENERATION
// ============================================================================

// Generate complete Aether source from a plan
func codegen_from_plan(plan: Int) -> Int {
    let buf = buffer_new()
    
    // Header comment
    buffer_append(buf, "// Generated by Aether Synthesis Engine")
    buffer_newline(buf)
    buffer_append(buf, "// Intent-to-Code Compilation")
    buffer_newline(buf)
    buffer_newline(buf)
    
    // Generate imports
    codegen_imports(buf, plan)
    buffer_newline(buf)
    
    // Generate main function
    codegen_main(buf, plan)
    
    buffer_to_string(buf)
}

// Generate import statements
func codegen_imports(buf: Int, plan: Int) {
    let count = plan_module_count(plan)
    
    let i = 0
    while i < count {
        let mod_name = plan_get_import(plan, i)
        
        buffer_append(buf, "import ")
        buffer_append(buf, mod_name)
        buffer_newline(buf)
        
        i = i + 1
    }
}

// Generate main function
func codegen_main(buf: Int, plan: Int) {
    buffer_append(buf, "func main(argc: Int, argv: Int) -> Int {")
    buffer_newline(buf)
    
    // Initialization section
    buffer_indent(buf, 1)
    buffer_append(buf, "// Initialize modules")
    buffer_newline(buf)
    
    codegen_initializations(buf, plan)
    buffer_newline(buf)
    
    // Main logic section
    buffer_indent(buf, 1)
    buffer_append(buf, "// Main logic")
    buffer_newline(buf)
    
    codegen_main_logic(buf, plan)
    buffer_newline(buf)
    
    // Return
    buffer_indent(buf, 1)
    buffer_append(buf, "0")
    buffer_newline(buf)
    
    buffer_append(buf, "}")
    buffer_newline(buf)
}

// Generate initialization calls
func codegen_initializations(buf: Int, plan: Int) {
    let count = plan_module_count(plan)
    
    let i = 0
    while i < count {
        let mod_id = plan_get_module(plan, i)
        let api = kg_get_module_api(mod_id)
        let func_count = vec_len(api)
        
        // Look for init functions
        let j = 0
        while j < func_count {
            let sig = vec_get(api, j)
            let name = func_sig_name(sig)
            
            // Check if it's an init function
            if str_contains(name, "_init") == 1 || str_contains(name, "_new") == 1 {
                buffer_indent(buf, 1)
                buffer_append(buf, "let ")
                
                // Generate variable name from function
                let var_name = extract_var_name(name)
                buffer_append(buf, var_name)
                
                buffer_append(buf, " = ")
                buffer_append(buf, name)
                buffer_append(buf, "()")
                buffer_newline(buf)
            }
            
            j = j + 1
        }
        
        i = i + 1
    }
}

// Extract variable name from function name
func extract_var_name(func_name: Int) -> Int {
    let len = str_len(func_name)
    
    // Remove _init or _new suffix
    let suffix_pos = str_find(func_name, "_init")
    if suffix_pos == 0 {
        suffix_pos = str_find(func_name, "_new")
    }
    
    if suffix_pos > 0 {
        return str_slice(func_name, 0, suffix_pos)
    }
    
    func_name
}

// Generate main logic based on selected modules
func codegen_main_logic(buf: Int, plan: Int) {
    // Detect which modules were selected
    let modules = plan_modules(plan)
    let count = vec_len(modules)
    
    let has_http = 0
    let has_firebase = 0
    let has_postgres = 0
    
    let i = 0
    while i < count {
        let mod_id = vec_get(modules, i)
        let name = kg_get_module_name(mod_id)
        
        if str_contains(name, "http") == 1 { has_http = 1 }
        if str_contains(name, "firebase") == 1 { has_firebase = 1 }
        if str_contains(name, "postgres") == 1 { has_postgres = 1 }
        
        i = i + 1
    }
    
    // Generate module-specific boilerplate using environment variables
    if has_firebase == 1 {
        buffer_indent(buf, 1)
        buffer_append(buf, "// Firebase Setup - set FIREBASE_PROJECT_ID and FIREBASE_API_KEY env vars")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let project_id = __builtin_getenv(\"FIREBASE_PROJECT_ID\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let api_key = __builtin_getenv(\"FIREBASE_API_KEY\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let config = firebase_config_new(project_id, api_key)")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let app = firebase_init(config)")
        buffer_newline(buf)
    }
    
    if has_postgres == 1 {
        buffer_indent(buf, 1)
        buffer_append(buf, "// PostgreSQL Connection - set DATABASE_URL env var")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let db_host = __builtin_getenv(\"DATABASE_HOST\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let db_port = __builtin_getenv(\"DATABASE_PORT\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let db_name = __builtin_getenv(\"DATABASE_NAME\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let db_user = __builtin_getenv(\"DATABASE_USER\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let db_pass = __builtin_getenv(\"DATABASE_PASS\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let conn = pg_connect_str(db_host, db_port, db_name, db_user, db_pass)")
        buffer_newline(buf)
    }
    
    if has_http == 1 && has_firebase == 0 && has_postgres == 0 {
        buffer_indent(buf, 1)
        buffer_append(buf, "// HTTP Example")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let api_url = __builtin_getenv(\"API_URL\")")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "let response = http_get(api_url)")
        buffer_newline(buf)
    }
    
    // Add entry point call if we have modules
    if count > 0 {
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "// Application entry point")
        buffer_newline(buf)
        buffer_indent(buf, 1)
        buffer_append(buf, "println(\"Application initialized successfully\")")
        buffer_newline(buf)
    }
}

// ============================================================================
// FILE OUTPUT
// ============================================================================

// Write generated code to file
func codegen_emit_file(code: Int, path: Int) -> Int {
    let len = str_len(code)
    
    // Open file for writing
    let fd = __builtin_open(path, 577, 420)  // O_WRONLY | O_CREAT | O_TRUNC, 0644
    if fd < 0 {
        return 0
    }
    
    // Write code
    __builtin_write(fd, code, len)
    
    // Close file
    __builtin_close(fd)
    
    1
}

// ============================================================================
// HIGH-LEVEL API
// ============================================================================

// Synthesize code from intent and write to file
func synthesize(intent: Int, output_path: Int) -> Int {
    // Step 1: Create plan from intent
    let plan = plan_from_intent(intent)
    
    if plan_status(plan) != 1 {
        return 0  // Planning failed
    }
    
    // Step 2: Generate code
    let code = codegen_from_plan(plan)
    
    if code == 0 {
        return 0  // Codegen failed
    }
    
    // Step 3: Write to file
    let result = codegen_emit_file(code, output_path)
    
    result
}

// Synthesize and return code string (for REPL use)
func synthesize_to_string(intent: Int) -> Int {
    let plan = plan_from_intent(intent)
    
    if plan_status(plan) != 1 {
        return 0
    }
    
    codegen_from_plan(plan)
}
