// ═══════════════════════════════════════════════════════════════════════════════
// AETHER RESULT/OPTION - Error Handling with ? Operator Pattern
// ═══════════════════════════════════════════════════════════════════════════════
// Clean error handling that rivals Rust's ? operator

// ============================================================================
// RESULT TYPE
// ============================================================================

// Result layout: [is_ok, value_or_error]
const RESULT_OK: Int = 0
const RESULT_ERR: Int = 8

// Create Ok result
func Ok(value: Int) -> Int {
    let r = __builtin_malloc(16)
    __builtin_store64(r + RESULT_OK, 1)
    __builtin_store64(r + RESULT_ERR, value)
    r
}

// Create Err result
func Err(error: Int) -> Int {
    let r = __builtin_malloc(16)
    __builtin_store64(r + RESULT_OK, 0)
    __builtin_store64(r + RESULT_ERR, error)
    r
}

// Check if result is Ok
func is_ok(r: Int) -> Bool {
    __builtin_load64(r + RESULT_OK) == 1
}

// Check if result is Err
func is_err(r: Int) -> Bool {
    __builtin_load64(r + RESULT_OK) == 0
}

// Unwrap Ok value (panics if Err)
func unwrap(r: Int) -> Int {
    if is_err(r) {
        __builtin_panic(100)
    }
    __builtin_load64(r + RESULT_ERR)
}

// Unwrap with default
func unwrap_or(r: Int, default_val: Int) -> Int {
    if is_ok(r) {
        __builtin_load64(r + RESULT_ERR)
    } else {
        default_val
    }
}

// Get error (panics if Ok)
func unwrap_err(r: Int) -> Int {
    if is_ok(r) {
        __builtin_panic(101)
    }
    __builtin_load64(r + RESULT_ERR)
}

// ============================================================================
// ? OPERATOR PATTERN (try_* functions)
// ============================================================================

// Use like: let val = try_unwrap(result, &early_return)
// If error, sets early_return and returns error
// If ok, returns unwrapped value

func try_unwrap(r: Int) -> Int {
    if is_err(r) {
        // Return the error result for propagation
        return 0 - 1  // Sentinel for error
    }
    __builtin_load64(r + RESULT_ERR)
}

// Check if try failed
func try_failed(val: Int) -> Bool {
    val == 0 - 1
}

// ============================================================================
// OPTION TYPE
// ============================================================================

// Option layout: [is_some, value]
const OPTION_SOME: Int = 0
const OPTION_VAL: Int = 8

// Create Some option
func Some(value: Int) -> Int {
    let o = __builtin_malloc(16)
    __builtin_store64(o + OPTION_SOME, 1)
    __builtin_store64(o + OPTION_VAL, value)
    o
}

// Create None option
func None() -> Int {
    let o = __builtin_malloc(16)
    __builtin_store64(o + OPTION_SOME, 0)
    __builtin_store64(o + OPTION_VAL, 0)
    o
}

// Check if option is Some
func is_some(o: Int) -> Bool {
    __builtin_load64(o + OPTION_SOME) == 1
}

// Check if option is None
func is_none(o: Int) -> Bool {
    __builtin_load64(o + OPTION_SOME) == 0
}

// Unwrap Some value
func option_unwrap(o: Int) -> Int {
    if is_none(o) {
        __builtin_panic(102)
    }
    __builtin_load64(o + OPTION_VAL)
}

// Unwrap with default
func option_unwrap_or(o: Int, default_val: Int) -> Int {
    if is_some(o) {
        __builtin_load64(o + OPTION_VAL)
    } else {
        default_val
    }
}

// ============================================================================
// COMBINATORS
// ============================================================================

// Map over Result
func result_map(r: Int, fn: Int) -> Int {
    if is_err(r) {
        r
    } else {
        let val = unwrap(r)
        Ok(__builtin_call(fn, val))
    }
}

// Map over Option
func option_map(o: Int, fn: Int) -> Int {
    if is_none(o) {
        o
    } else {
        let val = option_unwrap(o)
        Some(__builtin_call(fn, val))
    }
}

// Chain Results (and_then / flatMap)
func result_and_then(r: Int, fn: Int) -> Int {
    if is_err(r) {
        r
    } else {
        let val = unwrap(r)
        __builtin_call(fn, val)
    }
}

// Chain Options
func option_and_then(o: Int, fn: Int) -> Int {
    if is_none(o) {
        o
    } else {
        let val = option_unwrap(o)
        __builtin_call(fn, val)
    }
}

// Convert Option to Result
func option_ok_or(o: Int, err: Int) -> Int {
    if is_some(o) {
        Ok(option_unwrap(o))
    } else {
        Err(err)
    }
}

// Convert Result to Option
func result_ok(r: Int) -> Int {
    if is_ok(r) {
        Some(unwrap(r))
    } else {
        None()
    }
}
