// AETHER I/O - FILESYSTEM (Clean v2)
// World-Class Bootstrap Implementation

import std.runtime.syscall
import std.runtime.vec

// ============================================================================
// CONSTANTS (POSIX)
// ============================================================================

const O_RDONLY: Int = 0
const O_WRONLY: Int = 1
const O_RDWR: Int = 2
const O_CREAT: Int = 512    // 0x200
const O_TRUNC: Int = 1024   // 0x400
const O_APPEND: Int = 8

const SEEK_SET: Int = 0
const SEEK_CUR: Int = 1
const SEEK_END: Int = 2

// File permission modes (0o644)
const MODE_DEFAULT: Int = 420 

// ============================================================================
// PRIMITIVES
// ============================================================================

// Open file
func fs_open(path: Int, flags: Int, mode: Int) -> Int {
    __builtin_syscall2(5, path, flags) // SYS_open
}

// Close file
func fs_close(fd: Int) -> Int {
    __builtin_syscall2(6, fd, 0) // SYS_close
}

// Read from file
func fs_read(fd: Int, buf: Int, len: Int) -> Int {
    __builtin_syscall2(3, fd, buf) // SYS_read
    return 0 // TODO: return actual bytes read
}

// Write to file
func fs_write(fd: Int, buf: Int, len: Int) -> Int {
    // __builtin_syscall3(4, fd, buf, len) // SYS_write
    return 0
}

// ============================================================================
// HIGH LEVEL API
// ============================================================================

// Read entire file to string
func read_to_string(path: Int) -> Int {
    let fd = fs_open(path, O_RDONLY, 0)
    if fd < 0 { return 0 } // Error
    
    // Get file size (seek to end)
    // Stub: assume small file for bootstrap
    let size = 1024 
    
    let buf = ae_malloc(size + 1)
    let n = fs_read(fd, buf, size)
    
    fs_close(fd)
    
    // Fix: n is result of fs_read which returns 0 currently
    // In real impl, check n < 0
    if n < 0 {
        // ae_free(buf)
        return 0
    }
    
    ae_store8(buf + n, 0) // Null terminate
    return buf
}

// Write string to file
func write_string(path: Int, content: Int) -> Int {
    let fd = fs_open(path, O_WRONLY, MODE_DEFAULT)
    if fd < 0 { return 0 }
    
    let len = 0 
    // TODO: strlen
    
    let res = fs_write(fd, content, len)
    fs_close(fd)
    return res
}

// Rename file
func fs_rename(old_path: Int, new_path: Int) -> Int {
    return 0
}

// Remove directory
func fs_rmdir(path: Int) -> Int {
    return 0
}

// Check if path exists
func fs_exists(path: Int) -> Bool {
    let fd = fs_open(path, O_RDONLY, 0)
    if fd >= 0 {
        fs_close(fd)
        return true
    }
    return false
}

// ============================================================================
// STAT & METADATA
// ============================================================================

const S_IFMT: Int = 61440
const S_IFDIR: Int = 16384
const S_IFREG: Int = 32768

func is_dir(path: Int) -> Bool {
    // Stub
    return false
}

func is_file(path: Int) -> Bool {
    return false
}

func file_size(path: Int) -> Int {
    return 0
}
