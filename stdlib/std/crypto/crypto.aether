//! ═══════════════════════════════════════════════════════════════════════════════
//! AETHER CRYPTO - COMPLETE CRYPTOGRAPHY LIBRARY
//! ═══════════════════════════════════════════════════════════════════════════════
//! Industry-standard cryptographic algorithms
//! - Hashing (SHA-256, SHA-512, Blake3)
//! - Encryption (AES-256-GCM, ChaCha20-Poly1305)
//! - Signatures (Ed25519, ECDSA)
//! - Key exchange (X25519, ECDH)

import std.runtime.syscall
import std.runtime.security

// ============================================================================
// HASHING
// ============================================================================

/// SHA-256 hash (32 bytes output)
func sha256(data: Int, len: Int) -> Int {
    let hash = malloc(32)
    __sha256_compute(data, len, hash)
    hash
}

/// SHA-512 hash (64 bytes output)
func sha512(data: Int, len: Int) -> Int {
    let hash = malloc(64)
    __sha512_compute(data, len, hash)
    hash
}

/// Blake3 hash (32 bytes, faster than SHA-256)
func blake3(data: Int, len: Int) -> Int {
    let hash = malloc(32)
    __blake3_compute(data, len, hash)
    hash
}

/// HMAC-SHA256 for message authentication
func hmac_sha256(key: Int, key_len: Int, data: Int, data_len: Int) -> Int {
    let mac = malloc(32)
    __hmac_sha256_compute(key, key_len, data, data_len, mac)
    mac
}

// ============================================================================
// SYMMETRIC ENCRYPTION
// ============================================================================

/// AES-256-GCM encrypt (authenticated encryption)
/// Returns: [nonce (12 bytes) | ciphertext | tag (16 bytes)]
func aes256_gcm_encrypt(key: Int, plaintext: Int, len: Int) -> Int {
    let nonce = malloc(12)
    secure_random(nonce, 12)
    
    let output_len = 12 + len + 16
    let output = malloc(output_len)
    
    // Copy nonce to output
    memcpy(output, nonce, 12)
    
    // Encrypt
    __aes256_gcm_encrypt(key, nonce, plaintext, len, output + 12)
    
    output
}

/// AES-256-GCM decrypt
/// Returns: plaintext or 0 on auth failure
func aes256_gcm_decrypt(key: Int, ciphertext: Int, len: Int) -> Int {
    let nonce = ciphertext
    let ct = ciphertext + 12
    let ct_len = len - 12 - 16
    
    let plaintext = malloc(ct_len)
    let ok = __aes256_gcm_decrypt(key, nonce, ct, ct_len, plaintext)
    
    if ok == 1 {
        plaintext
    } else {
        0  // Authentication failed
    }
}

/// ChaCha20-Poly1305 encrypt (faster on devices without AES hardware)
func chacha20_encrypt(key: Int, plaintext: Int, len: Int) -> Int {
    let nonce = malloc(12)
    secure_random(nonce, 12)
    
    let output_len = 12 + len + 16
    let output = malloc(output_len)
    
    memcpy(output, nonce, 12)
    __chacha20_poly1305_encrypt(key, nonce, plaintext, len, output + 12)
    
    output
}

// ============================================================================
// DIGITAL SIGNATURES
// ============================================================================

/// Generate Ed25519 keypair
/// Returns: [private_key (32 bytes) | public_key (32 bytes)]
func ed25519_keygen() -> Int {
    let keypair = malloc(64)
    __ed25519_keygen(keypair)
    keypair
}

/// Sign message with Ed25519
/// Returns: signature (64 bytes)
func ed25519_sign(private_key: Int, message: Int, len: Int) -> Int {
    let signature = malloc(64)
    __ed25519_sign(private_key, message, len, signature)
    signature
}

/// Verify Ed25519 signature
/// Returns: 1 if valid, 0 if invalid
func ed25519_verify(public_key: Int, message: Int, len: Int, signature: Int) -> Int {
    __ed25519_verify(public_key, message, len, signature)
}

// ============================================================================
// KEY EXCHANGE
// ============================================================================

/// Generate X25519 keypair for key exchange
func x25519_keygen() -> Int {
    let keypair = malloc(64)
    secure_random(keypair, 32)  // private key
    __x25519_public(keypair, keypair + 32)  // derive public
    keypair
}

/// Derive shared secret from X25519
func x25519_shared(my_private: Int, their_public: Int) -> Int {
    let shared = malloc(32)
    __x25519_shared(my_private, their_public, shared)
    shared
}

// ============================================================================
// KEY DERIVATION
// ============================================================================

/// HKDF - derive keys from shared secret
func hkdf_sha256(input: Int, input_len: Int, salt: Int, salt_len: Int, 
                  info: Int, info_len: Int, output_len: Int) -> Int {
    let output = malloc(output_len)
    __hkdf_sha256(input, input_len, salt, salt_len, info, info_len, output, output_len)
    output
}

/// PBKDF2 - derive key from password
func pbkdf2_sha256(password: Int, pass_len: Int, salt: Int, salt_len: Int, 
                   iterations: Int) -> Int {
    let key = malloc(32)
    __pbkdf2_sha256(password, pass_len, salt, salt_len, iterations, key)
    key
}

// ============================================================================
// RANDOM
// ============================================================================

/// Generate cryptographically secure random bytes
func random_bytes(len: Int) -> Int {
    let buf = malloc(len)
    secure_random(buf, len)
    buf
}

/// Generate random UUID v4
func uuid_v4() -> Int {
    let uuid = malloc(36)
    let bytes = random_bytes(16)
    
    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    __format_uuid(bytes, uuid)
    uuid
}
