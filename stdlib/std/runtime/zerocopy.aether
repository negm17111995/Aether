// AETHER ZEROCOPY - Bootstrap Compatible
// Zero-copy data handling

import std

// Slice: [data_ptr, start, len]
func slice_new(data: Int, start: Int, len: Int) -> Int {
    let s = ae_malloc(24)
    ae_store64(s, data)
    ae_store64(s + 8, start)
    ae_store64(s + 16, len)
    s
}

func slice_data(s: Int) -> Int { ae_load64(s) }
func slice_start(s: Int) -> Int { ae_load64(s + 8) }
func slice_len(s: Int) -> Int { ae_load64(s + 16) }

func slice_get(s: Int, idx: Int) -> Int {
    let data = ae_load64(s)
    let start = ae_load64(s + 8)
    ae_load64(data + (start + idx) * 8)
}

func slice_subslice(s: Int, from: Int, to: Int) -> Int {
    let data = ae_load64(s)
    let start = ae_load64(s + 8) + from
    let len = to - from
    slice_new(data, start, len)
}

// Buffer: [data_ptr, len, cap]
func buffer_new(cap: Int) -> Int {
    let b = ae_malloc(24)
    ae_store64(b, ae_malloc(cap))
    ae_store64(b + 8, 0)
    ae_store64(b + 16, cap)
    b
}

func buffer_write(b: Int, data: Int, len: Int) -> Int {
    let buf_data = ae_load64(b)
    let buf_len = ae_load64(b + 8)
    let cap = ae_load64(b + 16)
    
    if buf_len + len > cap { return 0 }
    
    let i = 0
    while i < len {
        ae_store8(buf_data + buf_len + i, ae_load8(data + i))
        i = i + 1
    }
    
    ae_store64(b + 8, buf_len + len)
    len
}

func buffer_as_slice(b: Int) -> Int {
    slice_new(ae_load64(b), 0, ae_load64(b + 8))
}
