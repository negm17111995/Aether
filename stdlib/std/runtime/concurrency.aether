// AETHER CONCURRENCY - Bootstrap Compatible
// Thread primitives

import std

// Mutex: [state, owner]
func mutex_new() -> Int {
    let m = ae_malloc(16)
    ae_store64(m, 0)      // unlocked
    ae_store64(m + 8, 0)  // no owner
    m
}

func mutex_lock(m: Int) {
    ae_store64(m, 1)
}

func mutex_unlock(m: Int) {
    ae_store64(m, 0)
}

func mutex_is_locked(m: Int) -> Int {
    ae_load64(m)
}

// Channel: [buffer, head, tail, cap]
func channel_new(cap: Int) -> Int {
    let c = ae_malloc(32)
    ae_store64(c, ae_malloc(cap * 8))  // buffer
    ae_store64(c + 8, 0)               // head
    ae_store64(c + 16, 0)              // tail
    ae_store64(c + 24, cap)
    c
}

func channel_send(c: Int, val: Int) -> Int {
    let buf = ae_load64(c)
    let tail = ae_load64(c + 16)
    let cap = ae_load64(c + 24)
    
    let next = tail + 1
    if next >= cap { next = 0 }
    
    let head = ae_load64(c + 8)
    if next == head { return 0 }  // Full
    
    ae_store64(buf + tail * 8, val)
    ae_store64(c + 16, next)
    1
}

func channel_recv(c: Int) -> Int {
    let buf = ae_load64(c)
    let head = ae_load64(c + 8)
    let tail = ae_load64(c + 16)
    
    if head == tail { return 0 }  // Empty
    
    let val = ae_load64(buf + head * 8)
    let cap = ae_load64(c + 24)
    let next = head + 1
    if next >= cap { next = 0 }
    ae_store64(c + 8, next)
    val
}
