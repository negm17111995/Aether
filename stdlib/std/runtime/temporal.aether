//! ═══════════════════════════════════════════════════════════════════════════════
//! AETHER TEMPORAL DURABILITY - NEVER FAILS, AUTOMATIC RECOVERY
//! ═══════════════════════════════════════════════════════════════════════════════
//! Temporal-style workflow durability for Aether
//! - Automatic checkpointing after each step
//! - Replay from last checkpoint on crash
//! - Retry with exponential backoff

import std.runtime.syscall
import std.runtime.vec
import std.runtime.map

// ============================================================================
// WORKFLOW STATE
// ============================================================================

const WORKFLOW_STATE_PENDING: Int = 0
const WORKFLOW_STATE_RUNNING: Int = 1
const WORKFLOW_STATE_COMPLETED: Int = 2
const WORKFLOW_STATE_FAILED: Int = 3

// Workflow: [id, state, current_step, checkpoints, result]
const WF_ID_OFF: Int = 0
const WF_STATE_OFF: Int = 8
const WF_STEP_OFF: Int = 16
const WF_CHECKPOINTS_OFF: Int = 24
const WF_RESULT_OFF: Int = 32

// ============================================================================
// CHECKPOINT SYSTEM
// ============================================================================

/// Create a new durable workflow
func workflow_new(id: Int) -> Int {
    let wf = malloc(48)
    poke(wf + WF_ID_OFF, id)
    poke(wf + WF_STATE_OFF, WORKFLOW_STATE_PENDING)
    poke(wf + WF_STEP_OFF, 0)
    poke(wf + WF_CHECKPOINTS_OFF, vec_new())
    poke(wf + WF_RESULT_OFF, 0)
    wf
}

/// Save checkpoint at current step
func workflow_checkpoint(wf: Int, state: Int) {
    let checkpoints = peek(wf + WF_CHECKPOINTS_OFF)
    let step = peek(wf + WF_STEP_OFF)
    
    // Store (step, state) pair
    let checkpoint = malloc(16)
    poke(checkpoint, step)
    poke(checkpoint + 8, state)
    vec_push(checkpoints, checkpoint)
}

/// Get last checkpoint state
func workflow_last_checkpoint(wf: Int) -> Int {
    let checkpoints = peek(wf + WF_CHECKPOINTS_OFF)
    let len = vec_len(checkpoints)
    if len == 0 {
        return 0
    }
    let last = vec_get(checkpoints, len - 1)
    peek(last + 8)  // Return state
}

/// Advance to next step
func workflow_next_step(wf: Int) {
    let step = peek(wf + WF_STEP_OFF)
    poke(wf + WF_STEP_OFF, step + 1)
}

/// Mark workflow complete
func workflow_complete(wf: Int, result: Int) {
    poke(wf + WF_STATE_OFF, WORKFLOW_STATE_COMPLETED)
    poke(wf + WF_RESULT_OFF, result)
}

/// Mark workflow failed
func workflow_fail(wf: Int) {
    poke(wf + WF_STATE_OFF, WORKFLOW_STATE_FAILED)
}

// ============================================================================
// RETRY WITH BACKOFF
// ============================================================================

/// Retry activity with exponential backoff
/// max_retries: maximum number of attempts
/// base_delay_ms: initial delay in milliseconds
func retry_with_backoff(activity: Int, max_retries: Int, base_delay_ms: Int) -> Int {
    let attempt = 0
    let delay = base_delay_ms
    
    while attempt < max_retries {
        let result = __call_activity(activity)
        
        if result >= 0 {
            return result  // Success
        }
        
        attempt = attempt + 1
        
        if attempt < max_retries {
            // Sleep with exponential backoff
            __sleep_ms(delay)
            delay = delay * 2
            
            // Cap at 30 seconds
            if delay > 30000 {
                delay = 30000
            }
        }
    }
    
    -1  // All retries exhausted
}

// ============================================================================
// DURABLE EXECUTION
// ============================================================================

/// Execute a step durably - checkpoint before and after
func durable_step(wf: Int, step_fn: Int) -> Int {
    // Checkpoint current state
    let state = __capture_state()
    workflow_checkpoint(wf, state)
    
    // Execute step
    let result = __call_step(step_fn)
    
    // Advance step counter
    workflow_next_step(wf)
    
    result
}

/// Recover workflow from last checkpoint
func workflow_recover(wf: Int) -> Int {
    let state = workflow_last_checkpoint(wf)
    if state == 0 {
        return 0  // No checkpoint to recover from
    }
    
    // Restore state and continue
    __restore_state(state)
    poke(wf + WF_STATE_OFF, WORKFLOW_STATE_RUNNING)
    1
}
