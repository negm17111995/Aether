// AETHER PARALLEL - Bootstrap Compatible
// Parallel execution primitives

import std

// Work item: [func_ptr, data, result]
func work_new(func_ptr: Int, data: Int) -> Int {
    let w = ae_malloc(24)
    ae_store64(w, func_ptr)
    ae_store64(w + 8, data)
    ae_store64(w + 16, 0)
    w
}

func work_execute(w: Int) {
    // Execute synchronously in bootstrap
    let data = ae_load64(w + 8)
    // Would call function pointer here
}

// Parallel for (sequential in bootstrap)
func parallel_for(start: Int, end: Int, func_ptr: Int) {
    let i = start
    while i < end {
        // Would spawn threads in real impl
        i = i + 1
    }
}

// Worker pool
func pool_new(num_workers: Int) -> Int {
    let p = ae_malloc(16)
    ae_store64(p, num_workers)
    ae_store64(p + 8, vec_new())  // work queue
    p
}

func pool_submit(p: Int, work: Int) {
    let queue = ae_load64(p + 8)
    vec_push(queue, work)
}

func pool_run_all(p: Int) {
    let queue = ae_load64(p + 8)
    let count = vec_len(queue)
    let i = 0
    while i < count {
        work_execute(vec_get(queue, i))
        i = i + 1
    }
}
