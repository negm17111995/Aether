// ═══════════════════════════════════════════════════════════════════════════════
// AETHER SECURITY - ULTIMATE PROTECTION
// ═══════════════════════════════════════════════════════════════════════════════

import std

// ============================================================================
// SECURE MEMORY
// ============================================================================

/// Securely wipe memory (prevents compiler optimization)
func secure_wipe(ptr: Int, len: Int) {
    let i = 0
    while i < len {
        ae_store8(ptr + i, 0)
        i = i + 1
    }
    // Memory barrier to prevent optimization
    __memory_barrier()
}

/// Constant-time comparison (prevents timing attacks)
func secure_compare(a: Int, b: Int, len: Int) -> Int {
    let result = 0
    let i = 0
    while i < len {
        let xa = ae_load8(a + i)
        let xb = ae_load8(b + i)
        let diff = __builtin_xor(xa, xb)
        result = __builtin_or(result, diff)
        i = i + 1
    }
    // Returns 1 if equal, 0 if different
    if result == 0 { return 1 }
    0
}

/// Secure random bytes (from OS entropy)
func secure_random(buf: Int, len: Int) -> Int {
    // macOS: getentropy syscall (SYS_getentropy = 244)
    // __builtin_syscall2(244, buf, len)
    // Using simple stub for now as syscall requires more setup
    0
}

/// Generate secure random Int
func secure_random_int() -> Int {
    let buf = ae_malloc(8)
    // secure_random(buf, 8)
    let val = ae_load64(buf)
    // ae_free(buf) // Need to expose free in std
    val
}

// ============================================================================
// BOUNDS CHECKING
// ============================================================================

/// Safe array access with bounds check
func secure_get(arr: Int, idx: Int, len: Int) -> Int {
    if idx < 0 || idx >= len {
        // Bounds violation - return 0 instead of crashing
        return 0
    }
    ae_load64(arr + idx * 8)
}

/// Safe array write with bounds check
func secure_set(arr: Int, idx: Int, len: Int, val: Int) -> Int {
    if idx < 0 || idx >= len {
        return 0  // Failed
    }
    ae_store64(arr + idx * 8, val)
    1  // Success
}

// ============================================================================
// NULL SAFETY
// ============================================================================

/// Check if pointer is valid (non-null, non-zero)
func is_valid(ptr: Int) -> Int {
    if ptr == 0 { return 0 }
    1
}

/// Safe dereference - returns default on null
func secure_deref(ptr: Int, default_val: Int) -> Int {
    if ptr == 0 {
        return default_val
    }
    ae_load64(ptr)
}

// ============================================================================
// STACK PROTECTION
// ============================================================================

const STACK_CANARY_VALUE: Int = 0xDEADBEEFCAFEBABE

/// Push stack canary
func stack_canary_push(sp: Int) -> Int {
    ae_store64(sp, STACK_CANARY_VALUE)
    sp + 8
}

/// Check stack canary (returns 1 if valid)
func stack_canary_check(sp: Int) -> Int {
    if ae_load64(sp) == STACK_CANARY_VALUE { return 1 }
    0
}

// ============================================================================
// PANIC HANDLER
// ============================================================================

/// Safe panic that doesn't crash - returns to safe state
func safe_panic(msg: Int) {
    // Log error (stub)
    // sys_write(2, msg, str_len(msg))
    
    // Don't actually exit - return to caller
}
