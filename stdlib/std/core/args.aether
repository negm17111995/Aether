// AETHER ARGUMENTS - Bootstrap Compatible
// Default Parameters & Named Arguments

import std

// Args layout: [count, capacity, names_ptr, values_ptr, defaults_ptr, has_ptr]
const ARGS_COUNT: Int = 0
const ARGS_CAP: Int = 8
const ARGS_NAMES: Int = 16
const ARGS_VALUES: Int = 24
const ARGS_DEFAULTS: Int = 32
const ARGS_HAS: Int = 40

func args_new(capacity: Int) -> Int {
    let a = ae_malloc(48)
    ae_store64(a + ARGS_COUNT, 0)
    ae_store64(a + ARGS_CAP, capacity)
    ae_store64(a + ARGS_NAMES, ae_malloc(capacity * 8))
    ae_store64(a + ARGS_VALUES, ae_malloc(capacity * 8))
    ae_store64(a + ARGS_DEFAULTS, ae_malloc(capacity * 8))
    ae_store64(a + ARGS_HAS, ae_malloc(capacity))
    a
}

func args_define(a: Int, name: Int, default_val: Int) {
    let count = ae_load64(a + ARGS_COUNT)
    let names = ae_load64(a + ARGS_NAMES)
    let defaults = ae_load64(a + ARGS_DEFAULTS)
    let has = ae_load64(a + ARGS_HAS)
    
    ae_store64(names + count * 8, name)
    ae_store64(defaults + count * 8, default_val)
    ae_store8(has + count, 0)
    
    ae_store64(a + ARGS_COUNT, count + 1)
}

func args_set(a: Int, name: Int, value: Int) {
    let count = ae_load64(a + ARGS_COUNT)
    let names = ae_load64(a + ARGS_NAMES)
    let values = ae_load64(a + ARGS_VALUES)
    let has = ae_load64(a + ARGS_HAS)
    
    let i = 0
    while i < count {
        let n = ae_load64(names + i * 8)
        if n == name {
            ae_store64(values + i * 8, value)
            ae_store8(has + i, 1)
            return
        }
        i = i + 1
    }
}

func args_set_pos(a: Int, pos: Int, value: Int) {
    let values = ae_load64(a + ARGS_VALUES)
    let has = ae_load64(a + ARGS_HAS)
    ae_store64(values + pos * 8, value)
    ae_store8(has + pos, 1)
}

func args_get(a: Int, name: Int) -> Int {
    let count = ae_load64(a + ARGS_COUNT)
    let names = ae_load64(a + ARGS_NAMES)
    let values = ae_load64(a + ARGS_VALUES)
    let defaults = ae_load64(a + ARGS_DEFAULTS)
    let has = ae_load64(a + ARGS_HAS)
    
    let i = 0
    while i < count {
        let n = ae_load64(names + i * 8)
        if n == name {
            let is_set = ae_load8(has + i)
            if is_set == 1 {
                return ae_load64(values + i * 8)
            }
            return ae_load64(defaults + i * 8)
        }
        i = i + 1
    }
    0
}

func args_get_pos(a: Int, pos: Int) -> Int {
    let values = ae_load64(a + ARGS_VALUES)
    let defaults = ae_load64(a + ARGS_DEFAULTS)
    let has = ae_load64(a + ARGS_HAS)
    
    let is_set = ae_load8(has + pos)
    if is_set == 1 {
        return ae_load64(values + pos * 8)
    }
    ae_load64(defaults + pos * 8)
}

// Fluent builder
func with_arg(a: Int, name: Int, value: Int) -> Int {
    args_set(a, name, value)
    a
}

// Tuple helpers
func tuple_new(count: Int) -> Int {
    let t = ae_malloc(8 + count * 8)
    ae_store64(t, count)
    t
}

func tuple_set(t: Int, idx: Int, val: Int) {
    ae_store64(t + 8 + idx * 8, val)
}

func tuple_get(t: Int, idx: Int) -> Int {
    ae_load64(t + 8 + idx * 8)
}

func tuple_len(t: Int) -> Int {
    ae_load64(t)
}

func pair(a: Int, b: Int) -> Int {
    let t = tuple_new(2)
    tuple_set(t, 0, a)
    tuple_set(t, 1, b)
    t
}

func fst(t: Int) -> Int { tuple_get(t, 0) }
func snd(t: Int) -> Int { tuple_get(t, 1) }
