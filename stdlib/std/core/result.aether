// AETHER RESULT/OPTION - Error Handling with ? Operator Pattern
import std

// ============================================================================
// RESULT TYPE
// ============================================================================

// Result layout: [is_ok, value_or_error]
const RESULT_OK: Int = 0
const RESULT_ERR: Int = 8

// Create Ok result
func Ok(value: Int) -> Int {
    let r = ae_malloc(16)
    ae_store64(r + RESULT_OK, 1)
    ae_store64(r + RESULT_ERR, value)
    r
}

// Create Err result
func Err(error: Int) -> Int {
    let r = ae_malloc(16)
    ae_store64(r + RESULT_OK, 0)
    ae_store64(r + RESULT_ERR, error)
    r
}

// Check if result is Ok
func is_ok(r: Int) -> Bool {
    ae_load64(r + RESULT_OK) == 1
}

// Check if result is Err
func is_err(r: Int) -> Bool {
    ae_load64(r + RESULT_OK) == 0
}

// Unwrap Ok value (panics if Err)
func unwrap(r: Int) -> Int {
    if is_err(r) {
        __builtin_panic(100)
    }
    ae_load64(r + RESULT_ERR)
}

// Unwrap with default
func unwrap_or(r: Int, default_val: Int) -> Int {
    if is_ok(r) {
        return ae_load64(r + RESULT_ERR)
    }
    default_val
}

// Get error (panics if Ok)
func unwrap_err(r: Int) -> Int {
    if is_ok(r) {
        __builtin_panic(101)
    }
    ae_load64(r + RESULT_ERR)
}

// ============================================================================
// ? OPERATOR PATTERN (try_* functions)
// ============================================================================

func try_unwrap(r: Int) -> Int {
    if is_err(r) {
        // Return the error result for propagation
        return 0 - 1  // Sentinel for error
    }
    ae_load64(r + RESULT_ERR)
}

// Check if try failed
func try_failed(val: Int) -> Bool {
    val == 0 - 1
}

// ============================================================================
// OPTION TYPE
// ============================================================================

// Option layout: [is_some, value]
const OPTION_SOME: Int = 0
const OPTION_VAL: Int = 8

// Create Some option
func Some(value: Int) -> Int {
    let o = ae_malloc(16)
    ae_store64(o + OPTION_SOME, 1)
    ae_store64(o + OPTION_VAL, value)
    o
}

// Create None option
func None() -> Int {
    let o = ae_malloc(16)
    ae_store64(o + OPTION_SOME, 0)
    ae_store64(o + OPTION_VAL, 0)
    o
}

// Check if option is Some
func is_some(o: Int) -> Bool {
    ae_load64(o + OPTION_SOME) == 1
}

// Check if option is None
func is_none(o: Int) -> Bool {
    ae_load64(o + OPTION_SOME) == 0
}

// Unwrap Some value
func option_unwrap(o: Int) -> Int {
    if is_none(o) {
        __builtin_panic(102)
    }
    ae_load64(o + OPTION_VAL)
}

// Unwrap with default
func option_unwrap_or(o: Int, default_val: Int) -> Int {
    if is_some(o) {
        return ae_load64(o + OPTION_VAL)
    }
    default_val
}

// ============================================================================
// COMBINATORS
// ============================================================================

// Map over Result
func result_map(r: Int, fn: Int) -> Int {
    if is_err(r) {
        return r
    }
    let val = unwrap(r)
    Ok(__builtin_call(fn, val))
}

// Map over Option
func option_map(o: Int, fn: Int) -> Int {
    if is_none(o) {
        return o
    }
    let val = option_unwrap(o)
    Some(__builtin_call(fn, val))
}

// Chain Results (and_then / flatMap)
func result_and_then(r: Int, fn: Int) -> Int {
    if is_err(r) {
        return r
    }
    let val = unwrap(r)
    __builtin_call(fn, val)
}

// Chain Options
func option_and_then(o: Int, fn: Int) -> Int {
    if is_none(o) {
        return o
    }
    let val = option_unwrap(o)
    __builtin_call(fn, val)
}

// Convert Option to Result
func option_ok_or(o: Int, err: Int) -> Int {
    if is_some(o) {
        return Ok(option_unwrap(o))
    }
    Err(err)
}

// Convert Result to Option
func result_ok(r: Int) -> Int {
    if is_ok(r) {
        return Some(unwrap(r))
    }
    None()
}
