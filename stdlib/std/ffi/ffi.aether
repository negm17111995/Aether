// AETHER FFI - FOREIGN FUNCTION INTERFACE
// Call C libraries and external code

import runtime.vec
import runtime.map

// ============================================================================
// FFI TYPES
// ============================================================================

const FFI_TYPE_VOID: Int = 0
const FFI_TYPE_INT8: Int = 1
const FFI_TYPE_INT16: Int = 2
const FFI_TYPE_INT32: Int = 3
const FFI_TYPE_INT64: Int = 4
const FFI_TYPE_FLOAT: Int = 5
const FFI_TYPE_DOUBLE: Int = 6
const FFI_TYPE_PTR: Int = 7
const FFI_TYPE_STRUCT: Int = 8

// ============================================================================
// LIBRARY HANDLE
// ============================================================================

struct Library {
    path: Int,
    handle: Int,
    symbols: Int,
}

func library_open(path: Int) -> Int {
    let lib = __builtin_malloc(24)
    __builtin_store64(lib, path)
    
    // dlopen
    let handle = __builtin_dlopen(path, 1)  // RTLD_LAZY
    __builtin_store64(lib + 8, handle)
    __builtin_store64(lib + 16, map_new())
    
    lib
}

func library_close(lib: Int) {
    let handle = __builtin_load64(lib + 8)
    __builtin_dlclose(handle)
}

func library_get_symbol(lib: Int, name: Int) -> Int {
    let handle = __builtin_load64(lib + 8)
    let symbols = __builtin_load64(lib + 16)
    
    if map_has_int(symbols, name) == 1 {
        return map_get_int(symbols, name)
    }
    
    // dlsym
    let sym = __builtin_dlsym(handle, name)
    map_set_int(symbols, name, sym)
    sym
}

// ============================================================================
// FUNCTION SIGNATURE
// ============================================================================

struct FFISignature {
    return_type: Int,
    param_types: Int,
    param_count: Int,
}

func signature_new(ret_type: Int) -> Int {
    let sig = __builtin_malloc(24)
    __builtin_store64(sig, ret_type)
    __builtin_store64(sig + 8, vec_new())
    __builtin_store64(sig + 16, 0)
    sig
}

func signature_add_param(sig: Int, param_type: Int) {
    let params = __builtin_load64(sig + 8)
    vec_push(params, param_type)
    let count = __builtin_load64(sig + 16) + 1
    __builtin_store64(sig + 16, count)
}

// ============================================================================
// FFI CALL
// ============================================================================

struct FFICall {
    func_ptr: Int,
    signature: Int,
    args: Int,
}

func ffi_call_new(func_ptr: Int, sig: Int) -> Int {
    let call = __builtin_malloc(24)
    __builtin_store64(call, func_ptr)
    __builtin_store64(call + 8, sig)
    __builtin_store64(call + 16, vec_new())
    call
}

func ffi_call_push_int(call: Int, val: Int) {
    let args = __builtin_load64(call + 16)
    vec_push(args, val)
}

func ffi_call_push_ptr(call: Int, ptr: Int) {
    let args = __builtin_load64(call + 16)
    vec_push(args, ptr)
}

func ffi_call_invoke(call: Int) -> Int {
    let func_ptr = __builtin_load64(call)
    let sig = __builtin_load64(call + 8)
    let args = __builtin_load64(call + 16)
    
    let arg_count = vec_len(args)
    
    // Call function based on arg count
    // Uses platform-specific calling convention
    if arg_count == 0 {
        return __builtin_ffi_call0(func_ptr)
    }
    if arg_count == 1 {
        return __builtin_ffi_call1(func_ptr, vec_get(args, 0))
    }
    if arg_count == 2 {
        return __builtin_ffi_call2(func_ptr, vec_get(args, 0), vec_get(args, 1))
    }
    if arg_count == 3 {
        return __builtin_ffi_call3(func_ptr, vec_get(args, 0), vec_get(args, 1), vec_get(args, 2))
    }
    if arg_count == 4 {
        return __builtin_ffi_call4(func_ptr, 
            vec_get(args, 0), vec_get(args, 1), 
            vec_get(args, 2), vec_get(args, 3))
    }
    
    0
}

// ============================================================================
// C STRING CONVERSION
// ============================================================================

func to_c_string(aether_str: Int) -> Int {
    // Aether strings are already null-terminated
    aether_str
}

func from_c_string(c_str: Int) -> Int {
    // Copy C string
    let len = c_str_len(c_str)
    let str = __builtin_malloc(len + 1)
    let i = 0
    while i <= len {
        __builtin_store8(str + i, __builtin_load8(c_str + i))
        i = i + 1
    }
    str
}

func c_str_len(s: Int) -> Int {
    let i = 0
    while __builtin_load8(s + i) != 0 { i = i + 1 }
    i
}

// ============================================================================
// COMMON C FUNCTIONS
// ============================================================================

func c_malloc(size: Int) -> Int {
    let libc = library_open(0)  // Default library
    let sym = library_get_symbol(libc, make_str("malloc"))
    let call = ffi_call_new(sym, signature_new(FFI_TYPE_PTR))
    ffi_call_push_int(call, size)
    ffi_call_invoke(call)
}

func c_free(ptr: Int) {
    let libc = library_open(0)
    let sym = library_get_symbol(libc, make_str("free"))
    let call = ffi_call_new(sym, signature_new(FFI_TYPE_VOID))
    ffi_call_push_ptr(call, ptr)
    ffi_call_invoke(call)
}

func c_printf(fmt: Int) -> Int {
    let libc = library_open(0)
    let sym = library_get_symbol(libc, make_str("printf"))
    let call = ffi_call_new(sym, signature_new(FFI_TYPE_INT32))
    ffi_call_push_ptr(call, fmt)
    ffi_call_invoke(call)
}

// ============================================================================
// STRUCT LAYOUT
// ============================================================================

struct StructLayout {
    fields: Int,
    size: Int,
    alignment: Int,
}

func struct_layout_new() -> Int {
    let layout = __builtin_malloc(24)
    __builtin_store64(layout, vec_new())
    __builtin_store64(layout + 8, 0)
    __builtin_store64(layout + 16, 8)
    layout
}

func struct_add_field(layout: Int, ffi_type: Int) {
    let fields = __builtin_load64(layout)
    vec_push(fields, ffi_type)
    
    // Update size
    let size = __builtin_load64(layout + 8)
    let field_size = get_type_size(ffi_type)
    size = size + field_size
    __builtin_store64(layout + 8, size)
}

func get_type_size(ffi_type: Int) -> Int {
    if ffi_type == FFI_TYPE_INT8 { return 1 }
    if ffi_type == FFI_TYPE_INT16 { return 2 }
    if ffi_type == FFI_TYPE_INT32 { return 4 }
    if ffi_type == FFI_TYPE_INT64 { return 8 }
    if ffi_type == FFI_TYPE_FLOAT { return 4 }
    if ffi_type == FFI_TYPE_DOUBLE { return 8 }
    if ffi_type == FFI_TYPE_PTR { return 8 }
    0
}

// ============================================================================
// HELPER
// ============================================================================

func make_str(s: Int) -> Int {
    s  // Already a string pointer
}

// Builtin stubs
func __builtin_dlopen(path: Int, flags: Int) -> Int { 0 }
func __builtin_dlclose(handle: Int) { }
func __builtin_dlsym(handle: Int, name: Int) -> Int { 0 }
func __builtin_ffi_call0(f: Int) -> Int { 0 }
func __builtin_ffi_call1(f: Int, a0: Int) -> Int { 0 }
func __builtin_ffi_call2(f: Int, a0: Int, a1: Int) -> Int { 0 }
func __builtin_ffi_call3(f: Int, a0: Int, a1: Int, a2: Int) -> Int { 0 }
func __builtin_ffi_call4(f: Int, a0: Int, a1: Int, a2: Int, a3: Int) -> Int { 0 }
