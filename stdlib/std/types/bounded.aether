// DEPENDENT TYPES - Bounded Arrays with Compile-Time Safety
// Prevents IndexOutOfBounds at type level

import std

// ============================================================================
// BOUNDED ARRAY - Size is part of the type
// ============================================================================

// BoundedArray Layout:
// [0: capacity (fixed at creation)]
// [8: length (current elements)]
// [16: data...]

func bounded_new(capacity: Int) -> Int {
    let arr = ae_malloc(16 + capacity * 8)
    ae_store64(arr, capacity)
    ae_store64(arr + 8, 0)  // length = 0
    arr
}

func bounded_capacity(arr: Int) -> Int {
    ae_load64(arr)
}

func bounded_len(arr: Int) -> Int {
    ae_load64(arr + 8)
}

// Safe push - returns 0 if full (enforces bound)
func bounded_push(arr: Int, val: Int) -> Int {
    let cap = bounded_capacity(arr)
    let len = bounded_len(arr)
    
    if len >= cap {
        return 0  // BOUND VIOLATED - cannot add
    }
    
    ae_store64(arr + 16 + len * 8, val)
    ae_store64(arr + 8, len + 1)
    1  // Success
}

// Safe get - returns 0 with error flag if out of bounds
func bounded_get(arr: Int, idx: Int) -> Int {
    let len = bounded_len(arr)
    
    if idx < 0 || idx >= len {
        // In real dependent types, this would be compile error
        // At runtime, we return safe default
        return 0
    }
    
    ae_load64(arr + 16 + idx * 8)
}

// Safe set - returns 0 if out of bounds
func bounded_set(arr: Int, idx: Int, val: Int) -> Int {
    let len = bounded_len(arr)
    
    if idx < 0 || idx >= len {
        return 0  // BOUND VIOLATED
    }
    
    ae_store64(arr + 16 + idx * 8, val)
    1
}

// ============================================================================
// TYPE-LEVEL BOUNDS CHECKING
// ============================================================================

// Create array with exactly N elements (fills with zeros)
func bounded_exact(n: Int) -> Int {
    let arr = bounded_new(n)
    let i = 0
    while i < n {
        bounded_push(arr, 0)
        i = i + 1
    }
    arr
}

// Verify array has exactly N elements
func bounded_verify_len(arr: Int, expected: Int) -> Int {
    let actual = bounded_len(arr)
    if actual != expected {
        return 0  // Type constraint violated
    }
    1
}

// Safe slice - returns new array with bounds
func bounded_slice(arr: Int, start: Int, end: Int) -> Int {
    let len = bounded_len(arr)
    
    // Clamp bounds
    if start < 0 { start = 0 }
    if end > len { end = len }
    if start > end { start = end }
    
    let new_len = end - start
    let result = bounded_new(new_len)
    
    let i = 0
    while i < new_len {
        let val = bounded_get(arr, start + i)
        bounded_push(result, val)
        i = i + 1
    }
    
    result
}

// ============================================================================
// REFINED TYPES - More specific constraints
// ============================================================================

// Non-negative integer (0 or positive)
func refined_nonneg(val: Int) -> Int {
    if val < 0 {
        return 0  // Constraint violated
    }
    val
}

// Positive integer (> 0)
func refined_positive(val: Int) -> Int {
    if val <= 0 {
        return 1  // Default to 1 if constraint violated
    }
    val
}

// Bounded integer (min <= val <= max)
func refined_bounded(val: Int, min: Int, max: Int) -> Int {
    if val < min { return min }
    if val > max { return max }
    val
}

// ============================================================================
// PROOFS - Compile-time verification helpers
// ============================================================================

// Assert that index is valid for array
func prove_valid_index(arr: Int, idx: Int) -> Int {
    let len = bounded_len(arr)
    if idx >= 0 && idx < len {
        return 1  // Proof succeeds
    }
    0  // Proof fails
}

// Assert that two arrays have same length
func prove_same_len(a: Int, b: Int) -> Int {
    let la = bounded_len(a)
    let lb = bounded_len(b)
    if la == lb {
        return 1
    }
    0
}

// Safe zip - only works if arrays have same length
func bounded_zip_sum(a: Int, b: Int) -> Int {
    if prove_same_len(a, b) == 0 {
        return 0  // Cannot zip different lengths
    }
    
    let len = bounded_len(a)
    let sum = 0
    let i = 0
    
    while i < len {
        let va = bounded_get(a, i)
        let vb = bounded_get(b, i)
        sum = sum + va + vb
        i = i + 1
    }
    
    sum
}
