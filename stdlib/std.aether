// AETHER STANDARD LIBRARY - 100% PURE AETHER
// Core runtime primitives and data structures
// NO C OR OTHER LANGUAGES!

// ============================================================================
// MEMORY PRIMITIVES (compiler builtins)
// ============================================================================

// Allocate n bytes of memory, returns pointer
func ae_malloc(size: Int) -> Int { __builtin_malloc(size) }

// Free memory at address
func ae_free(ptr: Int) { __builtin_free(ptr) }

// Store/load 64-bit values
func ae_store64(addr: Int, val: Int) { __builtin_store64(addr, val) }
func ae_load64(addr: Int) -> Int { __builtin_load64(addr) }

// Store/load 32-bit values
func ae_store32(addr: Int, val: Int) {
    ae_store8(addr, val % 256)
    ae_store8(addr + 1, (val / 256) % 256)
    ae_store8(addr + 2, (val / 65536) % 256)
    ae_store8(addr + 3, (val / 16777216) % 256)
}

func ae_load32(addr: Int) -> Int {
    ae_load8(addr) + 
    ae_load8(addr + 1) * 256 + 
    ae_load8(addr + 2) * 65536 + 
    ae_load8(addr + 3) * 16777216
}

// Store/load 8-bit values
func ae_store8(addr: Int, val: Int) { __builtin_store8(addr, val) }
func ae_load8(addr: Int) -> Int { __builtin_load8(addr) }

// ============================================================================
// PRINT FUNCTION
// ============================================================================

func print(val: Int) {
    __builtin_print(val)
}

func println(val: Int) {
    print(val)
    print(10)  // newline
}

// ============================================================================
// VECTOR IMPLEMENTATION
// ============================================================================

// Vector structure: [data_ptr, length, capacity]
const VEC_DATA_OFF: Int = 0
const VEC_LEN_OFF: Int = 8
const VEC_CAP_OFF: Int = 16
const VEC_SIZE: Int = 24

// Create a new empty vector with initial capacity
func vec_new() -> Int {
    let v = ae_malloc(VEC_SIZE)
    let initial_cap = 64
    ae_store64(v + VEC_DATA_OFF, ae_malloc(initial_cap * 8))
    ae_store64(v + VEC_LEN_OFF, 0)
    ae_store64(v + VEC_CAP_OFF, initial_cap)
    v
}

// Get vector length
func vec_len(v: Int) -> Int {
    ae_load64(v + VEC_LEN_OFF)
}

// Get vector capacity
func vec_cap(v: Int) -> Int {
    ae_load64(v + VEC_CAP_OFF)
}

// Get element at index
func vec_get(v: Int, i: Int) -> Int {
    let data = ae_load64(v + VEC_DATA_OFF)
    ae_load64(data + i * 8)
}

// Set element at index
func vec_set(v: Int, i: Int, val: Int) {
    let data = ae_load64(v + VEC_DATA_OFF)
    ae_store64(data + i * 8, val)
}

// Push element to end of vector
func vec_push(v: Int, val: Int) {
    let len = vec_len(v)
    let cap = vec_cap(v)
    
    // Grow if needed
    if len >= cap {
        vec_grow(v)
    }
    
    // Store value and increment length
    let data = ae_load64(v + VEC_DATA_OFF)
    ae_store64(data + len * 8, val)
    ae_store64(v + VEC_LEN_OFF, len + 1)
}

// Pop element from end of vector
func vec_pop(v: Int) -> Int {
    let len = vec_len(v)
    if len == 0 { return 0 }
    
    let new_len = len - 1
    ae_store64(v + VEC_LEN_OFF, new_len)
    vec_get(v, new_len)
}

// Grow vector capacity by 2x
func vec_grow(v: Int) {
    let old_cap = vec_cap(v)
    let new_cap = old_cap * 2
    let old_data = ae_load64(v + VEC_DATA_OFF)
    let new_data = ae_malloc(new_cap * 8)
    
    // Copy old data
    let i = 0
    while i < old_cap {
        ae_store64(new_data + i * 8, ae_load64(old_data + i * 8))
        i = i + 1
    }
    
    ae_store64(v + VEC_DATA_OFF, new_data)
    ae_store64(v + VEC_CAP_OFF, new_cap)
    // Note: old_data leaks, but we have no free() yet in pure mode
}

// ============================================================================
// STRING UTILITIES
// ============================================================================

// Get string length (null-terminated)
func str_len(s: Int) -> Int {
    let i = 0
    while ae_load8(s + i) != 0 {
        i = i + 1
    }
    i
}

// Compare two strings for equality
func str_eq(a: Int, b: Int) -> Int {
    if a == b { return 1 }
    let i = 0
    while 1 == 1 {
        let ca = ae_load8(a + i)
        let cb = ae_load8(b + i)
        if ca != cb { return 0 }
        if ca == 0 { return 1 }
        i = i + 1
    }
    0
}

// Copy string from src to dst, returns bytes copied
func str_copy(dst: Int, src: Int) -> Int {
    let i = 0
    while 1 == 1 {
        let c = ae_load8(src + i)
        ae_store8(dst + i, c)
        if c == 0 { return i }
        i = i + 1
    }
    i
}

// ============================================================================
// MEMORY UTILITIES
// ============================================================================

// Copy n bytes from src to dst
func mem_copy(dst: Int, src: Int, n: Int) {
    let i = 0
    while i < n {
        ae_store8(dst + i, ae_load8(src + i))
        i = i + 1
    }
}

// Set n bytes to value
func mem_set(dst: Int, val: Int, n: Int) {
    let i = 0
    while i < n {
        ae_store8(dst + i, val)
        i = i + 1
    }
}

// ============================================================================
// NUMBER UTILITIES
// ============================================================================

// Absolute value
func abs(n: Int) -> Int {
    if n < 0 { return 0 - n }
    n
}

// Minimum of two values
func min(a: Int, b: Int) -> Int {
    if a < b { return a }
    b
}

// Maximum of two values
func max(a: Int, b: Int) -> Int {
    if a > b { return a }
    b
}

// Power function
func pow(base: Int, exp: Int) -> Int {
    if exp == 0 { return 1 }
    let result = 1
    let i = 0
    while i < exp {
        result = result * base
        i = i + 1
    }
    result
}

// ============================================================================
// CHARACTER UTILITIES
// ============================================================================

func is_digit(c: Int) -> Int {
    if c >= 48 && c <= 57 { return 1 }
    0
}

func is_alpha(c: Int) -> Int {
    if c >= 65 && c <= 90 { return 1 }   // A-Z
    if c >= 97 && c <= 122 { return 1 }  // a-z
    if c == 95 { return 1 }               // _
    0
}

func is_alnum(c: Int) -> Int {
    if is_alpha(c) == 1 { return 1 }
    if is_digit(c) == 1 { return 1 }
    0
}

func is_space(c: Int) -> Int {
    if c == 32 { return 1 }   // space
    if c == 9 { return 1 }    // tab
    if c == 10 { return 1 }   // newline
    if c == 13 { return 1 }   // carriage return
    0
}

// ============================================================================
// HASHMAP IMPLEMENTATION
// ============================================================================

// HashMap: [buckets, num_buckets, size]
const HASHMAP_BUCKETS_OFF: Int = 0
const HASHMAP_NUM_BUCKETS_OFF: Int = 8
const HASHMAP_SIZE_OFF: Int = 16
const HASHMAP_HEADER_SIZE: Int = 24

// Entry: [key, value, next]
const ENTRY_KEY_OFF: Int = 0
const ENTRY_VAL_OFF: Int = 8
const ENTRY_NEXT_OFF: Int = 16
const ENTRY_SIZE: Int = 24

func hashmap_new() -> Int {
    let num_buckets = 64
    let m = ae_malloc(HASHMAP_HEADER_SIZE)
    let buckets = ae_malloc(num_buckets * 8)
    
    // Initialize buckets to 0
    let i = 0
    while i < num_buckets {
        ae_store64(buckets + i * 8, 0)
        i = i + 1
    }
    
    ae_store64(m + HASHMAP_BUCKETS_OFF, buckets)
    ae_store64(m + HASHMAP_NUM_BUCKETS_OFF, num_buckets)
    ae_store64(m + HASHMAP_SIZE_OFF, 0)
    m
}

// Simple hash function for integers
func hash_int(key: Int) -> Int {
    let h = key * 2654435761
    if h < 0 { h = 0 - h }
    h
}

func hashmap_get(m: Int, key: Int) -> Int {
    let num_buckets = ae_load64(m + HASHMAP_NUM_BUCKETS_OFF)
    let buckets = ae_load64(m + HASHMAP_BUCKETS_OFF)
    let bucket_idx = hash_int(key) % num_buckets
    let entry = ae_load64(buckets + bucket_idx * 8)
    
    while entry != 0 {
        if ae_load64(entry + ENTRY_KEY_OFF) == key {
            return ae_load64(entry + ENTRY_VAL_OFF)
        }
        entry = ae_load64(entry + ENTRY_NEXT_OFF)
    }
    0
}

func hashmap_set(m: Int, key: Int, val: Int) {
    let num_buckets = ae_load64(m + HASHMAP_NUM_BUCKETS_OFF)
    let buckets = ae_load64(m + HASHMAP_BUCKETS_OFF)
    let bucket_idx = hash_int(key) % num_buckets
    let entry = ae_load64(buckets + bucket_idx * 8)
    
    // Check if key exists
    let cur = entry
    while cur != 0 {
        if ae_load64(cur + ENTRY_KEY_OFF) == key {
            ae_store64(cur + ENTRY_VAL_OFF, val)
            return
        }
        cur = ae_load64(cur + ENTRY_NEXT_OFF)
    }
    
    // Create new entry
    let new_entry = ae_malloc(ENTRY_SIZE)
    ae_store64(new_entry + ENTRY_KEY_OFF, key)
    ae_store64(new_entry + ENTRY_VAL_OFF, val)
    ae_store64(new_entry + ENTRY_NEXT_OFF, entry)
    ae_store64(buckets + bucket_idx * 8, new_entry)
    
    // Increment size
    let size = ae_load64(m + HASHMAP_SIZE_OFF)
    ae_store64(m + HASHMAP_SIZE_OFF, size + 1)
}

// ============================================================================
// PLATFORM DETECTION
// ============================================================================

const PLATFORM_UNKNOWN: Int = 0
const PLATFORM_MACOS_ARM64: Int = 1
const PLATFORM_MACOS_X64: Int = 2
const PLATFORM_LINUX_ARM64: Int = 3
const PLATFORM_LINUX_X64: Int = 4
const PLATFORM_WINDOWS_X64: Int = 5

// Will be set by compiler at compile time
func detect_platform() -> Int {
    // Default to macOS ARM64 for now
    // Real detection happens at compile time in the bootstrap
    PLATFORM_MACOS_ARM64
}

// ============================================================================
// ASSERT / DEBUG
// ============================================================================

func assert(cond: Int, msg: Int) {
    if cond == 0 {
        // Print "ASSERT FAILED: "
        print(65) print(83) print(83) print(69) print(82) print(84)
        print(32) print(70) print(65) print(73) print(76) print(69) print(68)
        print(58) print(32)
        // Print message char by char
        let i = 0
        while ae_load8(msg + i) != 0 {
            print(ae_load8(msg + i))
            i = i + 1
        }
        print(10)
        __builtin_exit(1)
    }
}

func debug_int(label: Int, val: Int) {
    let i = 0
    while ae_load8(label + i) != 0 {
        print(ae_load8(label + i))
        i = i + 1
    }
    print(58) print(32)  // ": "
    // Print number (simplified - just print digits)
    if val == 0 {
        print(48)
    } else {
        let buf = ae_malloc(32)
        let neg = 0
        let n = val
        if n < 0 {
            neg = 1
            n = 0 - n
        }
        let j = 0
        while n > 0 {
            ae_store8(buf + 31 - j, 48 + n % 10)
            n = n / 10
            j = j + 1
        }
        if neg == 1 { print(45) }  // -
        let k = 0
        while k < j {
            print(ae_load8(buf + 32 - j + k))
            k = k + 1
        }
    }
    print(10)
}
