// AETHER CACHE - Bootstrap Compatible
// Distributed cache

import std

// Cache entry: [key, value, expiry]
func cache_entry_new(key: Int, value: Int, ttl: Int) -> Int {
    let e = ae_malloc(24)
    ae_store64(e, key)
    ae_store64(e + 8, value)
    ae_store64(e + 16, __builtin_now_ms() + ttl)
    e
}

func cache_entry_expired(e: Int) -> Int {
    let expiry = ae_load64(e + 16)
    if __builtin_now_ms() > expiry { return 1 }
    0
}

// Cache: [entries, count]
func dist_cache_new() -> Int {
    let c = ae_malloc(16)
    ae_store64(c, vec_new())
    ae_store64(c + 8, 0)
    c
}

func dist_cache_set(c: Int, key: Int, value: Int, ttl_ms: Int) {
    let entries = ae_load64(c)
    let e = cache_entry_new(key, value, ttl_ms)
    vec_push(entries, e)
    let count = ae_load64(c + 8)
    ae_store64(c + 8, count + 1)
}

func dist_cache_get(c: Int, key: Int) -> Int {
    let entries = ae_load64(c)
    let count = vec_len(entries)
    let i = 0
    while i < count {
        let e = vec_get(entries, i)
        if ae_load64(e) == key {
            if cache_entry_expired(e) == 0 {
                return ae_load64(e + 8)
            }
        }
        i = i + 1
    }
    0
}

func dist_cache_evict_expired(c: Int) -> Int {
    // Would remove expired entries
    0
}
