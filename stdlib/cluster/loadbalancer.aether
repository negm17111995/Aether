// AETHER LOADBALANCER - Bootstrap Compatible
// Load balancing

import std

// Backend: [host, port, weight, active]
func lb_backend_new(host: Int, port: Int, weight: Int) -> Int {
    let b = ae_malloc(32)
    ae_store64(b, host)
    ae_store64(b + 8, port)
    ae_store64(b + 16, weight)
    ae_store64(b + 24, 1)  // active
    b
}

func lb_backend_set_active(b: Int, active: Int) {
    ae_store64(b + 24, active)
}

// Load balancer: [backends, current_idx, strategy]
const LB_ROUND_ROBIN: Int = 0
const LB_RANDOM: Int = 1
const LB_LEAST_CONN: Int = 2

func loadbalancer_new(strategy: Int) -> Int {
    let lb = ae_malloc(24)
    ae_store64(lb, vec_new())  // backends
    ae_store64(lb + 8, 0)      // current idx
    ae_store64(lb + 16, strategy)
    lb
}

func lb_add_backend(lb: Int, backend: Int) {
    let backends = ae_load64(lb)
    vec_push(backends, backend)
}

func lb_next_backend(lb: Int) -> Int {
    let backends = ae_load64(lb)
    let count = vec_len(backends)
    if count == 0 { return 0 }
    
    let strategy = ae_load64(lb + 16)
    let idx = ae_load64(lb + 8)
    
    if strategy == LB_ROUND_ROBIN {
        let next = (idx + 1) % count
        ae_store64(lb + 8, next)
        return vec_get(backends, idx)
    }
    
    if strategy == LB_RANDOM {
        let r = __builtin_now_ms() % count
        return vec_get(backends, r)
    }
    
    vec_get(backends, 0)
}

func lb_health_check(lb: Int) -> Int {
    let backends = ae_load64(lb)
    let count = vec_len(backends)
    let healthy = 0
    let i = 0
    while i < count {
        let b = vec_get(backends, i)
        if ae_load64(b + 24) == 1 {
            healthy = healthy + 1
        }
        i = i + 1
    }
    healthy
}
