// Aether Collections - Bootstrap Compatible Version
// Uses Int handles for all data structures. No generics.

// Vec layout: [data_ptr, len, cap] at handle address
const VEC_DATA: Int = 0
const VEC_LEN: Int = 8
const VEC_CAP: Int = 16

func vec_new() -> Int {
    let v = __builtin_malloc(24)
    let data = __builtin_malloc(64)
    __builtin_store64(v + VEC_DATA, data)
    __builtin_store64(v + VEC_LEN, 0)
    __builtin_store64(v + VEC_CAP, 8)
    v
}

func vec_len(v: Int) -> Int {
    __builtin_load64(v + VEC_LEN)
}

func vec_cap(v: Int) -> Int {
    __builtin_load64(v + VEC_CAP)
}

func vec_get(v: Int, idx: Int) -> Int {
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_load64(data + idx * 8)
}

func vec_set(v: Int, idx: Int, val: Int) {
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_store64(data + idx * 8, val)
}

func vec_push(v: Int, val: Int) {
    let len = __builtin_load64(v + VEC_LEN)
    let cap = __builtin_load64(v + VEC_CAP)
    
    if len >= cap {
        let new_cap = cap * 2
        let old_data = __builtin_load64(v + VEC_DATA)
        let new_data = __builtin_malloc(new_cap * 8)
        
        let i = 0
        while i < len {
            let src = __builtin_load64(old_data + i * 8)
            __builtin_store64(new_data + i * 8, src)
            i = i + 1
        }
        
        __builtin_store64(v + VEC_DATA, new_data)
        __builtin_store64(v + VEC_CAP, new_cap)
    }
    
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_store64(data + len * 8, val)
    __builtin_store64(v + VEC_LEN, len + 1)
}

func vec_pop(v: Int) -> Int {
    let len = __builtin_load64(v + VEC_LEN)
    if len == 0 { return 0 }
    
    let new_len = len - 1
    __builtin_store64(v + VEC_LEN, new_len)
    
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_load64(data + new_len * 8)
}

func vec_clear(v: Int) {
    __builtin_store64(v + VEC_LEN, 0)
}

// HashMap - simple linear probe
const MAP_BUCKETS: Int = 0
const MAP_SIZE: Int = 8
const MAP_CAP: Int = 16

func map_new() -> Int {
    let m = __builtin_malloc(24)
    let buckets = __builtin_malloc(256 * 16)  // 16 buckets * (key + value)
    __builtin_store64(m + MAP_BUCKETS, buckets)
    __builtin_store64(m + MAP_SIZE, 0)
    __builtin_store64(m + MAP_CAP, 16)
    m
}

func hash_int(key: Int) -> Int {
    let h = key
    h = h * 2654435761
    h
}

func map_insert(m: Int, key: Int, val: Int) {
    let buckets = __builtin_load64(m + MAP_BUCKETS)
    let cap = __builtin_load64(m + MAP_CAP)
    let idx = hash_int(key) % cap
    
    // Linear probe
    let i = idx
    // Simplified: just use first available slot
    __builtin_store64(buckets + i * 16, key)
    __builtin_store64(buckets + i * 16 + 8, val)
    
    let size = __builtin_load64(m + MAP_SIZE)
    __builtin_store64(m + MAP_SIZE, size + 1)
}

func map_get(m: Int, key: Int) -> Int {
    let buckets = __builtin_load64(m + MAP_BUCKETS)
    let cap = __builtin_load64(m + MAP_CAP)
    let idx = hash_int(key) % cap
    
    let stored_key = __builtin_load64(buckets + idx * 16)
    if stored_key == key {
        __builtin_load64(buckets + idx * 16 + 8)
    } else {
        0
    }
}

// Set - wrapper around map
func set_new() -> Int {
    map_new()
}

func set_add(s: Int, item: Int) {
    map_insert(s, item, 1)
}

func set_contains(s: Int, item: Int) -> Bool {
    map_get(s, item) != 0
}
