// AETHER COMPILER MACHO - Bootstrap Compatible
// Mach-O binary format

import std

// Mach-O header constants
const MH_MAGIC_64: Int = 0xFEEDFACF
const MH_EXECUTE: Int = 2
const CPU_TYPE_ARM64: Int = 0x0100000C

// Mach-O builder
func macho_new() -> Int {
    let m = ae_malloc(48)
    ae_store64(m, ae_malloc(65536))  // buffer
    ae_store64(m + 8, 0)             // size
    ae_store64(m + 16, 65536)        // capacity
    ae_store64(m + 24, 0)            // text offset
    ae_store64(m + 32, 0)            // data offset
    ae_store64(m + 40, 0)            // entry point
    m
}

func macho_write_header(m: Int) {
    let buf = ae_load64(m)
    ae_store64(buf, MH_MAGIC_64)
    ae_store64(buf + 4, CPU_TYPE_ARM64)
    ae_store64(buf + 8, 0)  // cpu subtype
    ae_store64(buf + 12, MH_EXECUTE)
    ae_store64(m + 8, 32)  // header size
}

func macho_add_text(m: Int, code: Int, size: Int) {
    let buf = ae_load64(m)
    let offset = ae_load64(m + 8)
    ae_store64(m + 24, offset)
    
    // Copy code
    let i = 0
    while i < size {
        ae_store8(buf + offset + i, ae_load8(code + i))
        i = i + 1
    }
    
    ae_store64(m + 8, offset + size)
}

func macho_set_entry(m: Int, entry: Int) {
    ae_store64(m + 40, entry)
}

func macho_finalize(m: Int) -> Int {
    ae_load64(m)  // Return buffer
}

func macho_size(m: Int) -> Int {
    ae_load64(m + 8)
}
