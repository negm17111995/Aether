// AETHER COMPILER ARM64 - Bootstrap Compatible
// ARM64 code generation

import std

// ARM64 registers
const ARM_X0: Int = 0
const ARM_X1: Int = 1
const ARM_X2: Int = 2
const ARM_X3: Int = 3
const ARM_LR: Int = 30
const ARM_SP: Int = 31

// Instruction buffer
func arm64_code_create() -> Int {
    let c = ae_malloc(24)
    ae_store64(c, ae_malloc(4096))
    ae_store64(c + 8, 0)
    ae_store64(c + 16, 4096)
    c
}

func arm64_emit_32(c: Int, inst: Int) {
    let buf = ae_load64(c)
    let off = ae_load64(c + 8)
    ae_store64(buf + off, inst)
    ae_store64(c + 8, off + 4)
}

// Shift helper (no << operator)
func arm64_shift_5(val: Int) -> Int {
    val * 32
}

func arm64_shift_16(val: Int) -> Int {
    val * 65536
}

// Common instructions (simplified without bit shifts)
func arm64_emit_mov(c: Int, rd: Int, imm: Int) {
    let inst = 0xD2800000 + (rd % 32) + arm64_shift_5(imm % 65536)
    arm64_emit_32(c, inst)
}

func arm64_emit_add(c: Int, rd: Int, rn: Int, rm: Int) {
    let inst = 0x8B000000 + (rd % 32) + arm64_shift_5(rn % 32) + arm64_shift_16(rm % 32)
    arm64_emit_32(c, inst)
}

func arm64_emit_sub(c: Int, rd: Int, rn: Int, rm: Int) {
    let inst = 0xCB000000 + (rd % 32) + arm64_shift_5(rn % 32) + arm64_shift_16(rm % 32)
    arm64_emit_32(c, inst)
}

func arm64_emit_ret(c: Int) {
    arm64_emit_32(c, 0xD65F03C0)
}

func arm64_emit_bl(c: Int, offset: Int) {
    let inst = 0x94000000 + (offset % 67108864)
    arm64_emit_32(c, inst)
}

func arm64_get_code_size(c: Int) -> Int {
    ae_load64(c + 8)
}

func arm64_get_code_ptr(c: Int) -> Int {
    ae_load64(c)
}
