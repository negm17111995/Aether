// Aether Vector Library - Single Source of Truth
// All vector operations consolidated here
// Used by: codegen, optimizer, collections, runtime

// ============================================================================
// VECTOR LAYOUT: [data_ptr, len, cap] at handle address
// ============================================================================

const VEC_DATA: Int = 0
const VEC_LEN: Int = 8
const VEC_CAP: Int = 16

// ============================================================================
// VECTOR OPERATIONS
// ============================================================================

// Create new empty vector
func vec_new() -> Int {
    let v = __builtin_malloc(24)
    let data = __builtin_malloc(64)  // Initial 8 elements
    __builtin_store64(v + VEC_DATA, data)
    __builtin_store64(v + VEC_LEN, 0)
    __builtin_store64(v + VEC_CAP, 8)
    v
}

// Create vector with initial capacity
func vec_with_capacity(cap: Int) -> Int {
    let v = __builtin_malloc(24)
    let data = __builtin_malloc(cap * 8)
    __builtin_store64(v + VEC_DATA, data)
    __builtin_store64(v + VEC_LEN, 0)
    __builtin_store64(v + VEC_CAP, cap)
    v
}

// Get vector length
func vec_len(v: Int) -> Int {
    __builtin_load64(v + VEC_LEN)
}

// Get vector capacity
func vec_cap(v: Int) -> Int {
    __builtin_load64(v + VEC_CAP)
}

// Get element at index
func vec_get(v: Int, idx: Int) -> Int {
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_load64(data + idx * 8)
}

// Set element at index
func vec_set(v: Int, idx: Int, val: Int) {
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_store64(data + idx * 8, val)
}

// Push element to end (auto-resize if needed)
func vec_push(v: Int, val: Int) {
    let len = __builtin_load64(v + VEC_LEN)
    let cap = __builtin_load64(v + VEC_CAP)
    
    // Resize if full
    if len >= cap {
        let new_cap = cap * 2
        let old_data = __builtin_load64(v + VEC_DATA)
        let new_data = __builtin_malloc(new_cap * 8)
        
        // Copy old data
        let i = 0
        while i < len {
            let src = __builtin_load64(old_data + i * 8)
            __builtin_store64(new_data + i * 8, src)
            i = i + 1
        }
        
        __builtin_store64(v + VEC_DATA, new_data)
        __builtin_store64(v + VEC_CAP, new_cap)
    }
    
    // Add new element
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_store64(data + len * 8, val)
    __builtin_store64(v + VEC_LEN, len + 1)
}

// Pop element from end
func vec_pop(v: Int) -> Int {
    let len = __builtin_load64(v + VEC_LEN)
    if len == 0 {
        return 0
    }
    
    let new_len = len - 1
    __builtin_store64(v + VEC_LEN, new_len)
    
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_load64(data + new_len * 8)
}

// Clear all elements
func vec_clear(v: Int) {
    __builtin_store64(v + VEC_LEN, 0)
}

// ============================================================================
// BYTE VECTOR OPERATIONS (for codegen/binary output)
// ============================================================================

// Push single byte
func vec_push8(v: Int, val: Int) {
    let len = __builtin_load64(v + VEC_LEN)
    let cap = __builtin_load64(v + VEC_CAP)
    
    if len >= cap {
        let new_cap = cap * 2
        let old_data = __builtin_load64(v + VEC_DATA)
        let new_data = __builtin_malloc(new_cap)
        
        let i = 0
        while i < len {
            let b = __builtin_load8(old_data + i)
            __builtin_store8(new_data + i, b)
            i = i + 1
        }
        
        __builtin_store64(v + VEC_DATA, new_data)
        __builtin_store64(v + VEC_CAP, new_cap)
    }
    
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_store8(data + len, val)
    __builtin_store64(v + VEC_LEN, len + 1)
}

// Get byte at index
func vec_get8(v: Int, idx: Int) -> Int {
    let data = __builtin_load64(v + VEC_DATA)
    __builtin_load8(data + idx)
}
