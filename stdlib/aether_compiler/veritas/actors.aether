// AETHER SELF-HOSTED COMPILER - ACTOR MODEL
// Message-passing concurrency with isolated actors

import std

// ============================================================================
// ACTOR STATE MACHINE
// ============================================================================

const ACTOR_IDLE: Int = 0
const ACTOR_RUNNING: Int = 1
const ACTOR_WAITING: Int = 2
const ACTOR_DEAD: Int = 3

// ============================================================================
// MESSAGE QUEUE
// ============================================================================

// Message: [data, next]
func msg_new(data: Int) -> Int {
    let m = ae_malloc(16)
    ae_store64(m, data)
    ae_store64(m + 8, 0)
    m
}

func msg_data(m: Int) -> Int { ae_load64(m) }
func msg_next(m: Int) -> Int { ae_load64(m + 8) }
func msg_set_next(m: Int, n: Int) { ae_store64(m + 8, n) }

// Queue: [head, tail, count]
func mqueue_new() -> Int {
    let q = ae_malloc(24)
    ae_store64(q, 0)
    ae_store64(q + 8, 0)
    ae_store64(q + 16, 0)
    q
}

func mqueue_head(q: Int) -> Int { ae_load64(q) }
func mqueue_tail(q: Int) -> Int { ae_load64(q + 8) }
func mqueue_count(q: Int) -> Int { ae_load64(q + 16) }
func mqueue_set_head(q: Int, h: Int) { ae_store64(q, h) }
func mqueue_set_tail(q: Int, t: Int) { ae_store64(q + 8, t) }
func mqueue_set_count(q: Int, c: Int) { ae_store64(q + 16, c) }

func mqueue_push(q: Int, data: Int) {
    let m = msg_new(data)
    if mqueue_count(q) == 0 {
        mqueue_set_head(q, m)
        mqueue_set_tail(q, m)
    } else {
        msg_set_next(mqueue_tail(q), m)
        mqueue_set_tail(q, m)
    }
    mqueue_set_count(q, mqueue_count(q) + 1)
}

func mqueue_pop(q: Int) -> Int {
    if mqueue_count(q) == 0 { return 0 - 1 }
    let m = mqueue_head(q)
    mqueue_set_head(q, msg_next(m))
    mqueue_set_count(q, mqueue_count(q) - 1)
    if mqueue_count(q) == 0 {
        mqueue_set_tail(q, 0)
    }
    msg_data(m)
}

// ============================================================================
// ACTOR REPRESENTATION
// ============================================================================

// Actor: [id, state, inbox, handler_fn, local_state]
const ACTOR_SIZE: Int = 40

func actor_new(id: Int, handler: Int) -> Int {
    let a = ae_malloc(ACTOR_SIZE)
    ae_store64(a, id)
    ae_store64(a + 8, ACTOR_IDLE)
    ae_store64(a + 16, mqueue_new())
    ae_store64(a + 24, handler)
    ae_store64(a + 32, 0)
    a
}

func actor_id(a: Int) -> Int { ae_load64(a) }
func actor_state(a: Int) -> Int { ae_load64(a + 8) }
func actor_inbox(a: Int) -> Int { ae_load64(a + 16) }
func actor_handler(a: Int) -> Int { ae_load64(a + 24) }
func actor_local(a: Int) -> Int { ae_load64(a + 32) }
func actor_set_state(a: Int, s: Int) { ae_store64(a + 8, s) }
func actor_set_local(a: Int, l: Int) { ae_store64(a + 32, l) }

// ============================================================================
// ACTOR RUNTIME
// ============================================================================

// Runtime: [actors, next_id, running]
func actor_runtime_new() -> Int {
    let rt = ae_malloc(24)
    ae_store64(rt, vec_new())
    ae_store64(rt + 8, 1)
    ae_store64(rt + 16, 1)
    rt
}

func rt_actors(rt: Int) -> Int { ae_load64(rt) }
func rt_next_id(rt: Int) -> Int { ae_load64(rt + 8) }
func rt_running(rt: Int) -> Int { ae_load64(rt + 16) }
func rt_set_next_id(rt: Int, id: Int) { ae_store64(rt + 8, id) }
func rt_set_running(rt: Int, r: Int) { ae_store64(rt + 16, r) }

// Spawn new actor
func actor_spawn(rt: Int, handler: Int) -> Int {
    let id = rt_next_id(rt)
    rt_set_next_id(rt, id + 1)
    let a = actor_new(id, handler)
    vec_push(rt_actors(rt), a)
    id
}

// Find actor by ID
func actor_find(rt: Int, id: Int) -> Int {
    let actors = rt_actors(rt)
    let i = 0
    while i < vec_len(actors) {
        let a = vec_get(actors, i)
        if actor_id(a) == id { return a }
        i = i + 1
    }
    0
}

// Send message to actor
func actor_send(rt: Int, target_id: Int, msg: Int) -> Int {
    let target = actor_find(rt, target_id)
    if target == 0 { return 0 }
    mqueue_push(actor_inbox(target), msg)
    1
}

// Receive message (blocking in real impl, immediate for codegen)
func actor_receive(a: Int) -> Int {
    mqueue_pop(actor_inbox(a))
}

// Process one message for an actor
func actor_step(a: Int) -> Int {
    let inbox = actor_inbox(a)
    if mqueue_count(inbox) == 0 { return 0 }
    
    actor_set_state(a, ACTOR_RUNNING)
    let msg = mqueue_pop(inbox)
    // In real impl, call handler with msg
    // handler(a, msg)
    actor_set_state(a, ACTOR_IDLE)
    1
}

// Run all actors until no messages
func actor_run_all(rt: Int) {
    let changed = 1
    while changed == 1 {
        changed = 0
        let actors = rt_actors(rt)
        let i = 0
        while i < vec_len(actors) {
            let a = vec_get(actors, i)
            if actor_state(a) != ACTOR_DEAD {
                let stepped = actor_step(a)
                if stepped == 1 { changed = 1 }
            }
            i = i + 1
        }
    }
}

// ============================================================================
// ACTOR AST NODES
// ============================================================================


func ast_actor_def(name: Int, state_fields: Int, handlers: Int, line: Int, col: Int) -> Int {
    let node = ast_new(AST_ACTOR_DEF, line, col)
    ast_set_data1(node, name)
    ast_set_data2(node, state_fields)
    ast_set_data3(node, handlers)
    node
}

func ast_send_expr(target: Int, message: Int, line: Int, col: Int) -> Int {
    let node = ast_new(AST_SEND_EXPR, line, col)
    ast_set_data1(node, target)
    ast_set_data2(node, message)
    node
}

func ast_receive_expr(line: Int, col: Int) -> Int {
    let node = ast_new(AST_RECEIVE_EXPR, line, col)
    node
}

// ============================================================================
// CODEGEN FOR ACTORS
// ============================================================================

// Generate actor struct
func actor_emit_struct(g: Int, name: Int, fields: Int) {
    // typedef struct { long long state; MessageQueue* inbox; ... } ActorName;
    cg_emit_char(g, 116) cg_emit_char(g, 121) cg_emit_char(g, 112) // typ
    cg_emit_char(g, 101) cg_emit_char(g, 100) cg_emit_char(g, 101) // ede
    cg_emit_char(g, 102) cg_emit_space(g) // f 
    cg_emit_char(g, 115) cg_emit_char(g, 116) cg_emit_char(g, 114) // str
    cg_emit_char(g, 117) cg_emit_char(g, 99) cg_emit_char(g, 116) // uct
    cg_emit_space(g) cg_emit_char(g, 123)
    cg_emit_nl(g)
    
    // Actor base fields
    cg_emit_space(g) cg_emit_space(g) cg_emit_space(g) cg_emit_space(g)
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // long
    cg_emit_space(g)
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // long
    cg_emit_space(g)
    // _state
    cg_emit_char(g, 95) cg_emit_char(g, 115) cg_emit_char(g, 116) // _st
    cg_emit_char(g, 97) cg_emit_char(g, 116) cg_emit_char(g, 101) // ate
    cg_emit_char(g, 59)
    cg_emit_nl(g)
    
    // _inbox
    cg_emit_space(g) cg_emit_space(g) cg_emit_space(g) cg_emit_space(g)
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // long
    cg_emit_space(g)
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // long
    cg_emit_space(g)
    // _inbox
    cg_emit_char(g, 95) cg_emit_char(g, 105) cg_emit_char(g, 110) // _in
    cg_emit_char(g, 98) cg_emit_char(g, 111) cg_emit_char(g, 120) // box
    cg_emit_char(g, 59)
    cg_emit_nl(g)
    
    // User fields
    let i = 0
    while i < vec_len(fields) {
        let f = vec_get(fields, i)
        cg_emit_space(g) cg_emit_space(g) cg_emit_space(g) cg_emit_space(g)
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // long
        cg_emit_space(g)
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // long
        cg_emit_space(g)
        cg_emit_cstr(g, ae_load64(f))
        cg_emit_char(g, 59)
        cg_emit_nl(g)
        i = i + 1
    }
    
    cg_emit_char(g, 125) cg_emit_space(g)
    cg_emit_cstr(g, name)
    cg_emit_char(g, 59)
    cg_emit_nl(g) cg_emit_nl(g)
}

// Generate send function
func actor_emit_send(g: Int, target: Int, msg: Int) {
    // actor_send(runtime, target, msg)
    cg_emit_char(g, 97) cg_emit_char(g, 99) cg_emit_char(g, 116) // act
    cg_emit_char(g, 111) cg_emit_char(g, 114) // or
    cg_emit_char(g, 95)
    cg_emit_char(g, 115) cg_emit_char(g, 101) cg_emit_char(g, 110) // sen
    cg_emit_char(g, 100) // d
    cg_emit_char(g, 40)
    cg_emit_char(g, 95) cg_emit_char(g, 114) cg_emit_char(g, 116) // _rt
    cg_emit_char(g, 44) cg_emit_space(g)
    cg_emit_expr(g, target)
    cg_emit_char(g, 44) cg_emit_space(g)
    cg_emit_expr(g, msg)
    cg_emit_char(g, 41)
}

// Generate receive
func actor_emit_receive(g: Int) {
    // actor_receive(_self)
    cg_emit_char(g, 97) cg_emit_char(g, 99) cg_emit_char(g, 116) // act
    cg_emit_char(g, 111) cg_emit_char(g, 114) // or
    cg_emit_char(g, 95)
    cg_emit_char(g, 114) cg_emit_char(g, 101) cg_emit_char(g, 99) // rec
    cg_emit_char(g, 101) cg_emit_char(g, 105) cg_emit_char(g, 118) // eiv
    cg_emit_char(g, 101) // e
    cg_emit_char(g, 40)
    cg_emit_char(g, 95) cg_emit_char(g, 115) cg_emit_char(g, 101) // _se
    cg_emit_char(g, 108) cg_emit_char(g, 102) // lf
    cg_emit_char(g, 41)
}
