// AETHER SELF-HOSTED COMPILER - QUERY-BASED BUILD
// Incremental compilation with content hashing

import std

// ============================================================================
// FNV-1A HASH
// ============================================================================

const FNV_OFFSET: Int = 14695981039346656037
const FNV_PRIME: Int = 1099511628211

func fnv_hash_init() -> Int {
    FNV_OFFSET
}

func fnv_hash_byte(h: Int, b: Int) -> Int {
    let xored = h ^ b
    xored * FNV_PRIME
}

func fnv_hash_string(s: Int) -> Int {
    let h = fnv_hash_init()
    let i = 0
    while 1 == 1 {
        let c = ae_load8(s + i)
        if c == 0 { return h }
        h = fnv_hash_byte(h, c)
        i = i + 1
    }
    h
}

func fnv_hash_bytes(data: Int, len: Int) -> Int {
    let h = fnv_hash_init()
    let i = 0
    while i < len {
        h = fnv_hash_byte(h, ae_load8(data + i))
        i = i + 1
    }
    h
}

// ============================================================================
// QUERY CACHE
// ============================================================================

// CacheEntry: [key_hash, result_hash, result_ptr, is_valid]
func cache_entry_new(key: Int, result: Int, ptr: Int) -> Int {
    let e = ae_malloc(32)
    ae_store64(e, key)
    ae_store64(e + 8, result)
    ae_store64(e + 16, ptr)
    ae_store64(e + 24, 1)
    e
}

func cache_entry_key(e: Int) -> Int { ae_load64(e) }
func cache_entry_result(e: Int) -> Int { ae_load64(e + 8) }
func cache_entry_ptr(e: Int) -> Int { ae_load64(e + 16) }
func cache_entry_valid(e: Int) -> Int { ae_load64(e + 24) }
func cache_entry_invalidate(e: Int) { ae_store64(e + 24, 0) }

// QueryCache: [entries, hit_count, miss_count]
func query_cache_new() -> Int {
    let c = ae_malloc(24)
    ae_store64(c, vec_new())
    ae_store64(c + 8, 0)
    ae_store64(c + 16, 0)
    c
}

func cache_entries(c: Int) -> Int { ae_load64(c) }
func cache_hits(c: Int) -> Int { ae_load64(c + 8) }
func cache_misses(c: Int) -> Int { ae_load64(c + 16) }
func cache_add_hit(c: Int) { ae_store64(c + 8, cache_hits(c) + 1) }
func cache_add_miss(c: Int) { ae_store64(c + 16, cache_misses(c) + 1) }

// Lookup in cache
func cache_lookup(c: Int, key_hash: Int) -> Int {
    let entries = cache_entries(c)
    let i = 0
    while i < vec_len(entries) {
        let e = vec_get(entries, i)
        if cache_entry_key(e) == key_hash {
            if cache_entry_valid(e) == 1 {
                cache_add_hit(c)
                return cache_entry_ptr(e)
            }
        }
        i = i + 1
    }
    cache_add_miss(c)
    0
}

// Store in cache
func cache_store(c: Int, key_hash: Int, result_hash: Int, ptr: Int) {
    let entries = cache_entries(c)
    
    // Check if updating existing entry
    let i = 0
    while i < vec_len(entries) {
        let e = vec_get(entries, i)
        if cache_entry_key(e) == key_hash {
            ae_store64(e + 8, result_hash)
            ae_store64(e + 16, ptr)
            ae_store64(e + 24, 1)
            return
        }
        i = i + 1
    }
    
    // New entry
    vec_push(entries, cache_entry_new(key_hash, result_hash, ptr))
}

// Invalidate entries matching key
func cache_invalidate(c: Int, key_hash: Int) {
    let entries = cache_entries(c)
    let i = 0
    while i < vec_len(entries) {
        let e = vec_get(entries, i)
        if cache_entry_key(e) == key_hash {
            cache_entry_invalidate(e)
        }
        i = i + 1
    }
}

// ============================================================================
// DEPENDENCY GRAPH
// ============================================================================

// DepNode: [file_hash, deps, dependents, last_hash]
func dep_node_new(file_hash: Int) -> Int {
    let n = ae_malloc(32)
    ae_store64(n, file_hash)
    ae_store64(n + 8, vec_new())   // deps (what I depend on)
    ae_store64(n + 16, vec_new())  // dependents (what depends on me)
    ae_store64(n + 24, 0)          // last content hash
    n
}

func dep_node_file(n: Int) -> Int { ae_load64(n) }
func dep_node_deps(n: Int) -> Int { ae_load64(n + 8) }
func dep_node_dependents(n: Int) -> Int { ae_load64(n + 16) }
func dep_node_hash(n: Int) -> Int { ae_load64(n + 24) }
func dep_node_set_hash(n: Int, h: Int) { ae_store64(n + 24, h) }

// DepGraph: [nodes]
func dep_graph_new() -> Int {
    let g = ae_malloc(8)
    ae_store64(g, vec_new())
    g
}

func dep_graph_nodes(g: Int) -> Int { ae_load64(g) }

func dep_graph_find(g: Int, file_hash: Int) -> Int {
    let nodes = dep_graph_nodes(g)
    let i = 0
    while i < vec_len(nodes) {
        let n = vec_get(nodes, i)
        if dep_node_file(n) == file_hash { return n }
        i = i + 1
    }
    0
}

func dep_graph_add(g: Int, file_hash: Int) -> Int {
    let existing = dep_graph_find(g, file_hash)
    if existing != 0 { return existing }
    let n = dep_node_new(file_hash)
    vec_push(dep_graph_nodes(g), n)
    n
}

func dep_graph_add_edge(g: Int, from_hash: Int, to_hash: Int) {
    let from_node = dep_graph_add(g, from_hash)
    let to_node = dep_graph_add(g, to_hash)
    vec_push(dep_node_deps(from_node), to_hash)
    vec_push(dep_node_dependents(to_node), from_hash)
}

// ============================================================================
// DIRTY CHECKING
// ============================================================================

// Check if file needs recompilation
func check_dirty(g: Int, file_hash: Int, new_content_hash: Int) -> Int {
    let node = dep_graph_find(g, file_hash)
    if node == 0 { return 1 }  // New file, always dirty
    
    let old_hash = dep_node_hash(node)
    if old_hash != new_content_hash { return 1 }  // Content changed
    
    // Check if any dependency is dirty
    let deps = dep_node_deps(node)
    let i = 0
    while i < vec_len(deps) {
        let dep_hash = vec_get(deps, i)
        let dep_node = dep_graph_find(g, dep_hash)
        if dep_node != 0 {
            // Would need to check if dep is dirty too (recursive)
            // Simplified: assume deps are clean
        }
        i = i + 1
    }
    
    0  // Not dirty
}

// Mark file and dependents as needing recompilation
func propagate_dirty(g: Int, file_hash: Int) {
    let node = dep_graph_find(g, file_hash)
    if node == 0 { return }
    
    // Mark all dependents dirty (in real impl, set a dirty flag)
    let dependents = dep_node_dependents(node)
    let i = 0
    while i < vec_len(dependents) {
        let dep_hash = vec_get(dependents, i)
        propagate_dirty(g, dep_hash)  // Recursive
        i = i + 1
    }
}

// ============================================================================
// QUERY FUNCTIONS
// ============================================================================

// Query: parse file (cached)
func query_parse(cache: Int, graph: Int, file_hash: Int, content: Int) -> Int {
    let content_hash = fnv_hash_string(content)
    
    // Check cache
    let cached = cache_lookup(cache, file_hash)
    if cached != 0 {
        // Verify content hash matches
        let entries = cache_entries(cache)
        let i = 0
        while i < vec_len(entries) {
            let e = vec_get(entries, i)
            if cache_entry_key(e) == file_hash {
                if cache_entry_result(e) == content_hash {
                    return cached  // Cache hit!
                }
            }
            i = i + 1
        }
    }
    
    // Cache miss - would parse and store
    // let ast = parse(tokenize(content, len))
    // cache_store(cache, file_hash, content_hash, ast)
    
    0  // Placeholder
}

// Query: type check (cached)
func query_typecheck(cache: Int, ast_hash: Int, ast: Int) -> Int {
    let cached = cache_lookup(cache, ast_hash)
    if cached != 0 { return cached }
    
    // Would type check and cache
    0
}
