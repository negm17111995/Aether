// AETHER SELF-HOSTED COMPILER - ALGEBRAIC EFFECTS (FULL)
// Effect handlers with resume continuations

import std

// ============================================================================
// EFFECT TYPES
// ============================================================================

const EFF_PURE: Int = 0
const EFF_IO: Int = 1
const EFF_ASYNC: Int = 2
const EFF_THROW: Int = 3
const EFF_STATE: Int = 4
const EFF_YIELD: Int = 5

// ============================================================================
// EFFECT DECLARATION
// ============================================================================

// EffectDecl: [name, operations]
func effect_decl_new(name: Int) -> Int {
    let e = ae_malloc(16)
    ae_store64(e, name)
    ae_store64(e + 8, vec_new())
    e
}

func effect_decl_name(e: Int) -> Int { ae_load64(e) }
func effect_decl_ops(e: Int) -> Int { ae_load64(e + 8) }

// EffectOp: [name, param_type, return_type]
func effect_op_new(name: Int, param: Int, ret: Int) -> Int {
    let op = ae_malloc(24)
    ae_store64(op, name)
    ae_store64(op + 8, param)
    ae_store64(op + 16, ret)
    op
}

func effect_op_name(op: Int) -> Int { ae_load64(op) }
func effect_op_param(op: Int) -> Int { ae_load64(op + 8) }
func effect_op_return(op: Int) -> Int { ae_load64(op + 16) }

// ============================================================================
// EFFECT HANDLER
// ============================================================================

// Handler: [effect, handlers_map, return_handler]
func handler_new_full(effect: Int) -> Int {
    let h = ae_malloc(24)
    ae_store64(h, effect)
    ae_store64(h + 8, vec_new())  // op handlers
    ae_store64(h + 16, 0)         // return handler
    h
}

func handler_effect(h: Int) -> Int { ae_load64(h) }
func handler_ops(h: Int) -> Int { ae_load64(h + 8) }
func handler_return(h: Int) -> Int { ae_load64(h + 16) }
func handler_set_return(h: Int, r: Int) { ae_store64(h + 16, r) }

// OpHandler: [op_name, handler_func, uses_resume]
func op_handler_new(op: Int, func_ptr: Int, uses_resume: Int) -> Int {
    let oh = ae_malloc(24)
    ae_store64(oh, op)
    ae_store64(oh + 8, func_ptr)
    ae_store64(oh + 16, uses_resume)
    oh
}

func op_handler_add(h: Int, op: Int, func_ptr: Int, uses_resume: Int) {
    vec_push(handler_ops(h), op_handler_new(op, func_ptr, uses_resume))
}

// ============================================================================
// CONTINUATION (RESUME)
// ============================================================================

// Continuation: [frame_ptr, next_continuation]
func continuation_new(frame: Int) -> Int {
    let k = ae_malloc(16)
    ae_store64(k, frame)
    ae_store64(k + 8, 0)
    k
}

func continuation_frame(k: Int) -> Int { ae_load64(k) }
func continuation_next(k: Int) -> Int { ae_load64(k + 8) }
func continuation_set_next(k: Int, n: Int) { ae_store64(k + 8, n) }

// Resume a continuation with a value
func continuation_resume(k: Int, value: Int) -> Int {
    // In real impl, this would restore the stack frame
    // For codegen, we generate a function call to the resume point
    value
}

// ============================================================================
// EFFECT CONTEXT
// ============================================================================

// EffectCtx: [handler_stack, current_continuation]
func effect_ctx_full_new() -> Int {
    let ctx = ae_malloc(16)
    ae_store64(ctx, vec_new())
    ae_store64(ctx + 8, 0)
    ctx
}

func ectx_handlers(ctx: Int) -> Int { ae_load64(ctx) }
func ectx_continuation(ctx: Int) -> Int { ae_load64(ctx + 8) }
func ectx_set_continuation(ctx: Int, k: Int) { ae_store64(ctx + 8, k) }

// Push handler onto stack
func ectx_push_handler(ctx: Int, h: Int) {
    vec_push(ectx_handlers(ctx), h)
}

// Pop handler from stack
func ectx_pop_handler(ctx: Int) -> Int {
    let stack = ectx_handlers(ctx)
    if vec_len(stack) == 0 { return 0 }
    // Pop last element
    let h = vec_get(stack, vec_len(stack) - 1)
    // Note: would need vec_pop in real impl
    h
}

// Find handler for effect operation
func ectx_find_handler(ctx: Int, effect: Int, op: Int) -> Int {
    let stack = ectx_handlers(ctx)
    let i = vec_len(stack) - 1
    while i >= 0 {
        let h = vec_get(stack, i)
        if handler_effect(h) == effect {
            let ops = handler_ops(h)
            let j = 0
            while j < vec_len(ops) {
                let oh = vec_get(ops, j)
                if ae_load64(oh) == op { return oh }
                j = j + 1
            }
        }
        i = i - 1
    }
    0
}

// ============================================================================
// EFFECT AST NODES
// ============================================================================


func ast_effect_decl(name: Int, ops: Int, line: Int, col: Int) -> Int {
    let node = ast_new(AST_EFFECT_DECL, line, col)
    ast_set_data1(node, name)
    ast_set_data2(node, ops)
    node
}

func ast_effect_handler(effect: Int, op_handlers: Int, line: Int, col: Int) -> Int {
    let node = ast_new(AST_EFFECT_HANDLER, line, col)
    ast_set_data1(node, effect)
    ast_set_data2(node, op_handlers)
    node
}

func ast_perform(effect: Int, op: Int, arg: Int, line: Int, col: Int) -> Int {
    let node = ast_new(AST_PERFORM, line, col)
    ast_set_data1(node, effect)
    ast_set_data2(node, op)
    ast_set_data3(node, arg)
    node
}

func ast_resume(value: Int, line: Int, col: Int) -> Int {
    let node = ast_new(AST_RESUME, line, col)
    ast_set_data1(node, value)
    node
}

// ============================================================================
// EFFECT TYPE CHECKING
// ============================================================================

// Check that all effects are handled
func check_effect_coverage(ctx: Int, inferred: Int, handlers: Int) -> Int {
    let i = 0
    while i < vec_len(inferred) {
        let eff = vec_get(inferred, i)
        let found = 0
        let j = 0
        while j < vec_len(handlers) {
            let h = vec_get(handlers, j)
            if handler_effect(h) == eff { found = 1 }
            j = j + 1
        }
        if found == 0 { return 0 }  // Unhandled effect
        i = i + 1
    }
    1  // All effects handled
}

// ============================================================================
// CODEGEN FOR EFFECTS
// ============================================================================

// Generate effect struct
func effect_emit_struct(g: Int, name: Int, ops: Int) {
    // typedef struct { void (*op1)(void*, int); ... } EffectName;
    cg_emit_char(g, 116) cg_emit_char(g, 121) cg_emit_char(g, 112) // typ
    cg_emit_char(g, 101) cg_emit_char(g, 100) cg_emit_char(g, 101) // ede
    cg_emit_char(g, 102) cg_emit_space(g) // f 
    cg_emit_char(g, 115) cg_emit_char(g, 116) cg_emit_char(g, 114) // str
    cg_emit_char(g, 117) cg_emit_char(g, 99) cg_emit_char(g, 116) // uct
    cg_emit_space(g) cg_emit_char(g, 123)
    cg_emit_nl(g)
    
    // Generate function pointers for each operation
    let i = 0
    while i < vec_len(ops) {
        let op = vec_get(ops, i)
        cg_emit_space(g) cg_emit_space(g) cg_emit_space(g) cg_emit_space(g)
        // long long (*opname)(void*, long long);
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103)
        cg_emit_space(g)
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103)
        cg_emit_space(g)
        cg_emit_char(g, 40) cg_emit_char(g, 42) // (*
        cg_emit_cstr(g, effect_op_name(op))
        cg_emit_char(g, 41) // )
        cg_emit_char(g, 40)
        cg_emit_char(g, 118) cg_emit_char(g, 111) cg_emit_char(g, 105) cg_emit_char(g, 100) // void
        cg_emit_char(g, 42) // *
        cg_emit_char(g, 44) cg_emit_space(g)
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103)
        cg_emit_space(g)
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103)
        cg_emit_char(g, 41) cg_emit_char(g, 59)
        cg_emit_nl(g)
        i = i + 1
    }
    
    cg_emit_char(g, 125) cg_emit_space(g)
    cg_emit_cstr(g, name)
    cg_emit_char(g, 59)
    cg_emit_nl(g) cg_emit_nl(g)
}

// Generate try-handle block
func effect_emit_try_handle(g: Int, body: Int, handlers: Int) {
    // { EffectHandler _handler = { ... }; push_handler(&_handler); body; pop_handler(); }
    cg_emit_char(g, 123)
    cg_emit_nl(g)
    cg_emit_indent(g)
    cg_emit_space(g) cg_emit_space(g) cg_emit_space(g) cg_emit_space(g)
    // Handler setup would go here
    cg_emit_block(g, body)
    cg_emit_indent(g)
    cg_emit_char(g, 125)
    cg_emit_nl(g)
}

// Generate perform (effect invocation)
func effect_emit_perform(g: Int, handler_var: Int, op: Int, arg: Int) {
    // _handler->op(_ctx, arg)
    cg_emit_cstr(g, handler_var)
    cg_emit_char(g, 45) cg_emit_char(g, 62) // ->
    cg_emit_cstr(g, op)
    cg_emit_char(g, 40)
    cg_emit_char(g, 95) cg_emit_char(g, 99) cg_emit_char(g, 116) cg_emit_char(g, 120) // _ctx
    cg_emit_char(g, 44) cg_emit_space(g)
    cg_emit_expr(g, arg)
    cg_emit_char(g, 41)
}

// Generate resume
func effect_emit_resume(g: Int, value: Int) {
    // return value;  (simplified - real impl uses continuations)
    cg_emit_char(g, 114) cg_emit_char(g, 101) cg_emit_char(g, 116) // ret
    cg_emit_char(g, 117) cg_emit_char(g, 114) cg_emit_char(g, 110) // urn
    cg_emit_space(g)
    cg_emit_expr(g, value)
}
