// AETHER SELF-HOSTED COMPILER - HARDWARE-AWARE COMPTIME
// Compile-time evaluation with platform detection

import std

// ============================================================================
// ARCHITECTURE CONSTANTS
// ============================================================================

const ARCH_UNKNOWN: Int = 0
const ARCH_X86_64: Int = 1
const ARCH_ARM64: Int = 2
const ARCH_APPLE_M: Int = 3
const ARCH_RISCV: Int = 4

const SIMD_NONE: Int = 0
const SIMD_SSE: Int = 1
const SIMD_AVX: Int = 2
const SIMD_AVX2: Int = 3
const SIMD_AVX512: Int = 4
const SIMD_NEON: Int = 10

// ============================================================================
// STRING COMPARISON (MUST BE FIRST)
// ============================================================================

func str_eq_ct(a: Int, b: Int) -> Int {
    if a == 0 || b == 0 { if a == b { return 1 } return 0 }
    let i = 0
    while 1 == 1 {
        let ca = ae_load8(a + i)
        let cb = ae_load8(b + i)
        if ca != cb { return 0 }
        if ca == 0 { return 1 }
        i = i + 1
    }
    0
}

// ============================================================================
// NAME HELPERS (MUST BE BEFORE EVAL)
// ============================================================================

func comptime_arch_name() -> Int {
    let s = ae_malloc(8)
    ae_store8(s, 64) ae_store8(s + 1, 97) ae_store8(s + 2, 114)
    ae_store8(s + 3, 99) ae_store8(s + 4, 104) ae_store8(s + 5, 0)
    s
}

func comptime_simd_name() -> Int {
    let s = ae_malloc(8)
    ae_store8(s, 64) ae_store8(s + 1, 115) ae_store8(s + 2, 105)
    ae_store8(s + 3, 109) ae_store8(s + 4, 100) ae_store8(s + 5, 0)
    s
}

func comptime_sizeof_name() -> Int {
    let s = ae_malloc(10)
    ae_store8(s, 64) ae_store8(s + 1, 115) ae_store8(s + 2, 105)
    ae_store8(s + 3, 122) ae_store8(s + 4, 101) ae_store8(s + 5, 111)
    ae_store8(s + 6, 102) ae_store8(s + 7, 0)
    s
}

func comptime_arch_cfg() -> Int {
    let s = ae_malloc(8)
    ae_store8(s, 97) ae_store8(s + 1, 114) ae_store8(s + 2, 99)
    ae_store8(s + 3, 104) ae_store8(s + 4, 0)
    s
}

func comptime_simd_cfg() -> Int {
    let s = ae_malloc(8)
    ae_store8(s, 115) ae_store8(s + 1, 105) ae_store8(s + 2, 109)
    ae_store8(s + 3, 100) ae_store8(s + 4, 0)
    s
}

// ============================================================================
// PLATFORM DETECTION
// ============================================================================

func comptime_detect_arch() -> Int { ARCH_APPLE_M }

func comptime_detect_simd() -> Int {
    let arch = comptime_detect_arch()
    if arch == ARCH_APPLE_M { return SIMD_NEON }
    if arch == ARCH_ARM64 { return SIMD_NEON }
    if arch == ARCH_X86_64 { return SIMD_AVX2 }
    SIMD_NONE
}

// ============================================================================
// COMPTIME CONTEXT
// ============================================================================

func comptime_ctx_new() -> Int {
    let ctx = ae_malloc(32)
    ae_store64(ctx, vec_new())
    ae_store64(ctx + 8, comptime_detect_arch())
    ae_store64(ctx + 16, comptime_detect_simd())
    ae_store64(ctx + 24, 0)
    ctx
}

func comptime_ctx_arch(ctx: Int) -> Int { ae_load64(ctx + 8) }
func comptime_ctx_simd(ctx: Int) -> Int { ae_load64(ctx + 16) }
func comptime_ctx_bindings(ctx: Int) -> Int { ae_load64(ctx) }

func comptime_bind(ctx: Int, name: Int, value: Int) {
    let binding = ae_malloc(16)
    ae_store64(binding, name)
    ae_store64(binding + 8, value)
    vec_push(comptime_ctx_bindings(ctx), binding)
}

func comptime_lookup(ctx: Int, name: Int) -> Int {
    let bindings = comptime_ctx_bindings(ctx)
    let i = 0
    while i < vec_len(bindings) {
        let b = vec_get(bindings, i)
        if str_eq_ct(ae_load64(b), name) == 1 { return ae_load64(b + 8) }
        i = i + 1
    }
    0
}

// ============================================================================
// COMPTIME EXPRESSION EVALUATOR
// ============================================================================

func comptime_eval(ctx: Int, node: Int) -> Int {
    if node == 0 { return 0 }
    
    let kind = ast_kind(node)
    
    if kind == AST_INT_LIT { return ast_data1(node) }
    
    if kind == AST_IDENT {
        let val = comptime_lookup(ctx, ast_data1(node))
        if val != 0 { return val }
        return 0 - 1
    }
    
    if kind == AST_BINARY {
        let left = comptime_eval(ctx, ast_data2(node))
        let right = comptime_eval(ctx, ast_data3(node))
        if left == 0 - 1 { return 0 - 1 }
        if right == 0 - 1 { return 0 - 1 }
        
        let op = ast_data1(node)
        if op == TOK_PLUS { return left + right }
        if op == TOK_MINUS { return left - right }
        if op == TOK_STAR { return left * right }
        if op == TOK_SLASH { if right != 0 { return left / right } return 0 }
        if op == TOK_EQEQ { if left == right { return 1 } return 0 }
        if op == TOK_LT { if left < right { return 1 } return 0 }
        if op == TOK_GT { if left > right { return 1 } return 0 }
        return 0 - 1
    }
    
    if kind == AST_CALL {
        let func_node = ast_data1(node)
        if ast_kind(func_node) == AST_IDENT {
            let name = ast_data1(func_node)
            if str_eq_ct(name, comptime_arch_name()) == 1 { return comptime_ctx_arch(ctx) }
            if str_eq_ct(name, comptime_simd_name()) == 1 { return comptime_ctx_simd(ctx) }
            if str_eq_ct(name, comptime_sizeof_name()) == 1 { return 8 }
        }
    }
    
    0 - 1
}

// ============================================================================
// CFG CHECK
// ============================================================================

func comptime_check_cfg(ctx: Int, cfg_name: Int, cfg_value: Int) -> Int {
    if str_eq_ct(cfg_name, comptime_arch_cfg()) == 1 {
        if cfg_value == ARCH_APPLE_M { return comptime_ctx_arch(ctx) == ARCH_APPLE_M }
        if cfg_value == ARCH_X86_64 { return comptime_ctx_arch(ctx) == ARCH_X86_64 }
    }
    if str_eq_ct(cfg_name, comptime_simd_cfg()) == 1 {
        if cfg_value == SIMD_NEON { return comptime_ctx_simd(ctx) == SIMD_NEON }
    }
    0
}

// ============================================================================
// CODEGEN
// ============================================================================

func comptime_emit_value(g: Int, value: Int) { cg_emit_int(g, value) }

func comptime_emit_arch_check(g: Int) {
    cg_emit_char(g, 35) cg_emit_char(g, 105) cg_emit_char(g, 102) cg_emit_space(g)
    cg_emit_char(g, 100) cg_emit_char(g, 101) cg_emit_char(g, 102)
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 101) cg_emit_char(g, 100)
    cg_emit_char(g, 40) cg_emit_char(g, 95) cg_emit_char(g, 95)
    cg_emit_char(g, 65) cg_emit_char(g, 80) cg_emit_char(g, 80)
    cg_emit_char(g, 76) cg_emit_char(g, 69) cg_emit_char(g, 95) cg_emit_char(g, 95)
    cg_emit_char(g, 41) cg_emit_nl(g)
    cg_emit_int(g, ARCH_APPLE_M) cg_emit_nl(g)
    cg_emit_char(g, 35) cg_emit_char(g, 101) cg_emit_char(g, 110) cg_emit_char(g, 100)
    cg_emit_char(g, 105) cg_emit_char(g, 102) cg_emit_nl(g)
}
