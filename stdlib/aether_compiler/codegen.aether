// AETHER SELF-HOSTED COMPILER - CODE GENERATOR
// Complete C code generation with all features

import std

// ============================================================================
// CODEGEN STATE
// ============================================================================

func codegen_new() -> Int {
    let g = ae_malloc(48)
    let cap = 131072
    ae_store64(g, ae_malloc(cap))  // output buffer
    ae_store64(g + 8, 0)           // length
    ae_store64(g + 16, cap)        // capacity
    ae_store64(g + 24, 0)          // indent level
    ae_store64(g + 32, vec_new())  // struct table
    ae_store64(g + 40, vec_new())  // trait table
    g
}

func cg_out(g: Int) -> Int { ae_load64(g) }
func cg_len(g: Int) -> Int { ae_load64(g + 8) }
func cg_indent(g: Int) -> Int { ae_load64(g + 24) }
func cg_set_len(g: Int, n: Int) { ae_store64(g + 8, n) }
func cg_set_indent(g: Int, n: Int) { ae_store64(g + 24, n) }
func cg_structs(g: Int) -> Int { ae_load64(g + 32) }
func cg_traits(g: Int) -> Int { ae_load64(g + 40) }

// ============================================================================
// OUTPUT HELPERS
// ============================================================================

func cg_emit_char(g: Int, c: Int) {
    let len = cg_len(g)
    let out = cg_out(g)
    ae_store8(out + len, c)
    cg_set_len(g, len + 1)
}

func cg_emit_cstr(g: Int, s: Int) {
    if s == 0 { return }
    let i = 0
    let c = ae_load8(s + i)
    while c != 0 {
        cg_emit_char(g, c)
        i = i + 1
        c = ae_load8(s + i)
    }
}

func cg_emit_int(g: Int, n: Int) {
    if n < 0 {
        cg_emit_char(g, 45)
        n = 0 - n
    }
    if n == 0 {
        cg_emit_char(g, 48)
        return
    }
    
    let buf = ae_malloc(32)
    let i = 0
    while n > 0 {
        ae_store8(buf + i, 48 + (n % 10))
        n = n / 10
        i = i + 1
    }
    
    while i > 0 {
        i = i - 1
        cg_emit_char(g, ae_load8(buf + i))
    }
}

func cg_emit_indent(g: Int) {
    let indent = cg_indent(g)
    let i = 0
    while i < indent {
        cg_emit_char(g, 32)
        cg_emit_char(g, 32)
        cg_emit_char(g, 32)
        cg_emit_char(g, 32)
        i = i + 1
    }
}

func cg_emit_nl(g: Int) {
    cg_emit_char(g, 10)
}

func cg_emit_space(g: Int) {
    cg_emit_char(g, 32)
}

// ============================================================================
// C HEADER
// ============================================================================

func cg_emit_header(g: Int) {
    // /* Aether Self-Hosted Compiler Output */
    cg_emit_char(g, 47) cg_emit_char(g, 42) cg_emit_char(g, 32)
    // A e t h e r
    cg_emit_char(g, 65) cg_emit_char(g, 101) cg_emit_char(g, 116)
    cg_emit_char(g, 104) cg_emit_char(g, 101) cg_emit_char(g, 114)
    cg_emit_char(g, 32) cg_emit_char(g, 42) cg_emit_char(g, 47)
    cg_emit_nl(g)
    
    // #include <stdio.h>
    cg_emit_char(g, 35)
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 99)
    cg_emit_char(g, 108) cg_emit_char(g, 117) cg_emit_char(g, 100)
    cg_emit_char(g, 101) cg_emit_char(g, 32) cg_emit_char(g, 60)
    cg_emit_char(g, 115) cg_emit_char(g, 116) cg_emit_char(g, 100)
    cg_emit_char(g, 105) cg_emit_char(g, 111) cg_emit_char(g, 46)
    cg_emit_char(g, 104) cg_emit_char(g, 62)
    cg_emit_nl(g)
    
    // #include <stdlib.h>
    cg_emit_char(g, 35)
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 99)
    cg_emit_char(g, 108) cg_emit_char(g, 117) cg_emit_char(g, 100)
    cg_emit_char(g, 101) cg_emit_char(g, 32) cg_emit_char(g, 60)
    cg_emit_char(g, 115) cg_emit_char(g, 116) cg_emit_char(g, 100)
    cg_emit_char(g, 108) cg_emit_char(g, 105) cg_emit_char(g, 98)
    cg_emit_char(g, 46) cg_emit_char(g, 104) cg_emit_char(g, 62)
    cg_emit_nl(g)
    
    // #include <string.h>
    cg_emit_char(g, 35)
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 99)
    cg_emit_char(g, 108) cg_emit_char(g, 117) cg_emit_char(g, 100)
    cg_emit_char(g, 101) cg_emit_char(g, 32) cg_emit_char(g, 60)
    cg_emit_char(g, 115) cg_emit_char(g, 116) cg_emit_char(g, 114)
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 103)
    cg_emit_char(g, 46) cg_emit_char(g, 104) cg_emit_char(g, 62)
    cg_emit_nl(g)
    cg_emit_nl(g)
    
    // Runtime macros
    cg_emit_runtime_macros(g)
    cg_emit_nl(g)
}

func cg_emit_runtime_macros(g: Int) {
    // #define print(x) printf("%lld\n",(long long)(x))
    cg_emit_char(g, 35) // #
    cg_emit_char(g, 100) cg_emit_char(g, 101) cg_emit_char(g, 102) // def
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 101) // ine
    cg_emit_space(g)
    cg_emit_char(g, 112) cg_emit_char(g, 114) cg_emit_char(g, 105) // pri
    cg_emit_char(g, 110) cg_emit_char(g, 116) // nt
    cg_emit_char(g, 40) cg_emit_char(g, 120) cg_emit_char(g, 41) // (x)
    cg_emit_space(g)
    cg_emit_char(g, 112) cg_emit_char(g, 114) cg_emit_char(g, 105) // pri
    cg_emit_char(g, 110) cg_emit_char(g, 116) cg_emit_char(g, 102) // ntf
    cg_emit_char(g, 40) cg_emit_char(g, 34) cg_emit_char(g, 37) // ("%
    cg_emit_char(g, 108) cg_emit_char(g, 108) cg_emit_char(g, 100) // lld
    cg_emit_char(g, 92) cg_emit_char(g, 110) cg_emit_char(g, 34) // \n"
    cg_emit_char(g, 44) // ,
    cg_emit_char(g, 40) cg_emit_char(g, 108) cg_emit_char(g, 111) // (lo
    cg_emit_char(g, 110) cg_emit_char(g, 103) cg_emit_space(g) // ng 
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
    cg_emit_char(g, 103) cg_emit_char(g, 41) // g)
    cg_emit_char(g, 40) cg_emit_char(g, 120) cg_emit_char(g, 41) // (x)
    cg_emit_char(g, 41) // )
    cg_emit_nl(g)
    
    // ae_malloc, ae_load/store macros
    // #define ae_malloc(n) ((long long)malloc(n))
    cg_emit_char(g, 35) // #
    cg_emit_char(g, 100) cg_emit_char(g, 101) cg_emit_char(g, 102)
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 101)
    cg_emit_space(g)
    cg_emit_char(g, 97) cg_emit_char(g, 101) cg_emit_char(g, 95) // ae_
    cg_emit_char(g, 109) cg_emit_char(g, 97) cg_emit_char(g, 108) // mal
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 99) // loc
    cg_emit_char(g, 40) cg_emit_char(g, 110) cg_emit_char(g, 41) // (n)
    cg_emit_space(g)
    cg_emit_char(g, 40) cg_emit_char(g, 40) // ((
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
    cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
    cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
    cg_emit_char(g, 41) // )
    cg_emit_char(g, 109) cg_emit_char(g, 97) cg_emit_char(g, 108) // mal
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 99) // loc
    cg_emit_char(g, 40) cg_emit_char(g, 110) cg_emit_char(g, 41) // (n)
    cg_emit_char(g, 41) // )
    cg_emit_nl(g)
}

// ============================================================================
// EXPRESSION CODEGEN
// ============================================================================

func cg_emit_expr(g: Int, node: Int) {
    if node == 0 { return }
    
    let kind = ast_kind(node)
    
    // Integer literal
    if kind == AST_INT_LIT {
        cg_emit_int(g, ast_data1(node))
        return
    }
    
    // Identifier
    if kind == AST_IDENT {
        cg_emit_cstr(g, ast_data1(node))
        return
    }
    
    // Binary expression
    if kind == AST_BINARY {
        cg_emit_char(g, 40) // (
        cg_emit_expr(g, ast_data2(node))
        cg_emit_space(g)
        
        let op = ast_data1(node)
        if op == TOK_PLUS { cg_emit_char(g, 43) }
        if op == TOK_MINUS { cg_emit_char(g, 45) }
        if op == TOK_STAR { cg_emit_char(g, 42) }
        if op == TOK_SLASH { cg_emit_char(g, 47) }
        if op == TOK_EQEQ { cg_emit_char(g, 61) cg_emit_char(g, 61) }
        if op == TOK_NE { cg_emit_char(g, 33) cg_emit_char(g, 61) }
        if op == TOK_LT { cg_emit_char(g, 60) }
        if op == TOK_LE { cg_emit_char(g, 60) cg_emit_char(g, 61) }
        if op == TOK_GT { cg_emit_char(g, 62) }
        if op == TOK_GE { cg_emit_char(g, 62) cg_emit_char(g, 61) }
        if op == TOK_AMP { cg_emit_char(g, 38) cg_emit_char(g, 38) }
        if op == TOK_PIPE { cg_emit_char(g, 124) cg_emit_char(g, 124) }
        
        cg_emit_space(g)
        cg_emit_expr(g, ast_data3(node))
        cg_emit_char(g, 41) // )
        return
    }
    
    // Unary expression
    if kind == AST_UNARY {
        let op = ast_data1(node)
        if op == TOK_MINUS { cg_emit_char(g, 45) }
        if op == TOK_BANG { cg_emit_char(g, 33) }
        if op == TOK_AMP { cg_emit_char(g, 38) }
        if op == TOK_STAR { cg_emit_char(g, 42) }
        cg_emit_expr(g, ast_data2(node))
        return
    }
    
    // Function call
    if kind == AST_CALL {
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 40) // (
        
        let args = ast_data2(node)
        let count = vec_len(args)
        let i = 0
        while i < count {
            if i > 0 {
                cg_emit_char(g, 44) // ,
                cg_emit_space(g)
            }
            cg_emit_expr(g, vec_get(args, i))
            i = i + 1
        }
        
        cg_emit_char(g, 41) // )
        return
    }
    
    // Field access
    if kind == AST_FIELD {
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 46) // .
        cg_emit_cstr(g, ast_data2(node))
        return
    }
    
    // Index access
    if kind == AST_INDEX {
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 91) // [
        cg_emit_expr(g, ast_data2(node))
        cg_emit_char(g, 93) // ]
        return
    }
    
    // Struct literal
    if kind == AST_STRUCT_LIT {
        cg_emit_char(g, 40) // (
        cg_emit_cstr(g, ast_data1(node))
        cg_emit_char(g, 41) // )
        cg_emit_char(g, 123) // {
        
        let fields = ast_data2(node)
        let count = vec_len(fields)
        let i = 0
        while i < count {
            if i > 0 { cg_emit_char(g, 44) cg_emit_space(g) }
            let pair = vec_get(fields, i)
            cg_emit_char(g, 46) // .
            cg_emit_cstr(g, ae_load64(pair))
            cg_emit_char(g, 61) // =
            cg_emit_expr(g, ae_load64(pair + 8))
            i = i + 1
        }
        
        cg_emit_char(g, 125) // }
        return
    }
    
    // Array literal
    if kind == AST_ARRAY_LIT {
        cg_emit_char(g, 40) // (
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
        cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
        cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
        cg_emit_char(g, 91) cg_emit_char(g, 93) // []
        cg_emit_char(g, 41) // )
        cg_emit_char(g, 123) // {
        
        let elems = ast_data1(node)
        let count = vec_len(elems)
        let i = 0
        while i < count {
            if i > 0 { cg_emit_char(g, 44) cg_emit_space(g) }
            cg_emit_expr(g, vec_get(elems, i))
            i = i + 1
        }
        
        cg_emit_char(g, 125) // }
        return
    }
}

// ============================================================================
// STATEMENT CODEGEN
// ============================================================================

func cg_emit_stmt(g: Int, node: Int) {
    if node == 0 { return }
    
    let kind = ast_kind(node)
    
    // Let statement
    if kind == AST_LET {
        cg_emit_indent(g)
        // long long varname = expr;
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
        cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
        cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
        cg_emit_space(g)
        cg_emit_cstr(g, ast_data1(node))
        cg_emit_space(g)
        cg_emit_char(g, 61) // =
        cg_emit_space(g)
        cg_emit_expr(g, ast_data3(node))
        cg_emit_char(g, 59) // ;
        cg_emit_nl(g)
        return
    }
    
    // Assignment
    if kind == AST_ASSIGN {
        cg_emit_indent(g)
        cg_emit_expr(g, ast_data1(node))
        cg_emit_space(g)
        cg_emit_char(g, 61) // =
        cg_emit_space(g)
        cg_emit_expr(g, ast_data2(node))
        cg_emit_char(g, 59) // ;
        cg_emit_nl(g)
        return
    }
    
    // Return statement
    if kind == AST_RETURN {
        cg_emit_indent(g)
        cg_emit_char(g, 114) cg_emit_char(g, 101) cg_emit_char(g, 116) // ret
        cg_emit_char(g, 117) cg_emit_char(g, 114) cg_emit_char(g, 110) // urn
        cg_emit_space(g)
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 59) // ;
        cg_emit_nl(g)
        return
    }
    
    // If statement
    if kind == AST_IF {
        cg_emit_indent(g)
        cg_emit_char(g, 105) cg_emit_char(g, 102) // if
        cg_emit_space(g)
        cg_emit_char(g, 40) // (
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 41) // )
        cg_emit_space(g)
        cg_emit_char(g, 123) // {
        cg_emit_nl(g)
        cg_set_indent(g, cg_indent(g) + 1)
        cg_emit_block_stmts(g, ast_data2(node))
        cg_set_indent(g, cg_indent(g) - 1)
        cg_emit_indent(g)
        cg_emit_char(g, 125) // }
        
        let else_blk = ast_data3(node)
        if else_blk != 0 {
            cg_emit_space(g)
            cg_emit_char(g, 101) cg_emit_char(g, 108) cg_emit_char(g, 115) // els
            cg_emit_char(g, 101) // e
            cg_emit_space(g)
            cg_emit_char(g, 123) // {
            cg_emit_nl(g)
            cg_set_indent(g, cg_indent(g) + 1)
            cg_emit_block_stmts(g, else_blk)
            cg_set_indent(g, cg_indent(g) - 1)
            cg_emit_indent(g)
            cg_emit_char(g, 125) // }
        }
        cg_emit_nl(g)
        return
    }
    
    // While statement
    if kind == AST_WHILE {
        cg_emit_indent(g)
        cg_emit_char(g, 119) cg_emit_char(g, 104) cg_emit_char(g, 105) // whi
        cg_emit_char(g, 108) cg_emit_char(g, 101) // le
        cg_emit_space(g)
        cg_emit_char(g, 40) // (
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 41) // )
        cg_emit_space(g)
        cg_emit_char(g, 123) // {
        cg_emit_nl(g)
        cg_set_indent(g, cg_indent(g) + 1)
        cg_emit_block_stmts(g, ast_data2(node))
        cg_set_indent(g, cg_indent(g) - 1)
        cg_emit_indent(g)
        cg_emit_char(g, 125) // }
        cg_emit_nl(g)
        return
    }
    
    // For loop
    if kind == AST_FOR {
        cg_emit_indent(g)
        // for (long long i = start; i < end; i++) {
        cg_emit_char(g, 102) cg_emit_char(g, 111) cg_emit_char(g, 114) // for
        cg_emit_space(g)
        cg_emit_char(g, 40) // (
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
        cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
        cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
        cg_emit_space(g)
        cg_emit_cstr(g, ast_data1(node))
        cg_emit_space(g)
        cg_emit_char(g, 61) // =
        cg_emit_space(g)
        cg_emit_expr(g, ast_data2(node))
        cg_emit_char(g, 59) // ;
        cg_emit_space(g)
        cg_emit_cstr(g, ast_data1(node))
        cg_emit_space(g)
        cg_emit_char(g, 60) // <
        cg_emit_space(g)
        cg_emit_expr(g, ast_data3(node))
        cg_emit_char(g, 59) // ;
        cg_emit_space(g)
        cg_emit_cstr(g, ast_data1(node))
        cg_emit_char(g, 43) cg_emit_char(g, 43) // ++
        cg_emit_char(g, 41) // )
        cg_emit_space(g)
        cg_emit_char(g, 123) // {
        cg_emit_nl(g)
        cg_set_indent(g, cg_indent(g) + 1)
        cg_emit_block_stmts(g, ast_data4(node))
        cg_set_indent(g, cg_indent(g) - 1)
        cg_emit_indent(g)
        cg_emit_char(g, 125) // }
        cg_emit_nl(g)
        return
    }
    
    // Match expression
    if kind == AST_MATCH {
        cg_emit_indent(g)
        // switch (scrutinee) { case X: ...; break; }
        cg_emit_char(g, 115) cg_emit_char(g, 119) cg_emit_char(g, 105) // swi
        cg_emit_char(g, 116) cg_emit_char(g, 99) cg_emit_char(g, 104) // tch
        cg_emit_space(g)
        cg_emit_char(g, 40) // (
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 41) // )
        cg_emit_space(g)
        cg_emit_char(g, 123) // {
        cg_emit_nl(g)
        
        let arms = ast_data2(node)
        let count = vec_len(arms)
        let i = 0
        while i < count {
            let arm = vec_get(arms, i)
            cg_emit_indent(g)
            cg_emit_char(g, 99) cg_emit_char(g, 97) cg_emit_char(g, 115) // cas
            cg_emit_char(g, 101) // e
            cg_emit_space(g)
            cg_emit_expr(g, ae_load64(arm))
            cg_emit_char(g, 58) // :
            cg_emit_space(g)
            cg_emit_expr(g, ae_load64(arm + 8))
            cg_emit_char(g, 59) // ;
            cg_emit_space(g)
            cg_emit_char(g, 98) cg_emit_char(g, 114) cg_emit_char(g, 101) // bre
            cg_emit_char(g, 97) cg_emit_char(g, 107) // ak
            cg_emit_char(g, 59) // ;
            cg_emit_nl(g)
            i = i + 1
        }
        
        cg_emit_indent(g)
        cg_emit_char(g, 125) // }
        cg_emit_nl(g)
        return
    }
    
    // Expression statement
    if kind == AST_EXPR_STMT {
        cg_emit_indent(g)
        cg_emit_expr(g, ast_data1(node))
        cg_emit_char(g, 59) // ;
        cg_emit_nl(g)
        return
    }
    
    // Block
    if kind == AST_BLOCK {
        cg_emit_block_stmts(g, node)
        return
    }
}

func cg_emit_block_stmts(g: Int, block: Int) {
    if block == 0 { return }
    let stmts = ast_data1(block)
    if stmts == 0 { return }
    
    let count = vec_len(stmts)
    let i = 0
    while i < count {
        cg_emit_stmt(g, vec_get(stmts, i))
        i = i + 1
    }
}

// ============================================================================
// DECLARATION CODEGEN
// ============================================================================

func cg_emit_struct(g: Int, node: Int) {
    let name = ast_data1(node)
    let fields = ast_data2(node)
    
    // typedef struct { ... } Name;
    cg_emit_char(g, 116) cg_emit_char(g, 121) cg_emit_char(g, 112) // typ
    cg_emit_char(g, 101) cg_emit_char(g, 100) cg_emit_char(g, 101) // ede
    cg_emit_char(g, 102) // f
    cg_emit_space(g)
    cg_emit_char(g, 115) cg_emit_char(g, 116) cg_emit_char(g, 114) // str
    cg_emit_char(g, 117) cg_emit_char(g, 99) cg_emit_char(g, 116) // uct
    cg_emit_space(g)
    cg_emit_char(g, 123) // {
    cg_emit_nl(g)
    
    let count = vec_len(fields)
    let i = 0
    while i < count {
        let field = vec_get(fields, i)
        cg_emit_indent(g)
        cg_emit_space(g) cg_emit_space(g) cg_emit_space(g) cg_emit_space(g)
        cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
        cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
        cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
        cg_emit_space(g)
        cg_emit_cstr(g, ae_load64(field))
        cg_emit_char(g, 59) // ;
        cg_emit_nl(g)
        i = i + 1
    }
    
    cg_emit_char(g, 125) // }
    cg_emit_space(g)
    cg_emit_cstr(g, name)
    cg_emit_char(g, 59) // ;
    cg_emit_nl(g)
    cg_emit_nl(g)
}

func cg_emit_func(g: Int, node: Int) {
    let name = ast_data1(node)
    let params = ast_data2(node)
    let body = ast_data4(node)
    
    // long long funcname(params) {
    cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
    cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
    cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
    cg_emit_space(g)
    cg_emit_cstr(g, name)
    cg_emit_char(g, 40) // (
    
    let count = vec_len(params)
    if count == 0 {
        cg_emit_char(g, 118) cg_emit_char(g, 111) cg_emit_char(g, 105) // voi
        cg_emit_char(g, 100) // d
    } else {
        let i = 0
        while i < count {
            if i > 0 { cg_emit_char(g, 44) cg_emit_space(g) }
            let param = vec_get(params, i)
            cg_emit_char(g, 108) cg_emit_char(g, 111) cg_emit_char(g, 110) // lon
            cg_emit_char(g, 103) cg_emit_space(g) cg_emit_char(g, 108) // g l
            cg_emit_char(g, 111) cg_emit_char(g, 110) cg_emit_char(g, 103) // ong
            cg_emit_space(g)
            cg_emit_cstr(g, ae_load64(param))
            i = i + 1
        }
    }
    
    cg_emit_char(g, 41) // )
    cg_emit_space(g)
    cg_emit_char(g, 123) // {
    cg_emit_nl(g)
    cg_set_indent(g, 1)
    cg_emit_block_stmts(g, body)
    cg_emit_char(g, 125) // }
    cg_emit_nl(g)
    cg_emit_nl(g)
    cg_set_indent(g, 0)
}

func cg_emit_const(g: Int, node: Int) {
    // #define NAME value
    cg_emit_char(g, 35) // #
    cg_emit_char(g, 100) cg_emit_char(g, 101) cg_emit_char(g, 102) // def
    cg_emit_char(g, 105) cg_emit_char(g, 110) cg_emit_char(g, 101) // ine
    cg_emit_space(g)
    cg_emit_cstr(g, ast_data1(node))
    cg_emit_space(g)
    cg_emit_expr(g, ast_data3(node))
    cg_emit_nl(g)
}

// ============================================================================
// MODULE CODEGEN
// ============================================================================

func cg_emit_module(g: Int, node: Int) {
    cg_emit_header(g)
    
    let decls = ast_data1(node)
    let count = vec_len(decls)
    
    // Pass 1: emit consts
    let i = 0
    while i < count {
        let decl = vec_get(decls, i)
        if ast_kind(decl) == AST_CONST {
            cg_emit_const(g, decl)
        }
        i = i + 1
    }
    cg_emit_nl(g)
    
    // Pass 2: emit structs
    i = 0
    while i < count {
        let decl = vec_get(decls, i)
        if ast_kind(decl) == AST_STRUCT {
            cg_emit_struct(g, decl)
        }
        i = i + 1
    }
    
    // Pass 3: emit functions
    i = 0
    while i < count {
        let decl = vec_get(decls, i)
        if ast_kind(decl) == AST_FUNC {
            cg_emit_func(g, decl)
        }
        i = i + 1
    }
}

func generate(ast: Int) -> Int {
    let g = codegen_new()
    cg_emit_module(g, ast)
    cg_emit_char(g, 0)
    cg_out(g)
}
