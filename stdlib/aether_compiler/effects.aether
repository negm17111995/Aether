// AETHER SELF-HOSTED COMPILER - EFFECTS SYSTEM
// Simplified Algebraic Effects

import std

// ============================================================================
// EFFECT KINDS  
// ============================================================================

const EFF_NONE: Int = 0
const EFF_IO: Int = 1
const EFF_THROW: Int = 3

// ============================================================================
// EFFECT SET
// ============================================================================

func effect_set_new() -> Int { vec_new() }

func effect_set_add(set: Int, kind: Int) {
    let i = 0
    while i < vec_len(set) {
        if vec_get(set, i) == kind { return }
        i = i + 1
    }
    vec_push(set, kind)
}

func str_has_prefix_eff(s: Int, c: Int) -> Int {
    if s == 0 { return 0 }
    let first = ae_load8(s)
    if first == c { return 1 }
    0
}

// ============================================================================
// EFFECT INFERENCE
// ============================================================================

func infer_effects_expr_eff(set: Int, node: Int) {
    if node == 0 { return }
    let kind = ast_kind(node)
    
    if kind == AST_CALL {
        let func_expr = ast_data1(node)
        if ast_kind(func_expr) == AST_IDENT {
            let name = ast_data1(func_expr)
            // 'p' = 112 for print
            if str_has_prefix_eff(name, 112) == 1 { effect_set_add(set, EFF_IO) }
        }
        let args = ast_data2(node)
        let i = 0
        while i < vec_len(args) {
            infer_effects_expr_eff(set, vec_get(args, i))
            i = i + 1
        }
        return
    }
    
    if kind == AST_BINARY {
        infer_effects_expr_eff(set, ast_data2(node))
        infer_effects_expr_eff(set, ast_data3(node))
        return
    }
}

func infer_effects_stmt_eff(set: Int, node: Int) {
    if node == 0 { return }
    let kind = ast_kind(node)
    if kind == AST_LET { infer_effects_expr_eff(set, ast_data3(node)) return }
    if kind == AST_RETURN { infer_effects_expr_eff(set, ast_data1(node)) return }
    if kind == AST_EXPR_STMT { infer_effects_expr_eff(set, ast_data1(node)) return }
}

func infer_effects_block_eff(set: Int, block: Int) {
    if block == 0 { return }
    let stmts = ast_data1(block)
    if stmts == 0 { return }
    let i = 0
    while i < vec_len(stmts) {
        infer_effects_stmt_eff(set, vec_get(stmts, i))
        i = i + 1
    }
}

func infer_func_effects_eff(node: Int) -> Int {
    let set = effect_set_new()
    infer_effects_block_eff(set, ast_data4(node))
    set
}

func verify_effects(module: Int) -> Int {
    let decls = ast_data1(module)
    let i = 0
    while i < vec_len(decls) {
        let d = vec_get(decls, i)
        if ast_kind(d) == AST_FUNC { infer_func_effects_eff(d) }
        i = i + 1
    }
    1
}
