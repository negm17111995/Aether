// AETHER SELF-HOSTED COMPILER - TYPE CHECKER
// Simplified version with correct function ordering

import std

// ============================================================================
// TYPE KINDS
// ============================================================================

const TYPE_INT: Int = 1
const TYPE_BOOL: Int = 3  
const TYPE_VOID: Int = 5
const TYPE_STRUCT: Int = 6
const TYPE_FUNC: Int = 9

// ============================================================================
// TYPE REPRESENTATION
// ============================================================================

func type_new(kind: Int, name: Int) -> Int {
    let t = ae_malloc(24)
    ae_store64(t, kind)
    ae_store64(t + 8, name)
    ae_store64(t + 16, 0)
    t
}

func type_kind(t: Int) -> Int { ae_load64(t) }
func type_name(t: Int) -> Int { ae_load64(t + 8) }

func type_int() -> Int { type_new(TYPE_INT, 0) }
func type_bool() -> Int { type_new(TYPE_BOOL, 0) }
func type_void() -> Int { type_new(TYPE_VOID, 0) }

// ============================================================================
// STRING COMPARISON (moved before type_env_lookup)
// ============================================================================

func str_eq_tc(a: Int, b: Int) -> Int {
    if a == 0 || b == 0 { if a == b { return 1 } return 0 }
    let i = 0
    while 1 == 1 {
        let ca = ae_load8(a + i)
        let cb = ae_load8(b + i)
        if ca != cb { return 0 }
        if ca == 0 { return 1 }
        i = i + 1
    }
    0
}

// ============================================================================
// TYPE ENVIRONMENT
// ============================================================================

func type_env_new(parent: Int) -> Int {
    let env = ae_malloc(16)
    ae_store64(env, vec_new())
    ae_store64(env + 8, parent)
    env
}

func type_env_vars(env: Int) -> Int { ae_load64(env) }
func type_env_parent(env: Int) -> Int { ae_load64(env + 8) }

func type_env_add(env: Int, name: Int, typ: Int) {
    let binding = ae_malloc(16)
    ae_store64(binding, name)
    ae_store64(binding + 8, typ)
    vec_push(type_env_vars(env), binding)
}

func type_env_lookup(env: Int, name: Int) -> Int {
    if env == 0 { return 0 }
    let vars = type_env_vars(env)
    let i = 0
    while i < vec_len(vars) {
        let b = vec_get(vars, i)
        if str_eq_tc(ae_load64(b), name) == 1 { return ae_load64(b + 8) }
        i = i + 1
    }
    type_env_lookup(type_env_parent(env), name)
}

// ============================================================================
// TYPE INFERENCE
// ============================================================================

func infer_type(env: Int, node: Int) -> Int {
    if node == 0 { return type_void() }
    let kind = ast_kind(node)
    if kind == AST_INT_LIT { return type_int() }
    if kind == AST_IDENT { 
        let t = type_env_lookup(env, ast_data1(node))
        if t != 0 { return t }
        return type_int()
    }
    if kind == AST_BINARY {
        let op = ast_data1(node)
        if op == TOK_EQEQ { return type_bool() }
        if op == TOK_NE { return type_bool() }
        if op == TOK_LT { return type_bool() }
        if op == TOK_GT { return type_bool() }
        if op == TOK_AMP { return type_bool() }
        if op == TOK_PIPE { return type_bool() }
        return type_int()
    }
    type_int()
}

// ============================================================================
// CHECK STATEMENTS
// ============================================================================

func check_stmt_tc(env: Int, node: Int) -> Int {
    if node == 0 { return 1 }
    let kind = ast_kind(node)
    if kind == AST_LET {
        let inferred = infer_type(env, ast_data3(node))
        type_env_add(env, ast_data1(node), inferred)
    }
    1
}

func check_block_tc(env: Int, block: Int) -> Int {
    if block == 0 { return 1 }
    let block_env = type_env_new(env)
    let stmts = ast_data1(block)
    if stmts == 0 { return 1 }
    let i = 0
    while i < vec_len(stmts) {
        check_stmt_tc(block_env, vec_get(stmts, i))
        i = i + 1
    }
    1
}

func check_func_tc(env: Int, node: Int) -> Int {
    let func_env = type_env_new(env)
    let params = ast_data2(node)
    let i = 0
    while i < vec_len(params) {
        let p = vec_get(params, i)
        type_env_add(func_env, ae_load64(p), type_int())
        i = i + 1
    }
    check_block_tc(func_env, ast_data4(node))
}

func check_module(node: Int) -> Int {
    let env = type_env_new(0)
    let decls = ast_data1(node)
    let i = 0
    while i < vec_len(decls) {
        let d = vec_get(decls, i)
        if ast_kind(d) == AST_FUNC {
            let ft = type_new(TYPE_FUNC, ast_data1(d))
            type_env_add(env, ast_data1(d), ft)
        }
        i = i + 1
    }
    i = 0
    while i < vec_len(decls) {
        let d = vec_get(decls, i)
        if ast_kind(d) == AST_FUNC { check_func_tc(env, d) }
        i = i + 1
    }
    1
}
