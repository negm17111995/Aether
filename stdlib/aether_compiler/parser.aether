// AETHER SELF-HOSTED COMPILER - PARSER
// COMPLETE parser - no forward declarations

import std

// ============================================================================
// PARSER STATE
// ============================================================================

func parser_new(tokens: Int) -> Int {
    let p = ae_malloc(24)
    ae_store64(p, tokens)
    ae_store64(p + 8, 0)
    ae_store64(p + 16, vec_len(tokens))
    p
}

func parser_tokens(p: Int) -> Int { ae_load64(p) }
func parser_pos(p: Int) -> Int { ae_load64(p + 8) }
func parser_count(p: Int) -> Int { ae_load64(p + 16) }
func parser_set_pos(p: Int, pos: Int) { ae_store64(p + 8, pos) }

func parser_peek(p: Int) -> Int {
    let pos = parser_pos(p)
    if pos >= parser_count(p) { return 0 }
    vec_get(parser_tokens(p), pos)
}

func parser_advance(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_set_pos(p, parser_pos(p) + 1)
    tok
}

func parser_check(p: Int, typ: Int) -> Int {
    let tok = parser_peek(p)
    if tok == 0 { return 0 }
    if token_type(tok) == typ { return 1 }
    0
}

func parser_match(p: Int, typ: Int) -> Int {
    if parser_check(p, typ) == 1 { parser_advance(p) return 1 }
    0
}

func parser_expect(p: Int, typ: Int) -> Int {
    if parser_check(p, typ) == 1 { return parser_advance(p) }
    0
}

// ============================================================================
// PRECEDENCE
// ============================================================================

func get_prec(typ: Int) -> Int {
    if typ == TOK_PIPE { return 1 }
    if typ == TOK_AMP { return 2 }
    if typ == TOK_EQEQ { return 3 }
    if typ == TOK_NE { return 3 }
    if typ == TOK_LT { return 4 }
    if typ == TOK_GT { return 4 }
    if typ == TOK_PLUS { return 5 }
    if typ == TOK_MINUS { return 5 }
    if typ == TOK_STAR { return 6 }
    if typ == TOK_SLASH { return 6 }
    0
}

func parse_type(p: Int) -> Int {
    let tok = parser_expect(p, TOK_ID)
    if tok != 0 { return token_value(tok) }
    0
}

// ============================================================================
// SIMPLE ATOM (no recursive expressions)
// ============================================================================

func parse_simple_atom(p: Int) -> Int {
    let tok = parser_peek(p)
    if tok == 0 { return 0 }
    let typ = token_type(tok)
    let line = token_line(tok)
    let col = token_col(tok)
    
    if typ == TOK_INT { parser_advance(p) return ast_int(token_value(tok), line, col) }
    if typ == TOK_ID { parser_advance(p) return ast_ident(token_value(tok), line, col) }
    if typ == TOK_TRUE { parser_advance(p) return ast_int(1, line, col) }
    if typ == TOK_FALSE { parser_advance(p) return ast_int(0, line, col) }
    0
}

func parse_simple_unary(p: Int) -> Int {
    let tok = parser_peek(p)
    if tok == 0 { return 0 }
    let typ = token_type(tok)
    if typ == TOK_MINUS {
        parser_advance(p)
        return ast_unary(TOK_MINUS, parse_simple_unary(p), token_line(tok), token_col(tok))
    }
    if typ == TOK_BANG {
        parser_advance(p)
        return ast_unary(TOK_BANG, parse_simple_unary(p), token_line(tok), token_col(tok))
    }
    parse_simple_atom(p)
}

func parse_simple_binary(p: Int, min_prec: Int) -> Int {
    let left = parse_simple_unary(p)
    if left == 0 { return 0 }
    
    let done = 0
    while done == 0 {
        let tok = parser_peek(p)
        if tok == 0 { done = 1 }
        else {
            let prec = get_prec(token_type(tok))
            if prec < min_prec { done = 1 }
            else {
                parser_advance(p)
                let right = parse_simple_binary(p, prec + 1)
                left = ast_binary(token_type(tok), left, right, ast_line(left), ast_col(left))
            }
        }
    }
    left
}

func parse_simple_expr(p: Int) -> Int {
    parse_simple_binary(p, 1)
}

// ============================================================================
// FULL EXPRESSION PARSING (uses simple for nested)
// ============================================================================

func parse_full_atom(p: Int) -> Int {
    let tok = parser_peek(p)
    if tok == 0 { return 0 }
    let typ = token_type(tok)
    let line = token_line(tok)
    let col = token_col(tok)
    
    if typ == TOK_INT { parser_advance(p) return ast_int(token_value(tok), line, col) }
    if typ == TOK_ID { parser_advance(p) return ast_ident(token_value(tok), line, col) }
    if typ == TOK_TRUE { parser_advance(p) return ast_int(1, line, col) }
    if typ == TOK_FALSE { parser_advance(p) return ast_int(0, line, col) }
    
    // @ builtin
    if typ == TOK_AT {
        parser_advance(p)
        let name_tok = parser_expect(p, TOK_ID)
        let name = 0
        if name_tok != 0 { name = token_value(name_tok) }
        parser_expect(p, TOK_LPAREN)
        let arg = 0
        if parser_check(p, TOK_RPAREN) == 0 { arg = parse_simple_expr(p) }
        parser_expect(p, TOK_RPAREN)
        let call_node = ast_new(AST_CALL, line, col)
        let ident = ast_ident(name, line, col)
        ast_set_data1(call_node, ident)
        ast_set_data2(call_node, vec_new())
        if arg != 0 { vec_push(ast_data2(call_node), arg) }
        return call_node
    }
    
    // Array literal [a, b, c]
    if typ == TOK_LBRACK {
        parser_advance(p)
        let elements = vec_new()
        if parser_check(p, TOK_RBRACK) == 0 {
            vec_push(elements, parse_simple_expr(p))
            while parser_match(p, TOK_COMMA) == 1 {
                vec_push(elements, parse_simple_expr(p))
            }
        }
        parser_expect(p, TOK_RBRACK)
        let arr = ast_new(AST_ARRAY_LIT, line, col)
        ast_set_data1(arr, elements)
        return arr
    }
    
    0
}

func parse_full_postfix(p: Int) -> Int {
    let expr = parse_full_atom(p)
    if expr == 0 { return 0 }
    
    let done = 0
    while done == 0 {
        // Function call
        if parser_check(p, TOK_LPAREN) == 1 {
            parser_advance(p)
            let args = vec_new()
            if parser_check(p, TOK_RPAREN) == 0 {
                vec_push(args, parse_simple_expr(p))
                while parser_match(p, TOK_COMMA) == 1 {
                    vec_push(args, parse_simple_expr(p))
                }
            }
            parser_expect(p, TOK_RPAREN)
            expr = ast_call(expr, args, ast_line(expr), ast_col(expr))
        } else {
            if parser_check(p, TOK_DOT) == 1 {
                parser_advance(p)
                let f = parser_expect(p, TOK_ID)
                if f != 0 { expr = ast_field(expr, token_value(f), ast_line(expr), ast_col(expr)) }
            } else {
                if parser_check(p, TOK_LBRACK) == 1 {
                    parser_advance(p)
                    let index = parse_simple_expr(p)
                    parser_expect(p, TOK_RBRACK)
                    let idx = ast_new(AST_INDEX, ast_line(expr), ast_col(expr))
                    ast_set_data1(idx, expr)
                    ast_set_data2(idx, index)
                    expr = idx
                } else {
                    done = 1
                }
            }
        }
    }
    expr
}

func parse_full_unary(p: Int) -> Int {
    let tok = parser_peek(p)
    if tok == 0 { return 0 }
    let typ = token_type(tok)
    if typ == TOK_MINUS {
        parser_advance(p)
        return ast_unary(TOK_MINUS, parse_full_unary(p), token_line(tok), token_col(tok))
    }
    if typ == TOK_BANG {
        parser_advance(p)
        return ast_unary(TOK_BANG, parse_full_unary(p), token_line(tok), token_col(tok))
    }
    if typ == TOK_AMP {
        parser_advance(p)
        let inner = parse_full_unary(p)
        let ref = ast_new(AST_REF, token_line(tok), token_col(tok))
        ast_set_data1(ref, inner)
        return ref
    }
    parse_full_postfix(p)
}

func parse_full_binary(p: Int, min_prec: Int) -> Int {
    let left = parse_full_unary(p)
    if left == 0 { return 0 }
    
    let done = 0
    while done == 0 {
        let tok = parser_peek(p)
        if tok == 0 { done = 1 }
        else {
            let prec = get_prec(token_type(tok))
            if prec < min_prec { done = 1 }
            else {
                parser_advance(p)
                let right = parse_full_binary(p, prec + 1)
                left = ast_binary(token_type(tok), left, right, ast_line(left), ast_col(left))
            }
        }
    }
    left
}

func parse_expr(p: Int) -> Int {
    parse_full_binary(p, 1)
}

// ============================================================================
// STATEMENTS
// ============================================================================

func parse_stmt(p: Int) -> Int {
    let tok = parser_peek(p)
    if tok == 0 { return 0 }
    let typ = token_type(tok)
    let line = token_line(tok)
    let col = token_col(tok)
    
    // let
    if typ == TOK_LET {
        parser_advance(p)
        let is_mut = 0
        if parser_match(p, TOK_MUT) == 1 { is_mut = 1 }
        let name_tok = parser_expect(p, TOK_ID)
        let name = 0
        if name_tok != 0 { name = token_value(name_tok) }
        let var_type = 0
        if parser_match(p, TOK_COLON) == 1 { var_type = parse_type(p) }
        parser_expect(p, TOK_EQ)
        let init = parse_expr(p)
        return ast_let(name, var_type, init, is_mut, line, col)
    }
    
    // return
    if typ == TOK_RETURN {
        parser_advance(p)
        let ret_expr = 0
        if parser_check(p, TOK_RBRACE) == 0 { ret_expr = parse_expr(p) }
        return ast_return(ret_expr, line, col)
    }
    
    // send
    if typ == TOK_SEND {
        parser_advance(p)
        let target = parse_expr(p)
        parser_expect(p, TOK_ARROW)
        let msg = parse_expr(p)
        let send = ast_new(AST_SEND_EXPR, line, col)
        ast_set_data1(send, target)
        ast_set_data2(send, msg)
        return send
    }
    
    // perform
    if typ == TOK_PERFORM {
        parser_advance(p)
        let eff = parser_expect(p, TOK_ID)
        parser_expect(p, TOK_DOT)
        let op = parser_expect(p, TOK_ID)
        parser_expect(p, TOK_LPAREN)
        let arg = 0
        if parser_check(p, TOK_RPAREN) == 0 { arg = parse_expr(p) }
        parser_expect(p, TOK_RPAREN)
        let perf = ast_new(AST_PERFORM, line, col)
        ast_set_data1(perf, token_value(eff))
        ast_set_data2(perf, token_value(op))
        ast_set_data3(perf, arg)
        return perf
    }
    
    // resume
    if typ == TOK_RESUME {
        parser_advance(p)
        let val = parse_expr(p)
        let res = ast_new(AST_RESUME, line, col)
        ast_set_data1(res, val)
        return res
    }
    
    // Expression or assignment
    let expr = parse_expr(p)
    if expr != 0 {
        if parser_check(p, TOK_EQ) == 1 {
            parser_advance(p)
            let value = parse_expr(p)
            let assign = ast_new(AST_ASSIGN, line, col)
            ast_set_data1(assign, expr)
            ast_set_data2(assign, value)
            return assign
        }
        let stmt = ast_new(AST_EXPR_STMT, line, col)
        ast_set_data1(stmt, expr)
        return stmt
    }
    0
}

// ============================================================================
// BLOCK PARSING (iterative - no mutual recursion)
// ============================================================================

func parse_block(p: Int) -> Int {
    let tok = parser_peek(p)
    let line = 0
    let col = 0
    if tok != 0 { line = token_line(tok) col = token_col(tok) }
    
    parser_expect(p, TOK_LBRACE)
    let stmts = vec_new()
    
    while parser_check(p, TOK_RBRACE) == 0 {
        if parser_check(p, TOK_EOF) == 1 { return ast_block(stmts, line, col) }
        
        let cur = parser_peek(p)
        if cur == 0 { return ast_block(stmts, line, col) }
        let cur_typ = token_type(cur)
        
        if cur_typ == TOK_IF {
            parser_advance(p)
            let cond = parse_expr(p)
            let then_blk = parse_block(p)
            let else_blk = 0
            if parser_match(p, TOK_ELSE) == 1 { else_blk = parse_block(p) }
            vec_push(stmts, ast_if(cond, then_blk, else_blk, token_line(cur), token_col(cur)))
        } else {
            if cur_typ == TOK_WHILE {
                parser_advance(p)
                let cond = parse_expr(p)
                let body = parse_block(p)
                vec_push(stmts, ast_while(cond, body, token_line(cur), token_col(cur)))
            } else {
                if cur_typ == TOK_FOR {
                    parser_advance(p)
                    let var_tok = parser_expect(p, TOK_ID)
                    parser_expect(p, TOK_IN)
                    let start = parse_expr(p)
                    parser_expect(p, TOK_DOT)
                    parser_expect(p, TOK_DOT)
                    let end = parse_expr(p)
                    let body = parse_block(p)
                    let for_s = ast_new(AST_FOR, token_line(cur), token_col(cur))
                    ast_set_data1(for_s, token_value(var_tok))
                    ast_set_data2(for_s, start)
                    ast_set_data3(for_s, end)
                    ast_set_data4(for_s, body)
                    vec_push(stmts, for_s)
                } else {
                    if cur_typ == TOK_MATCH {
                        parser_advance(p)
                        let scrutinee = parse_expr(p)
                        parser_expect(p, TOK_LBRACE)
                        let arms = vec_new()
                        while parser_check(p, TOK_RBRACE) == 0 {
                            let pat = parse_expr(p)
                            parser_expect(p, TOK_DARROW)
                            let arm_body = parse_expr(p)
                            let arm = ae_malloc(16)
                            ae_store64(arm, pat)
                            ae_store64(arm + 8, arm_body)
                            vec_push(arms, arm)
                            parser_match(p, TOK_COMMA)
                        }
                        parser_expect(p, TOK_RBRACE)
                        let match_s = ast_new(AST_MATCH, token_line(cur), token_col(cur))
                        ast_set_data1(match_s, scrutinee)
                        ast_set_data2(match_s, arms)
                        vec_push(stmts, match_s)
                    } else {
                        if cur_typ == TOK_TRY {
                            parser_advance(p)
                            let try_body = parse_block(p)
                            let handlers = vec_new()
                            while parser_match(p, TOK_HANDLE) == 1 {
                                let eff = parser_expect(p, TOK_ID)
                                parser_expect(p, TOK_LBRACE)
                                let ops = vec_new()
                                while parser_check(p, TOK_RBRACE) == 0 {
                                    let op = parser_expect(p, TOK_ID)
                                    parser_expect(p, TOK_LPAREN)
                                    let params = vec_new()
                                    if parser_check(p, TOK_RPAREN) == 0 {
                                        vec_push(params, parser_expect(p, TOK_ID))
                                        while parser_match(p, TOK_COMMA) == 1 {
                                            vec_push(params, parser_expect(p, TOK_ID))
                                        }
                                    }
                                    parser_expect(p, TOK_RPAREN)
                                    parser_expect(p, TOK_DARROW)
                                    let hbody = parse_expr(p)
                                    let h = ae_malloc(24)
                                    ae_store64(h, token_value(op))
                                    ae_store64(h + 8, params)
                                    ae_store64(h + 16, hbody)
                                    vec_push(ops, h)
                                    parser_match(p, TOK_COMMA)
                                }
                                parser_expect(p, TOK_RBRACE)
                                let hnd = ae_malloc(16)
                                ae_store64(hnd, token_value(eff))
                                ae_store64(hnd + 8, ops)
                                vec_push(handlers, hnd)
                            }
                            let try_n = ast_new(AST_TRY_HANDLE, token_line(cur), token_col(cur))
                            ast_set_data1(try_n, try_body)
                            ast_set_data2(try_n, handlers)
                            vec_push(stmts, try_n)
                        } else {
                            let s = parse_stmt(p)
                            if s != 0 { vec_push(stmts, s) }
                        }
                    }
                }
            }
        }
    }
    
    parser_expect(p, TOK_RBRACE)
    ast_block(stmts, line, col)
}

// ============================================================================
// DECLARATIONS
// ============================================================================

func parse_func(p: Int) -> Int {
    let tok = parser_peek(p)
    let line = token_line(tok)
    let col = token_col(tok)
    
    parser_expect(p, TOK_FUNC)
    let name_tok = parser_expect(p, TOK_ID)
    let name = 0
    if name_tok != 0 { name = token_value(name_tok) }
    
    parser_expect(p, TOK_LPAREN)
    let params = vec_new()
    
    if parser_check(p, TOK_RPAREN) == 0 {
        let pn = parser_expect(p, TOK_ID)
        parser_expect(p, TOK_COLON)
        let pt = parse_type(p)
        let pm = ae_malloc(16)
        ae_store64(pm, token_value(pn))
        ae_store64(pm + 8, pt)
        vec_push(params, pm)
        
        while parser_match(p, TOK_COMMA) == 1 {
            let pn2 = parser_expect(p, TOK_ID)
            parser_expect(p, TOK_COLON)
            let pt2 = parse_type(p)
            let pm2 = ae_malloc(16)
            ae_store64(pm2, token_value(pn2))
            ae_store64(pm2 + 8, pt2)
            vec_push(params, pm2)
        }
    }
    
    parser_expect(p, TOK_RPAREN)
    
    let ret_type = 0
    if parser_match(p, TOK_ARROW) == 1 { ret_type = parse_type(p) }
    
    let body = parse_block(p)
    ast_func(name, params, ret_type, body, line, col)
}

func parse_struct(p: Int) -> Int {
    let tok = parser_peek(p)
    let line = token_line(tok)
    let col = token_col(tok)
    
    parser_expect(p, TOK_STRUCT)
    let name_tok = parser_expect(p, TOK_ID)
    let name = 0
    if name_tok != 0 { name = token_value(name_tok) }
    
    parser_expect(p, TOK_LBRACE)
    let fields = vec_new()
    
    while parser_check(p, TOK_RBRACE) == 0 {
        let fn = parser_expect(p, TOK_ID)
        parser_expect(p, TOK_COLON)
        let ft = parse_type(p)
        let f = ae_malloc(16)
        ae_store64(f, token_value(fn))
        ae_store64(f + 8, ft)
        vec_push(fields, f)
        parser_match(p, TOK_COMMA)
    }
    
    parser_expect(p, TOK_RBRACE)
    ast_struct(name, fields, vec_new(), line, col)
}

func parse_trait(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_TRAIT)
    let name_tok = parser_expect(p, TOK_ID)
    parser_expect(p, TOK_LBRACE)
    let methods = vec_new()
    while parser_check(p, TOK_RBRACE) == 0 {
        if parser_check(p, TOK_FUNC) == 1 { vec_push(methods, parse_func(p)) }
        else { parser_advance(p) }
    }
    parser_expect(p, TOK_RBRACE)
    let t = ast_new(AST_TRAIT, token_line(tok), token_col(tok))
    ast_set_data1(t, token_value(name_tok))
    ast_set_data2(t, methods)
    t
}

func parse_impl(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_IMPL)
    let type_name = parser_expect(p, TOK_ID)
    let trait_name = 0
    if parser_match(p, TOK_FOR) == 1 {
        trait_name = token_value(type_name)
        type_name = parser_expect(p, TOK_ID)
    }
    parser_expect(p, TOK_LBRACE)
    let methods = vec_new()
    while parser_check(p, TOK_RBRACE) == 0 {
        if parser_check(p, TOK_FUNC) == 1 { vec_push(methods, parse_func(p)) }
        else { parser_advance(p) }
    }
    parser_expect(p, TOK_RBRACE)
    let impl_node = ast_new(AST_IMPL, token_line(tok), token_col(tok))
    ast_set_data1(impl_node, token_value(type_name))
    ast_set_data2(impl_node, trait_name)
    ast_set_data3(impl_node, methods)
    impl_node
}

func parse_actor(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_ACTOR)
    let name_tok = parser_expect(p, TOK_ID)
    let name = 0
    if name_tok != 0 { name = token_value(name_tok) }
    parser_expect(p, TOK_LBRACE)
    let fields = vec_new()
    let handlers = vec_new()
    while parser_check(p, TOK_RBRACE) == 0 {
        if parser_check(p, TOK_FUNC) == 1 { vec_push(handlers, parse_func(p)) }
        else {
            if parser_check(p, TOK_ID) == 1 {
                let fn = parser_expect(p, TOK_ID)
                parser_expect(p, TOK_COLON)
                let ft = parse_type(p)
                let f = ae_malloc(16)
                ae_store64(f, token_value(fn))
                ae_store64(f + 8, ft)
                vec_push(fields, f)
                parser_match(p, TOK_COMMA)
            } else { parser_advance(p) }
        }
    }
    parser_expect(p, TOK_RBRACE)
    let a = ast_new(AST_ACTOR_DEF, token_line(tok), token_col(tok))
    ast_set_data1(a, name)
    ast_set_data2(a, fields)
    ast_set_data3(a, handlers)
    a
}

func parse_effect(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_EFFECT)
    let name_tok = parser_expect(p, TOK_ID)
    let name = 0
    if name_tok != 0 { name = token_value(name_tok) }
    parser_expect(p, TOK_LBRACE)
    let ops = vec_new()
    while parser_check(p, TOK_RBRACE) == 0 {
        let op_name = parser_expect(p, TOK_ID)
        parser_expect(p, TOK_LPAREN)
        let param_type = 0
        if parser_check(p, TOK_RPAREN) == 0 { param_type = parse_type(p) }
        parser_expect(p, TOK_RPAREN)
        parser_expect(p, TOK_ARROW)
        let ret_type = parse_type(p)
        let op = ae_malloc(24)
        ae_store64(op, token_value(op_name))
        ae_store64(op + 8, param_type)
        ae_store64(op + 16, ret_type)
        vec_push(ops, op)
        parser_match(p, TOK_COMMA)
    }
    parser_expect(p, TOK_RBRACE)
    let e = ast_new(AST_EFFECT_DECL, token_line(tok), token_col(tok))
    ast_set_data1(e, name)
    ast_set_data2(e, ops)
    e
}

func parse_extern(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_EXTERN)
    parser_expect(p, TOK_FUNC)
    let name_tok = parser_expect(p, TOK_ID)
    let name = 0
    if name_tok != 0 { name = token_value(name_tok) }
    parser_expect(p, TOK_LPAREN)
    let params = vec_new()
    if parser_check(p, TOK_RPAREN) == 0 {
        let pn = parser_expect(p, TOK_ID)
        parser_expect(p, TOK_COLON)
        let pt = parse_type(p)
        let pm = ae_malloc(16)
        ae_store64(pm, token_value(pn))
        ae_store64(pm + 8, pt)
        vec_push(params, pm)
        while parser_match(p, TOK_COMMA) == 1 {
            let pn2 = parser_expect(p, TOK_ID)
            parser_expect(p, TOK_COLON)
            let pt2 = parse_type(p)
            let pm2 = ae_malloc(16)
            ae_store64(pm2, token_value(pn2))
            ae_store64(pm2 + 8, pt2)
            vec_push(params, pm2)
        }
    }
    parser_expect(p, TOK_RPAREN)
    let ret_type = 0
    if parser_match(p, TOK_ARROW) == 1 { ret_type = parse_type(p) }
    let ex = ast_new(AST_EXTERN_FUNC, token_line(tok), token_col(tok))
    ast_set_data1(ex, name)
    ast_set_data2(ex, params)
    ast_set_data3(ex, ret_type)
    ex
}

func parse_import(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_IMPORT)
    let path = vec_new()
    let name_tok = parser_expect(p, TOK_ID)
    if name_tok != 0 { vec_push(path, token_value(name_tok)) }
    while parser_match(p, TOK_DOT) == 1 {
        let next = parser_expect(p, TOK_ID)
        if next != 0 { vec_push(path, token_value(next)) }
    }
    ast_import(path, token_line(tok), token_col(tok))
}

func parse_const(p: Int) -> Int {
    let tok = parser_peek(p)
    parser_expect(p, TOK_CONST)
    let name_tok = parser_expect(p, TOK_ID)
    let name = 0
    if name_tok != 0 { name = token_value(name_tok) }
    parser_expect(p, TOK_COLON)
    let typ = parse_type(p)
    parser_expect(p, TOK_EQ)
    let val = parse_expr(p)
    ast_const(name, typ, val, token_line(tok), token_col(tok))
}

// ============================================================================
// MODULE
// ============================================================================

func parse_module(p: Int) -> Int {
    let decls = vec_new()
    
    while parser_check(p, TOK_EOF) == 0 {
        let tok = parser_peek(p)
        if tok == 0 { return ast_module(decls) }
        let typ = token_type(tok)
        
        if typ == TOK_FUNC { vec_push(decls, parse_func(p)) }
        else {
            if typ == TOK_STRUCT { vec_push(decls, parse_struct(p)) }
            else {
                if typ == TOK_CONST { vec_push(decls, parse_const(p)) }
                else {
                    if typ == TOK_IMPORT { vec_push(decls, parse_import(p)) }
                    else {
                        if typ == TOK_TRAIT { vec_push(decls, parse_trait(p)) }
                        else {
                            if typ == TOK_IMPL { vec_push(decls, parse_impl(p)) }
                            else {
                                if typ == TOK_ACTOR { vec_push(decls, parse_actor(p)) }
                                else {
                                    if typ == TOK_EFFECT { vec_push(decls, parse_effect(p)) }
                                    else {
                                        if typ == TOK_EXTERN { vec_push(decls, parse_extern(p)) }
                                        else { parser_advance(p) }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    ast_module(decls)
}

func parse(tokens: Int) -> Int {
    let p = parser_new(tokens)
    parse_module(p)
}
