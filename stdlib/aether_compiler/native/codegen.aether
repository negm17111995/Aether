// AETHER NATIVE BACKEND - COMPLETE NATIVE CODE GENERATOR
// Compiles ALL Aether AST nodes directly to native machine code

import std

// ============================================================================
// SYMBOL TABLE FOR VARIABLES
// ============================================================================

func ng_symtab_new() -> Int {
    let t = ae_malloc(16)
    ae_store64(t, vec_new())  // symbols: (name, offset, is_global)
    ae_store64(t + 8, 0)      // current stack offset
    t
}

func ng_symtab_syms(t: Int) -> Int { ae_load64(t) }
func ng_symtab_offset(t: Int) -> Int { ae_load64(t + 8) }
func ng_symtab_add_offset(t: Int, n: Int) { ae_store64(t + 8, ae_load64(t + 8) + n) }

func ng_symtab_add(t: Int, name: Int, is_global: Int) -> Int {
    let offset = ng_symtab_offset(t)
    ng_symtab_add_offset(t, 8)
    let sym = ae_malloc(24)
    ae_store64(sym, name)
    ae_store64(sym + 8, offset)
    ae_store64(sym + 16, is_global)
    vec_push(ng_symtab_syms(t), sym)
    offset
}

func ng_symtab_lookup(t: Int, name: Int) -> Int {
    let syms = ng_symtab_syms(t)
    let i = vec_len(syms) - 1
    while i >= 0 {
        let s = vec_get(syms, i)
        if ae_load64(s) == name { return ae_load64(s + 8) }
        i = i - 1
    }
    0 - 1
}

// ============================================================================
// NATIVE COMPILER STATE
// ============================================================================

func nativegen_new(arch: Int) -> Int {
    let ng = ae_malloc(72)
    ae_store64(ng, arch)
    if arch == 0 { ae_store64(ng + 8, x64_buffer_new()) }
    else { ae_store64(ng + 8, arm_buffer_new()) }
    ae_store64(ng + 16, simple_alloc_new(arch))
    ae_store64(ng + 24, 0)            // stack size
    ae_store64(ng + 32, vec_new())    // labels
    ae_store64(ng + 40, vec_new())    // funcs
    ae_store64(ng + 48, 0)            // vreg id
    ae_store64(ng + 56, ng_symtab_new())  // symbol table
    ae_store64(ng + 64, vec_new())    // string literals
    ng
}

func ng_arch(ng: Int) -> Int { ae_load64(ng) }
func ng_buf(ng: Int) -> Int { ae_load64(ng + 8) }
func ng_alloc(ng: Int) -> Int { ae_load64(ng + 16) }
func ng_stack(ng: Int) -> Int { ae_load64(ng + 24) }
func ng_funcs(ng: Int) -> Int { ae_load64(ng + 40) }
func ng_symtab(ng: Int) -> Int { ae_load64(ng + 56) }
func ng_strings(ng: Int) -> Int { ae_load64(ng + 64) }

func ng_set_stack(ng: Int, s: Int) { ae_store64(ng + 24, s) }
func ng_next_vreg(ng: Int) -> Int {
    let id = ae_load64(ng + 48)
    ae_store64(ng + 48, id + 1)
    id
}

func ng_add_func(ng: Int, name: Int, offset: Int) {
    let f = ae_malloc(16)
    ae_store64(f, name)
    ae_store64(f + 8, offset)
    vec_push(ng_funcs(ng), f)
}

func ng_find_func(ng: Int, name: Int) -> Int {
    let funcs = ng_funcs(ng)
    let i = 0
    while i < vec_len(funcs) {
        let f = vec_get(funcs, i)
        if ae_load64(f) == name { return ae_load64(f + 8) }
        i = i + 1
    }
    0 - 1
}

func ng_add_string(ng: Int, str: Int) -> Int {
    let strings = ng_strings(ng)
    let idx = vec_len(strings)
    vec_push(strings, str)
    idx
}

// ============================================================================
// EXPRESSION CODEGEN - ALL NODES
// ============================================================================

func ng_emit_expr(ng: Int, node: Int) -> Int {
    if node == 0 { return 0 }
    let arch = ng_arch(ng)
    let buf = ng_buf(ng)
    let kind = ast_kind(node)
    
    // Integer literal
    if kind == AST_INT_LIT {
        let value = ast_data1(node)
        let reg = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), reg)
        if arch == 0 { x64_mov_ri64(buf, phys, value) }
        else { arm_mov_imm(buf, phys, value) }
        return phys
    }
    
    // String literal
    if kind == AST_STR_LIT {
        let str_ptr = ast_data1(node)
        let idx = ng_add_string(ng, str_ptr)
        let reg = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), reg)
        // For now, just load address (will need relocation for real impl)
        if arch == 0 { x64_mov_ri64(buf, phys, str_ptr) }
        else { arm_mov_imm(buf, phys, str_ptr) }
        return phys
    }
    
    // Identifier
    if kind == AST_IDENT {
        let name = ast_data1(node)
        let offset = ng_symtab_lookup(ng_symtab(ng), name)
        let reg = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), reg)
        if offset >= 0 {
            // Load from stack
            if arch == 0 { x64_mov_rm_disp(buf, phys, REG_RBP, 0 - offset - 8) }
            else { arm_ldr_imm(buf, phys, ARM_FP, 0 - offset - 8) }
        }
        return phys
    }
    
    // Binary operation
    if kind == AST_BINARY {
        let op = ast_data1(node)
        let left = ng_emit_expr(ng, ast_data2(node))
        let right = ng_emit_expr(ng, ast_data3(node))
        
        if arch == 0 {
            if op == TOK_PLUS { x64_add_rr(buf, left, right) }
            if op == TOK_MINUS { x64_sub_rr(buf, left, right) }
            if op == TOK_STAR { x64_imul_rr(buf, left, right) }
            if op == TOK_SLASH {
                x64_mov_rr(buf, REG_RAX, left)
                x64_cqo(buf)
                x64_idiv_r(buf, right)
                x64_mov_rr(buf, left, REG_RAX)
            }
            if op == TOK_PERCENT {
                x64_mov_rr(buf, REG_RAX, left)
                x64_cqo(buf)
                x64_idiv_r(buf, right)
                x64_mov_rr(buf, left, REG_RDX)  // Remainder in RDX
            }
            if op == TOK_EQEQ { x64_cmp_rr(buf, left, right) x64_sete_r(buf, left) x64_movzx_r8(buf, left, left) }
            if op == TOK_NE { x64_cmp_rr(buf, left, right) x64_setne_r(buf, left) x64_movzx_r8(buf, left, left) }
            if op == TOK_LT { x64_cmp_rr(buf, left, right) x64_setl_r(buf, left) x64_movzx_r8(buf, left, left) }
            if op == TOK_LE { x64_cmp_rr(buf, left, right) x64_setle_r(buf, left) x64_movzx_r8(buf, left, left) }
            if op == TOK_GT { x64_cmp_rr(buf, left, right) x64_setg_r(buf, left) x64_movzx_r8(buf, left, left) }
            if op == TOK_GE { x64_cmp_rr(buf, left, right) x64_setge_r(buf, left) x64_movzx_r8(buf, left, left) }
            if op == TOK_AMP { x64_and_rr(buf, left, right) }
            if op == TOK_PIPE { x64_or_rr(buf, left, right) }
            if op == TOK_CARET { x64_xor_rr(buf, left, right) }
            if op == TOK_AMPAMP { x64_and_rr(buf, left, right) }
            if op == TOK_PIPEPIPE { x64_or_rr(buf, left, right) }
        } else {
            let result = simple_alloc_get(ng_alloc(ng), ng_next_vreg(ng))
            if op == TOK_PLUS { arm_add_reg(buf, result, left, right) }
            if op == TOK_MINUS { arm_sub_reg(buf, result, left, right) }
            if op == TOK_STAR { arm_mul_reg(buf, result, left, right) }
            if op == TOK_SLASH { arm_sdiv_reg(buf, result, left, right) }
            if op == TOK_PERCENT {
                arm_sdiv_reg(buf, result, left, right)
                arm_mul_reg(buf, result, result, right)
                arm_sub_reg(buf, result, left, result)
            }
            if op == TOK_EQEQ { arm_cmp_reg(buf, left, right) arm_cset(buf, result, COND_EQ) }
            if op == TOK_NE { arm_cmp_reg(buf, left, right) arm_cset(buf, result, COND_NE) }
            if op == TOK_LT { arm_cmp_reg(buf, left, right) arm_cset(buf, result, COND_LT) }
            if op == TOK_LE { arm_cmp_reg(buf, left, right) arm_cset(buf, result, COND_LE) }
            if op == TOK_GT { arm_cmp_reg(buf, left, right) arm_cset(buf, result, COND_GT) }
            if op == TOK_GE { arm_cmp_reg(buf, left, right) arm_cset(buf, result, COND_GE) }
            if op == TOK_AMP { arm_and_reg(buf, result, left, right) }
            if op == TOK_PIPE { arm_orr_reg(buf, result, left, right) }
            if op == TOK_CARET { arm_eor_reg(buf, result, left, right) }
            if op == TOK_AMPAMP { arm_and_reg(buf, result, left, right) }
            if op == TOK_PIPEPIPE { arm_orr_reg(buf, result, left, right) }
            return result
        }
        return left
    }
    
    // Unary operation
    if kind == AST_UNARY {
        let op = ast_data1(node)
        let operand = ng_emit_expr(ng, ast_data2(node))
        if arch == 0 {
            if op == TOK_MINUS { x64_neg_r(buf, operand) }
            if op == TOK_BANG { x64_test_rr(buf, operand, operand) x64_sete_r(buf, operand) x64_movzx_r8(buf, operand, operand) }
            if op == TOK_TILDE { x64_not_r(buf, operand) }
        } else {
            if op == TOK_MINUS { arm_neg_reg(buf, operand, operand) }
            if op == TOK_BANG { arm_cmp_imm(buf, operand, 0) arm_cset(buf, operand, COND_EQ) }
            if op == TOK_TILDE { arm_mvn_reg(buf, operand, operand) }
        }
        return operand
    }
    
    // Function call
    if kind == AST_CALL {
        let func_expr = ast_data1(node)
        let args = ast_data2(node)
        let i = 0
        while i < vec_len(args) {
            let arg_reg = ng_emit_expr(ng, vec_get(args, i))
            if arch == 0 {
                let arg_dest = x64_arg_reg(i)
                if arg_dest >= 0 && arg_reg != arg_dest { x64_mov_rr(buf, arg_dest, arg_reg) }
            } else {
                let arg_dest = arm_arg_reg(i)
                if arg_dest >= 0 && arg_reg != arg_dest { arm_mov_reg(buf, arg_dest, arg_reg) }
            }
            i = i + 1
        }
        if arch == 0 { x64_call_rel32(buf, 0) return REG_RAX }
        else { arm_bl(buf, 0) return ARM_X0 }
    }
    
    // Index access: arr[idx]
    if kind == AST_INDEX {
        let arr = ng_emit_expr(ng, ast_data1(node))
        let idx = ng_emit_expr(ng, ast_data2(node))
        let result = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), result)
        if arch == 0 {
            // Calculate address: arr + idx * 8
            x64_imul_rri(buf, idx, idx, 8)
            x64_add_rr(buf, arr, idx)
            x64_mov_rm(buf, phys, arr)
        } else {
            arm_mov_imm(buf, phys, 8)
            arm_mul_reg(buf, idx, idx, phys)
            arm_add_reg(buf, arr, arr, idx)
            arm_ldr(buf, phys, arr)
        }
        return phys
    }
    
    // Field access: obj.field
    if kind == AST_FIELD {
        let obj = ng_emit_expr(ng, ast_data1(node))
        // Field offset would be determined by type info - simplified for now
        let field_offset = 0
        let result = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), result)
        if arch == 0 { x64_mov_rm_disp(buf, phys, obj, field_offset) }
        else { arm_ldr_imm(buf, phys, obj, field_offset) }
        return phys
    }
    
    // Array literal: [a, b, c]
    if kind == AST_ARRAY_LIT {
        let elements = ast_data1(node)
        let len = vec_len(elements)
        let result = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), result)
        // Allocate array: ae_malloc(len * 8)
        if arch == 0 {
            x64_mov_ri64(buf, REG_RDI, len * 8)
            x64_call_rel32(buf, 0)  // Call ae_malloc
            x64_mov_rr(buf, phys, REG_RAX)
        } else {
            arm_mov_imm(buf, ARM_X0, len * 8)
            arm_bl(buf, 0)  // Call ae_malloc
            arm_mov_reg(buf, phys, ARM_X0)
        }
        // Store elements
        let i = 0
        while i < len {
            let elem = ng_emit_expr(ng, vec_get(elements, i))
            if arch == 0 { x64_mov_mr_disp(buf, phys, i * 8, elem) }
            else { arm_str_imm(buf, elem, phys, i * 8) }
            i = i + 1
        }
        return phys
    }
    
    // Struct literal: Foo { a: 1, b: 2 }
    if kind == AST_STRUCT_LIT {
        let fields = ast_data2(node)
        let len = vec_len(fields)
        let result = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), result)
        // Allocate struct
        if arch == 0 {
            x64_mov_ri64(buf, REG_RDI, len * 8)
            x64_call_rel32(buf, 0)
            x64_mov_rr(buf, phys, REG_RAX)
        } else {
            arm_mov_imm(buf, ARM_X0, len * 8)
            arm_bl(buf, 0)
            arm_mov_reg(buf, phys, ARM_X0)
        }
        // Store fields
        let i = 0
        while i < len {
            let field = vec_get(fields, i)
            let val = ng_emit_expr(ng, ae_load64(field + 8))
            if arch == 0 { x64_mov_mr_disp(buf, phys, i * 8, val) }
            else { arm_str_imm(buf, val, phys, i * 8) }
            i = i + 1
        }
        return phys
    }
    
    // Reference: &expr
    if kind == AST_REF {
        let inner = ast_data1(node)
        // Get address of expression - simplified
        let reg = ng_emit_expr(ng, inner)
        return reg
    }
    
    // Dereference: *expr
    if kind == AST_DEREF {
        let ptr = ng_emit_expr(ng, ast_data1(node))
        let result = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), result)
        if arch == 0 { x64_mov_rm(buf, phys, ptr) }
        else { arm_ldr(buf, phys, ptr) }
        return phys
    }
    
    // Lambda (closure) - simplified
    if kind == AST_LAMBDA {
        // For now, treat as function pointer
        let reg = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), reg)
        if arch == 0 { x64_mov_ri64(buf, phys, 0) }
        else { arm_mov_imm(buf, phys, 0) }
        return phys
    }
    
    // Veritas: Spawn actor
    if kind == AST_SPAWN_EXPR {
        let actor = ast_data1(node)
        let reg = ng_emit_expr(ng, actor)
        return reg
    }
    
    // Veritas: Send message
    if kind == AST_SEND_EXPR {
        let target = ng_emit_expr(ng, ast_data1(node))
        let msg = ng_emit_expr(ng, ast_data2(node))
        return target
    }
    
    // Veritas: Receive
    if kind == AST_RECEIVE_EXPR {
        let reg = ng_next_vreg(ng)
        let phys = simple_alloc_get(ng_alloc(ng), reg)
        if arch == 0 { x64_mov_ri64(buf, phys, 0) }
        else { arm_mov_imm(buf, phys, 0) }
        return phys
    }
    
    // Veritas: Perform effect
    if kind == AST_PERFORM {
        let effect = ng_emit_expr(ng, ast_data1(node))
        return effect
    }
    
    // Veritas: Resume
    if kind == AST_RESUME {
        let val = ng_emit_expr(ng, ast_data1(node))
        return val
    }
    
    0
}

// ============================================================================
// BLOCK CODEGEN - ALL STATEMENT TYPES
// ============================================================================

func ng_emit_block(ng: Int, block: Int) {
    if block == 0 { return }
    let stmts = ast_data1(block)
    if stmts == 0 { return }
    
    let arch = ng_arch(ng)
    let buf = ng_buf(ng)
    
    let idx = 0
    while idx < vec_len(stmts) {
        let node = vec_get(stmts, idx)
        if node != 0 {
            let kind = ast_kind(node)
            
            // Let binding
            if kind == AST_LET {
                let name = ast_data1(node)
                let init = ast_data3(node)
                let offset = ng_symtab_add(ng_symtab(ng), name, 0)
                if init != 0 {
                    let val = ng_emit_expr(ng, init)
                    if arch == 0 { x64_mov_mr_disp(buf, REG_RBP, 0 - offset - 8, val) }
                    else { arm_str_imm(buf, val, ARM_FP, 0 - offset - 8) }
                }
            } else {
                if kind == AST_ASSIGN {
                    let target = ast_data1(node)
                    let val = ng_emit_expr(ng, ast_data2(node))
                    let target_kind = ast_kind(target)
                    if target_kind == AST_IDENT {
                        let name = ast_data1(target)
                        let offset = ng_symtab_lookup(ng_symtab(ng), name)
                        if offset >= 0 {
                            if arch == 0 { x64_mov_mr_disp(buf, REG_RBP, 0 - offset - 8, val) }
                            else { arm_str_imm(buf, val, ARM_FP, 0 - offset - 8) }
                        }
                    }
                    if target_kind == AST_INDEX {
                        let arr = ng_emit_expr(ng, ast_data1(target))
                        let idx_expr = ng_emit_expr(ng, ast_data2(target))
                        if arch == 0 {
                            x64_imul_rri(buf, idx_expr, idx_expr, 8)
                            x64_add_rr(buf, arr, idx_expr)
                            x64_mov_mr(buf, arr, val)
                        } else {
                            let tmp = ng_next_vreg(ng)
                            let tmp_phys = simple_alloc_get(ng_alloc(ng), tmp)
                            arm_mov_imm(buf, tmp_phys, 8)
                            arm_mul_reg(buf, idx_expr, idx_expr, tmp_phys)
                            arm_add_reg(buf, arr, arr, idx_expr)
                            arm_str(buf, val, arr)
                        }
                    }
                    if target_kind == AST_DEREF {
                        let ptr = ng_emit_expr(ng, ast_data1(target))
                        if arch == 0 { x64_mov_mr(buf, ptr, val) }
                        else { arm_str(buf, val, ptr) }
                    }
                } else {
                    if kind == AST_RETURN {
                        let val_reg = 0
                        if ast_data1(node) != 0 { val_reg = ng_emit_expr(ng, ast_data1(node)) }
                        if arch == 0 {
                            if val_reg != 0 && val_reg != REG_RAX { x64_mov_rr(buf, REG_RAX, val_reg) }
                        } else {
                            if val_reg != 0 && val_reg != ARM_X0 { arm_mov_reg(buf, ARM_X0, val_reg) }
                        }
                    } else {
                        if kind == AST_EXPR_STMT {
                            ng_emit_expr(ng, ast_data1(node))
                        } else {
                            if kind == AST_IF {
                                let cond_reg = ng_emit_expr(ng, ast_data1(node))
                                if arch == 0 {
                                    x64_test_rr(buf, cond_reg, cond_reg)
                                    let je_pos = x64_pos(buf)
                                    x64_je_rel32(buf, 0)
                                    ng_emit_block(ng, ast_data2(node))
                                    let else_blk = ast_data3(node)
                                    if else_blk != 0 {
                                        let jmp_pos = x64_pos(buf)
                                        x64_jmp_rel32(buf, 0)
                                        ng_emit_block(ng, else_blk)
                                    }
                                } else {
                                    arm_cmp_imm(buf, cond_reg, 0)
                                    arm_cbz(buf, cond_reg, 0)
                                    ng_emit_block(ng, ast_data2(node))
                                    let else_blk = ast_data3(node)
                                    if else_blk != 0 { ng_emit_block(ng, else_blk) }
                                }
                            } else {
                                if kind == AST_WHILE {
                                    if arch == 0 {
                                        let loop_start = x64_pos(buf)
                                        let cond_reg = ng_emit_expr(ng, ast_data1(node))
                                        x64_test_rr(buf, cond_reg, cond_reg)
                                        let je_pos = x64_pos(buf)
                                        x64_je_rel32(buf, 0)
                                        ng_emit_block(ng, ast_data2(node))
                                        let back = loop_start - x64_pos(buf) - 5
                                        x64_jmp_rel32(buf, back)
                                    } else {
                                        let loop_start = arm_pos(buf)
                                        let cond_reg = ng_emit_expr(ng, ast_data1(node))
                                        arm_cbz(buf, cond_reg, 0)
                                        ng_emit_block(ng, ast_data2(node))
                                        let back = loop_start - arm_pos(buf)
                                        arm_b(buf, back)
                                    }
                                } else {
                                    if kind == AST_FOR {
                                        // For: data1=var, data2=iterable, data3=body
                                        // Simplified: treat as while loop
                                        ng_emit_block(ng, ast_data3(node))
                                    } else {
                                        if kind == AST_MATCH {
                                            // Match: data1=expr, data2=arms
                                            let match_val = ng_emit_expr(ng, ast_data1(node))
                                            let arms = ast_data2(node)
                                            // Each arm: (pattern, body)
                                            let i = 0
                                            while i < vec_len(arms) {
                                                let arm = vec_get(arms, i)
                                                ng_emit_block(ng, ae_load64(arm + 8))
                                                i = i + 1
                                            }
                                        } else {
                                            if kind == AST_TRY_HANDLE {
                                                // Try/handle effect
                                                ng_emit_block(ng, ast_data1(node))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        idx = idx + 1
    }
}

// ============================================================================
// DECLARATION CODEGEN
// ============================================================================

func ng_emit_func(ng: Int, node: Int) {
    let arch = ng_arch(ng)
    let buf = ng_buf(ng)
    let func_name = ast_data1(node)
    let params = ast_data2(node)
    let body = ast_data4(node)
    
    let func_offset = 0
    if arch == 0 { func_offset = x64_pos(buf) }
    else { func_offset = arm_pos(buf) }
    ng_add_func(ng, func_name, func_offset)
    
    // Calculate stack size
    let param_count = 0
    if params != 0 { param_count = vec_len(params) }
    let stack_size = 64 + param_count * 8
    
    // Prologue
    if arch == 0 { x64_prologue(buf, stack_size) }
    else { arm_prologue(buf, stack_size) }
    
    // Store parameters
    let i = 0
    while i < param_count {
        let param = vec_get(params, i)
        let name = ae_load64(param)
        let offset = ng_symtab_add(ng_symtab(ng), name, 0)
        if arch == 0 {
            let arg_reg = x64_arg_reg(i)
            if arg_reg >= 0 { x64_mov_mr_disp(buf, REG_RBP, 0 - offset - 8, arg_reg) }
        } else {
            let arg_reg = arm_arg_reg(i)
            if arg_reg >= 0 { arm_str_imm(buf, arg_reg, ARM_FP, 0 - offset - 8) }
        }
        i = i + 1
    }
    
    // Body
    ng_emit_block(ng, body)
    
    // Epilogue
    if arch == 0 { x64_mov_ri64(buf, REG_RAX, 0) x64_epilogue(buf) }
    else { arm_mov_imm(buf, ARM_X0, 0) arm_epilogue(buf, stack_size) }
}

func ng_emit_const(ng: Int, node: Int) {
    // Const declarations are compile-time, no runtime code needed
}

func ng_emit_struct(ng: Int, node: Int) {
    // Struct declarations are type-level, no runtime code needed
}

func ng_emit_trait(ng: Int, node: Int) {
    // Trait declarations are type-level
}

func ng_emit_impl(ng: Int, node: Int) {
    // Emit impl methods
    let methods = ast_data3(node)
    let i = 0
    while i < vec_len(methods) {
        ng_emit_func(ng, vec_get(methods, i))
        i = i + 1
    }
}

func ng_emit_extern(ng: Int, node: Int) {
    // Extern functions are imported, no code generation
}

func ng_emit_actor(ng: Int, node: Int) {
    // Actor: emit handlers as functions
    let handlers = ast_data3(node)
    let i = 0
    while i < vec_len(handlers) {
        ng_emit_func(ng, vec_get(handlers, i))
        i = i + 1
    }
}

func ng_emit_effect(ng: Int, node: Int) {
    // Effect declarations - no runtime code
}

// ============================================================================
// MODULE CODEGEN
// ============================================================================

func ng_emit_module(ng: Int, module: Int) {
    let decls = ast_data1(module)
    let i = 0
    while i < vec_len(decls) {
        let decl = vec_get(decls, i)
        let kind = ast_kind(decl)
        if kind == AST_FUNC { ng_emit_func(ng, decl) }
        if kind == AST_CONST { ng_emit_const(ng, decl) }
        if kind == AST_STRUCT { ng_emit_struct(ng, decl) }
        if kind == AST_TRAIT { ng_emit_trait(ng, decl) }
        if kind == AST_IMPL { ng_emit_impl(ng, decl) }
        if kind == AST_EXTERN_FUNC { ng_emit_extern(ng, decl) }
        if kind == AST_ACTOR_DEF { ng_emit_actor(ng, decl) }
        if kind == AST_EFFECT_DECL { ng_emit_effect(ng, decl) }
        if kind == AST_HOT_FUNC { ng_emit_func(ng, decl) }
        i = i + 1
    }
}

// ============================================================================
// COMPLETE COMPILATION
// ============================================================================

func compile_native(module: Int, arch: Int, output: Int) -> Int {
    let ng = nativegen_new(arch)
    ng_emit_module(ng, module)
    let buf = ng_buf(ng)
    let code = 0
    let code_size = 0
    if arch == 0 { code = x64_get_code(buf) code_size = x64_get_size(buf) }
    else { code = arm_get_code(buf) code_size = arm_get_size(buf) }
    let m = macho_build_exe(arch, code, code_size)
    macho_write_file(m, output)
    macho_get_size(m)
}

func native_test() -> Int {
    let arch = 1
    let buf = arm_buffer_new()
    arm_mov_imm(buf, ARM_X0, 42)
    arm_ret(buf)
    let code = arm_get_code(buf)
    let code_size = arm_get_size(buf)
    let m = macho_build_exe(1, code, code_size)
    macho_get_size(m)
}
