// AETHER NATIVE BACKEND - WINDOWS PE64 FORMAT GENERATOR
// Generates Windows x64 PE executables

import std

// ============================================================================
// PE CONSTANTS
// ============================================================================

const PE_SIGNATURE: Int = 17744  // "PE\0\0" = 0x4550
const IMAGE_FILE_MACHINE_AMD64: Int = 34404  // 0x8664
const IMAGE_FILE_EXECUTABLE_IMAGE: Int = 2
const IMAGE_FILE_LARGE_ADDRESS_AWARE: Int = 32

// PE Optional Header Magic
const PE32_MAGIC: Int = 267   // 0x10b
const PE64_MAGIC: Int = 523   // 0x20b

// Section characteristics
const IMAGE_SCN_CNT_CODE: Int = 32           // 0x20
const IMAGE_SCN_MEM_EXECUTE: Int = 536870912 // 0x20000000
const IMAGE_SCN_MEM_READ: Int = 1073741824   // 0x40000000
const IMAGE_SCN_MEM_WRITE: Int = 2147483648  // 0x80000000

// Subsystem
const IMAGE_SUBSYSTEM_CONSOLE: Int = 3
const IMAGE_SUBSYSTEM_WINDOWS_GUI: Int = 2

// Base addresses
const PE_IMAGE_BASE: Int = 4194304  // 0x400000
const PE_SECTION_ALIGNMENT: Int = 4096
const PE_FILE_ALIGNMENT: Int = 512

// ============================================================================
// PE BUILDER STATE
// ============================================================================

func pe_new() -> Int {
    let p = ae_malloc(64)
    ae_store64(p, ae_malloc(65536))      // buffer
    ae_store64(p + 8, 0)                  // position
    ae_store64(p + 16, IMAGE_FILE_MACHINE_AMD64)  // machine
    ae_store64(p + 24, 1)                 // num sections
    ae_store64(p + 32, IMAGE_SUBSYSTEM_CONSOLE)   // subsystem
    ae_store64(p + 40, PE_IMAGE_BASE)     // image base
    ae_store64(p + 48, 0)                 // entry point RVA
    ae_store64(p + 56, 0)                 // code size
    p
}

func pe_buf(p: Int) -> Int { ae_load64(p) }
func pe_pos(p: Int) -> Int { ae_load64(p + 8) }
func pe_set_pos(p: Int, pos: Int) { ae_store64(p + 8, pos) }

// ============================================================================
// WRITE HELPERS
// ============================================================================

func pe_write8(p: Int, val: Int) {
    let buf = pe_buf(p)
    let pos = pe_pos(p)
    ae_store8(buf + pos, val % 256)
    pe_set_pos(p, pos + 1)
}

func pe_write16(p: Int, val: Int) {
    pe_write8(p, val % 256)
    pe_write8(p, (val / 256) % 256)
}

func pe_write32(p: Int, val: Int) {
    pe_write16(p, val % 65536)
    pe_write16(p, (val / 65536) % 65536)
}

func pe_write64(p: Int, val: Int) {
    pe_write32(p, val % 4294967296)
    pe_write32(p, val / 4294967296)
}

func pe_write_zeros(p: Int, count: Int) {
    let i = 0
    while i < count { pe_write8(p, 0) i = i + 1 }
}

func pe_write_bytes(p: Int, src: Int, len: Int) {
    let i = 0
    while i < len {
        pe_write8(p, ae_load8(src + i))
        i = i + 1
    }
}

func pe_align(p: Int, alignment: Int) {
    let pos = pe_pos(p)
    let rem = pos % alignment
    if rem != 0 { pe_write_zeros(p, alignment - rem) }
}

// ============================================================================
// DOS HEADER (64 bytes)
// ============================================================================

func pe_write_dos_header(p: Int) {
    // DOS MZ header
    pe_write16(p, 23117)  // "MZ" = 0x5A4D
    pe_write_zeros(p, 58) // DOS stub padding
    pe_write32(p, 64)     // e_lfanew - PE header offset
}

// ============================================================================
// PE HEADER
// ============================================================================

func pe_write_file_header(p: Int, num_sections: Int) {
    // PE signature
    pe_write32(p, PE_SIGNATURE)
    
    // COFF File Header (20 bytes)
    pe_write16(p, IMAGE_FILE_MACHINE_AMD64)
    pe_write16(p, num_sections)
    pe_write32(p, 0)  // TimeDateStamp
    pe_write32(p, 0)  // PointerToSymbolTable
    pe_write32(p, 0)  // NumberOfSymbols
    pe_write16(p, 240) // SizeOfOptionalHeader (PE64)
    pe_write16(p, IMAGE_FILE_EXECUTABLE_IMAGE + IMAGE_FILE_LARGE_ADDRESS_AWARE)
}

// ============================================================================
// OPTIONAL HEADER (PE64 = 240 bytes)
// ============================================================================

func pe_write_optional_header(p: Int, code_size: Int, entry_rva: Int) {
    // Standard fields
    pe_write16(p, PE64_MAGIC)
    pe_write8(p, 14)   // Linker version major
    pe_write8(p, 0)    // Linker version minor
    pe_write32(p, code_size)  // SizeOfCode
    pe_write32(p, 0)   // SizeOfInitializedData
    pe_write32(p, 0)   // SizeOfUninitializedData
    pe_write32(p, entry_rva)  // AddressOfEntryPoint
    pe_write32(p, 4096) // BaseOfCode
    
    // PE64 specific
    pe_write64(p, PE_IMAGE_BASE)  // ImageBase
    pe_write32(p, PE_SECTION_ALIGNMENT)  // SectionAlignment
    pe_write32(p, PE_FILE_ALIGNMENT)     // FileAlignment
    pe_write16(p, 6)   // OS version major
    pe_write16(p, 0)   // OS version minor
    pe_write16(p, 0)   // Image version major
    pe_write16(p, 0)   // Image version minor
    pe_write16(p, 6)   // Subsystem version major
    pe_write16(p, 0)   // Subsystem version minor
    pe_write32(p, 0)   // Win32VersionValue
    
    // Size calculations
    let header_size = 512  // Aligned headers
    let image_size = header_size + ((code_size + 4095) / 4096) * 4096
    pe_write32(p, image_size)   // SizeOfImage
    pe_write32(p, header_size)  // SizeOfHeaders
    pe_write32(p, 0)   // CheckSum
    pe_write16(p, IMAGE_SUBSYSTEM_CONSOLE)
    pe_write16(p, 0)   // DllCharacteristics
    
    // Stack/Heap sizes
    pe_write64(p, 1048576)   // SizeOfStackReserve
    pe_write64(p, 4096)      // SizeOfStackCommit
    pe_write64(p, 1048576)   // SizeOfHeapReserve
    pe_write64(p, 4096)      // SizeOfHeapCommit
    pe_write32(p, 0)         // LoaderFlags
    pe_write32(p, 16)        // NumberOfRvaAndSizes
    
    // Data directories (16 entries, all zero for now)
    let i = 0
    while i < 16 { pe_write64(p, 0) i = i + 1 }
}

// ============================================================================
// SECTION HEADER
// ============================================================================

func pe_write_section_header(p: Int, name: Int, vsize: Int, vrva: Int, rawsize: Int, rawptr: Int, flags: Int) {
    // Name (8 bytes) - ".text\0\0\0"
    pe_write_bytes(p, name, 8)
    pe_write32(p, vsize)    // VirtualSize
    pe_write32(p, vrva)     // VirtualAddress
    pe_write32(p, rawsize)  // SizeOfRawData
    pe_write32(p, rawptr)   // PointerToRawData
    pe_write32(p, 0)        // PointerToRelocations
    pe_write32(p, 0)        // PointerToLinenumbers
    pe_write16(p, 0)        // NumberOfRelocations
    pe_write16(p, 0)        // NumberOfLinenumbers
    pe_write32(p, flags)    // Characteristics
}

// ============================================================================
// GENERATE COMPLETE PE
// ============================================================================

func make_text_section_name() -> Int {
    let s = ae_malloc(8)
    ae_store8(s, 46)     // .
    ae_store8(s + 1, 116) // t
    ae_store8(s + 2, 101) // e
    ae_store8(s + 3, 120) // x
    ae_store8(s + 4, 116) // t
    ae_store8(s + 5, 0)
    ae_store8(s + 6, 0)
    ae_store8(s + 7, 0)
    s
}

func pe_generate(p: Int, code: Int, code_size: Int) -> Int {
    // DOS header
    pe_write_dos_header(p)
    
    // PE File header
    pe_write_file_header(p, 1)
    
    // Optional header
    let entry_rva = 4096  // Code starts at 0x1000
    pe_write_optional_header(p, code_size, entry_rva)
    
    // .text section header
    let text_name = make_text_section_name()
    let code_file_offset = 512  // After headers
    let code_vsize = code_size
    let code_rawsize = ((code_size + 511) / 512) * 512
    let section_flags = IMAGE_SCN_CNT_CODE + IMAGE_SCN_MEM_EXECUTE + IMAGE_SCN_MEM_READ
    pe_write_section_header(p, text_name, code_vsize, entry_rva, code_rawsize, code_file_offset, section_flags)
    
    // Pad to file alignment (512)
    pe_align(p, PE_FILE_ALIGNMENT)
    
    // Write code
    pe_write_bytes(p, code, code_size)
    
    // Pad code section
    pe_align(p, PE_FILE_ALIGNMENT)
    
    pe_pos(p)
}

// ============================================================================
// HIGH-LEVEL API
// ============================================================================

func pe_build_exe(code: Int, code_size: Int) -> Int {
    let p = pe_new()
    pe_generate(p, code, code_size)
    p
}

func pe_get_binary(p: Int) -> Int { pe_buf(p) }
func pe_get_size(p: Int) -> Int { pe_pos(p) }

func pe_write_file(p: Int, filename: Int) -> Int {
    // Stubbed - return size instead of writing
    pe_pos(p)
}

// ============================================================================
// TEST: Create minimal Windows executable
// ============================================================================

func pe_test() -> Int {
    // Minimal x64 code: mov eax, 0; ret
    let code = ae_malloc(16)
    ae_store8(code, 184)     // mov eax, imm32
    ae_store8(code + 1, 0)
    ae_store8(code + 2, 0)
    ae_store8(code + 3, 0)
    ae_store8(code + 4, 0)
    ae_store8(code + 5, 195) // ret
    
    let p = pe_build_exe(code, 6)
    pe_get_size(p)
}
