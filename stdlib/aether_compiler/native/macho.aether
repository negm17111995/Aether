// AETHER NATIVE BACKEND - MACH-O BINARY FORMAT GENERATOR
// Generates Mach-O executables for macOS

import std

// ============================================================================
// MACH-O CONSTANTS
// ============================================================================

// Magic numbers
const MH_MAGIC_64: Int = 4277009103      // 0xFEEDFACF
const MH_CIGAM_64: Int = 3489328638      // 0xCFFAEDFE (big endian)

// CPU types
const CPU_TYPE_X86_64: Int = 16777223    // 0x1000007
const CPU_TYPE_ARM64: Int = 16777228     // 0x100000C

// CPU subtypes
const CPU_SUBTYPE_X86_64_ALL: Int = 3
const CPU_SUBTYPE_ARM64_ALL: Int = 0

// File types
const MH_EXECUTE: Int = 2
const MH_DYLIB: Int = 6
const MH_BUNDLE: Int = 8

// Flags
const MH_NOUNDEFS: Int = 1
const MH_DYLDLINK: Int = 4
const MH_PIE: Int = 2097152              // 0x200000

// Load command types
const LC_SEGMENT_64: Int = 25            // 0x19
const LC_SYMTAB: Int = 2
const LC_DYSYMTAB: Int = 11
const LC_LOAD_DYLINKER: Int = 14
const LC_UUID: Int = 27
const LC_MAIN: Int = 2147483688          // 0x80000028
const LC_UNIXTHREAD: Int = 5
const LC_DYLD_INFO_ONLY: Int = 2147483682 // 0x80000022
const LC_SOURCE_VERSION: Int = 42
const LC_BUILD_VERSION: Int = 50

// Section types
const S_REGULAR: Int = 0
const S_ZEROFILL: Int = 1
const S_ATTR_PURE_INSTRUCTIONS: Int = 2147483648  // 0x80000000
const S_ATTR_SOME_INSTRUCTIONS: Int = 1024

// VM protections
const VM_PROT_READ: Int = 1
const VM_PROT_WRITE: Int = 2
const VM_PROT_EXECUTE: Int = 4

// Sizes
const MACH_HEADER_SIZE: Int = 32
const SEGMENT_CMD_SIZE: Int = 72
const SECTION_SIZE: Int = 80
const UNIXTHREAD_SIZE_X64: Int = 184
const UNIXTHREAD_SIZE_ARM64: Int = 280
const LC_MAIN_SIZE: Int = 24

// Default addresses
const MACHO_BASE: Int = 4294967296      // 0x100000000

// ============================================================================
// MACH-O BUFFER
// ============================================================================

func macho_new() -> Int {
    let m = ae_malloc(64)
    ae_store64(m, ae_malloc(1048576))  // 1MB buffer
    ae_store64(m + 8, 0)   // position
    ae_store64(m + 16, 0)  // entry point offset
    ae_store64(m + 24, 0)  // machine (0=x64, 1=arm64)
    ae_store64(m + 32, 0)  // number of load commands
    ae_store64(m + 40, 0)  // size of load commands
    ae_store64(m + 48, vec_new())  // segments
    ae_store64(m + 56, 0)  // code offset
    m
}

func macho_buf(m: Int) -> Int { ae_load64(m) }
func macho_pos(m: Int) -> Int { ae_load64(m + 8) }
func macho_entry(m: Int) -> Int { ae_load64(m + 16) }
func macho_machine(m: Int) -> Int { ae_load64(m + 24) }
func macho_ncmds(m: Int) -> Int { ae_load64(m + 32) }
func macho_sizeofcmds(m: Int) -> Int { ae_load64(m + 40) }
func macho_segments(m: Int) -> Int { ae_load64(m + 48) }
func macho_code_off(m: Int) -> Int { ae_load64(m + 56) }

func macho_set_pos(m: Int, p: Int) { ae_store64(m + 8, p) }
func macho_set_entry(m: Int, e: Int) { ae_store64(m + 16, e) }
func macho_set_machine(m: Int, v: Int) { ae_store64(m + 24, v) }
func macho_set_ncmds(m: Int, n: Int) { ae_store64(m + 32, n) }
func macho_set_sizeofcmds(m: Int, s: Int) { ae_store64(m + 40, s) }
func macho_set_code_off(m: Int, o: Int) { ae_store64(m + 56, o) }

// Write functions
func macho_write8(m: Int, val: Int) {
    let buf = macho_buf(m)
    let pos = macho_pos(m)
    ae_store8(buf + pos, val)
    macho_set_pos(m, pos + 1)
}

func macho_write32(m: Int, val: Int) {
    macho_write8(m, val % 256)
    macho_write8(m, val / 256 % 256)
    macho_write8(m, val / 65536 % 256)
    macho_write8(m, val / 16777216 % 256)
}

func macho_write64(m: Int, val: Int) {
    macho_write32(m, val)
    macho_write32(m, val / 4294967296)
}

func macho_write_bytes(m: Int, data: Int, len: Int) {
    let i = 0
    while i < len {
        macho_write8(m, ae_load8(data + i))
        i = i + 1
    }
}

func macho_write_string(m: Int, s: Int, max_len: Int) {
    let i = 0
    let done = 0
    // Copy string bytes until null or max_len
    while i < max_len {
        if done == 0 {
            let c = ae_load8(s + i)
            macho_write8(m, c)
            if c == 0 { done = 1 }
        } else {
            // Pad with zeros after null terminator
            macho_write8(m, 0)
        }
        i = i + 1
    }
}

func macho_align(m: Int, align: Int) {
    let pos = macho_pos(m)
    let rem = pos % align
    if rem != 0 {
        let pad = align - rem
        let i = 0
        while i < pad {
            macho_write8(m, 0)
            i = i + 1
        }
    }
}

// ============================================================================
// MACH-O HEADER
// ============================================================================

func macho_write_header(m: Int, ncmds: Int, sizeofcmds: Int) {
    // Magic
    macho_write32(m, MH_MAGIC_64)
    
    // CPU type
    if macho_machine(m) == 0 {
        macho_write32(m, CPU_TYPE_X86_64)
        macho_write32(m, CPU_SUBTYPE_X86_64_ALL)
    } else {
        macho_write32(m, CPU_TYPE_ARM64)
        macho_write32(m, CPU_SUBTYPE_ARM64_ALL)
    }
    
    // File type
    macho_write32(m, MH_EXECUTE)
    
    // Number of load commands
    macho_write32(m, ncmds)
    
    // Size of load commands
    macho_write32(m, sizeofcmds)
    
    // Flags
    macho_write32(m, MH_NOUNDEFS)
    
    // Reserved (64-bit only)
    macho_write32(m, 0)
}

// ============================================================================
// SEGMENT LOAD COMMAND
// ============================================================================

func macho_write_segment(m: Int, name: Int, vmaddr: Int, vmsize: Int, fileoff: Int, filesize: Int, maxprot: Int, initprot: Int, nsects: Int) {
    // LC_SEGMENT_64
    macho_write32(m, LC_SEGMENT_64)
    
    // Command size
    let cmdsize = SEGMENT_CMD_SIZE + nsects * SECTION_SIZE
    macho_write32(m, cmdsize)
    
    // Segment name (16 bytes)
    macho_write_string(m, name, 16)
    
    // VM address
    macho_write64(m, vmaddr)
    
    // VM size
    macho_write64(m, vmsize)
    
    // File offset
    macho_write64(m, fileoff)
    
    // File size
    macho_write64(m, filesize)
    
    // Max VM protection
    macho_write32(m, maxprot)
    
    // Initial VM protection
    macho_write32(m, initprot)
    
    // Number of sections
    macho_write32(m, nsects)
    
    // Flags
    macho_write32(m, 0)
}

// ============================================================================
// SECTION
// ============================================================================

func macho_write_section(m: Int, sectname: Int, segname: Int, addr: Int, size: Int, offset: Int, align: Int, flags: Int) {
    // Section name (16 bytes)
    macho_write_string(m, sectname, 16)
    
    // Segment name (16 bytes)
    macho_write_string(m, segname, 16)
    
    // Address
    macho_write64(m, addr)
    
    // Size
    macho_write64(m, size)
    
    // Offset
    macho_write32(m, offset)
    
    // Alignment (power of 2)
    macho_write32(m, align)
    
    // Relocations offset
    macho_write32(m, 0)
    
    // Number of relocations
    macho_write32(m, 0)
    
    // Flags
    macho_write32(m, flags)
    
    // Reserved
    macho_write32(m, 0)
    macho_write32(m, 0)
    macho_write32(m, 0)
}

// ============================================================================
// LC_MAIN (entry point)
// ============================================================================

func macho_write_lc_main(m: Int, entry_offset: Int, stack_size: Int) {
    macho_write32(m, LC_MAIN)
    macho_write32(m, LC_MAIN_SIZE)
    macho_write64(m, entry_offset)
    macho_write64(m, stack_size)
}

// ============================================================================
// LC_UNIXTHREAD (alternative entry point)
// ============================================================================

func macho_write_unixthread_x64(m: Int, entry: Int) {
    macho_write32(m, LC_UNIXTHREAD)
    macho_write32(m, UNIXTHREAD_SIZE_X64)
    
    // Flavor: x86_THREAD_STATE64
    macho_write32(m, 4)
    
    // Count (number of 32-bit words)
    macho_write32(m, 42)
    
    // Registers (21 x 64-bit = 168 bytes)
    // rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp, r8-r15, rip, rflags, cs, fs, gs
    let i = 0
    while i < 16 {
        macho_write64(m, 0)  // General registers
        i = i + 1
    }
    macho_write64(m, entry)  // RIP = entry point
    macho_write64(m, 0)      // RFLAGS
    macho_write64(m, 0)      // CS
    macho_write64(m, 0)      // FS
    macho_write64(m, 0)      // GS
}

func macho_write_unixthread_arm64(m: Int, entry: Int) {
    macho_write32(m, LC_UNIXTHREAD)
    macho_write32(m, UNIXTHREAD_SIZE_ARM64)
    
    // Flavor: ARM_THREAD_STATE64
    macho_write32(m, 6)
    
    // Count
    macho_write32(m, 68)
    
    // Registers: x0-x28, fp, lr, sp, pc, cpsr
    let i = 0
    while i < 29 {
        macho_write64(m, 0)  // x0-x28
        i = i + 1
    }
    macho_write64(m, 0)      // x29 (fp)
    macho_write64(m, 0)      // x30 (lr)
    macho_write64(m, 0)      // sp
    macho_write64(m, entry)  // pc = entry point
    macho_write32(m, 0)      // cpsr
    macho_write32(m, 0)      // pad
}

// ============================================================================
// STRING HELPERS (must be before macho_generate)
// ============================================================================

func make_text_name() -> Int {
    let s = ae_malloc(16)
    // Zero out all 16 bytes first
    let i = 0
    while i < 16 {
        ae_store8(s + i, 0)
        i = i + 1
    }
    // Write __TEXT
    ae_store8(s, 95) ae_store8(s + 1, 95)  // __
    ae_store8(s + 2, 84) ae_store8(s + 3, 69)  // TE
    ae_store8(s + 4, 88) ae_store8(s + 5, 84)  // XT
    s
}

func make_pagezero_name() -> Int {
    let s = ae_malloc(16)
    // Zero out all 16 bytes first
    let i = 0
    while i < 16 {
        ae_store8(s + i, 0)
        i = i + 1
    }
    // Write __PAGEZERO
    ae_store8(s, 95) ae_store8(s + 1, 95)  // __
    ae_store8(s + 2, 80) ae_store8(s + 3, 65)  // PA
    ae_store8(s + 4, 71) ae_store8(s + 5, 69)  // GE
    ae_store8(s + 6, 90) ae_store8(s + 7, 69)  // ZE
    ae_store8(s + 8, 82) ae_store8(s + 9, 79)  // RO
    s
}

func make_text_sect() -> Int {
    let s = ae_malloc(16)
    // Zero out all 16 bytes first
    let i = 0
    while i < 16 {
        ae_store8(s + i, 0)
        i = i + 1
    }
    // Write __text
    ae_store8(s, 95) ae_store8(s + 1, 95)  // __
    ae_store8(s + 2, 116) ae_store8(s + 3, 101)  // te
    ae_store8(s + 4, 120) ae_store8(s + 5, 116)  // xt
    s
}

// ============================================================================
// SIMPLE EXECUTABLE GENERATION
// ============================================================================

func macho_generate(m: Int, code: Int, code_size: Int) -> Int {
    let machine = macho_machine(m)
    
    // Calculate layout
    // Mach-O header: 32 bytes
    // LC_SEGMENT_64 (__PAGEZERO): 72 bytes (no sections)
    // LC_SEGMENT_64 (__TEXT): 72 bytes + section (80 bytes)
    // LC_UNIXTHREAD: 184 (x64) or 280 (arm64) bytes
    
    let header_size = MACH_HEADER_SIZE
    let pagezero_segment_size = SEGMENT_CMD_SIZE  // No sections
    let text_segment_size = SEGMENT_CMD_SIZE + SECTION_SIZE
    let unixthread_size = 0
    if machine == 0 {
        unixthread_size = UNIXTHREAD_SIZE_X64
    } else {
        unixthread_size = UNIXTHREAD_SIZE_ARM64
    }
    
    // 3 load commands: PAGEZERO, TEXT, UNIXTHREAD
    let sizeofcmds = pagezero_segment_size + text_segment_size + unixthread_size
    let ncmds = 3
    
    // Align code to page boundary
    let load_cmds_end = header_size + sizeofcmds
    let code_offset = (load_cmds_end + 4095) / 4096 * 4096
    macho_set_code_off(m, code_offset)
    
    let code_vaddr = MACHO_BASE + code_offset
    let total_size = code_offset + code_size
    let file_size = total_size
    let text_vm_size = (total_size + 4095) / 4096 * 4096
    
    macho_set_entry(m, code_offset)
    
    // Write header
    macho_write_header(m, ncmds, sizeofcmds)
    
    // Write __PAGEZERO segment (required for macOS)
    // VM address 0, VM size = 0x100000000, no file content
    let pagezero_name = make_pagezero_name()
    macho_write_segment(m, pagezero_name, 0, MACHO_BASE, 0, 0, 0, 0, 0)
    
    // Write __TEXT segment
    let text_name = make_text_name()
    macho_write_segment(m, text_name, MACHO_BASE, text_vm_size, 0, file_size, VM_PROT_READ + VM_PROT_EXECUTE, VM_PROT_READ + VM_PROT_EXECUTE, 1)
    
    // Write __text section
    let text_sect = make_text_sect()
    macho_write_section(m, text_sect, text_name, code_vaddr, code_size, code_offset, 4, S_ATTR_PURE_INSTRUCTIONS + S_ATTR_SOME_INSTRUCTIONS)
    
    // Write LC_UNIXTHREAD
    if machine == 0 {
        macho_write_unixthread_x64(m, code_vaddr)
    } else {
        macho_write_unixthread_arm64(m, code_vaddr)
    }
    
    // Pad to code offset
    macho_align(m, 4096)
    
    // Write code
    macho_write_bytes(m, code, code_size)
    
    macho_pos(m)
}

// ============================================================================
// COMPLETE EXECUTABLE BUILDER
// ============================================================================

func macho_build_exe(machine: Int, code: Int, code_size: Int) -> Int {
    let m = macho_new()
    macho_set_machine(m, machine)
    macho_generate(m, code, code_size)
    m
}

func macho_get_binary(m: Int) -> Int {
    macho_buf(m)
}

func macho_get_size(m: Int) -> Int {
    macho_pos(m)
}

// ============================================================================
// HELLO WORLD EXAMPLE FOR macOS ARM64
// ============================================================================

func macho_hello_arm64() -> Int {
    let code = arm_buffer_new()
    
    // mov x16, 4 (syscall: write)
    arm_mov_imm(code, ARM_X16, 4)
    // mov x0, 1 (stdout)
    arm_mov_imm(code, ARM_X0, 1)
    // adr x1, msg (address of string)
    arm_adr(code, ARM_X1, 24)  // offset to string
    // mov x2, 14 (length)
    arm_mov_imm(code, ARM_X2, 14)
    // svc 0x80 (syscall)
    arm_svc(code, 128)
    
    // mov x16, 1 (syscall: exit)
    arm_mov_imm(code, ARM_X16, 1)
    // mov x0, 0 (exit code)
    arm_mov_imm(code, ARM_X0, 0)
    // svc 0x80
    arm_svc(code, 128)
    
    // String: "Hello, World!\n"
    arm_emit32(code, 1819043144)  // "Hell"
    arm_emit32(code, 1461726319)  // "o, W"
    arm_emit32(code, 1684828783)  // "orld"
    arm_emit32(code, 174351905)   // "!\n" + padding
    
    let code_size = arm_get_size(code)
    let code_bytes = arm_get_code(code)
    
    let m = macho_new()
    macho_set_machine(m, 1)  // ARM64
    macho_generate(m, code_bytes, code_size)
    
    m
}

// ============================================================================
// WRITE TO FILE
// ============================================================================

func macho_write_file(m: Int, filename: Int) -> Int {
    // Write using native syscalls
    let buf = macho_buf(m)
    let data = ae_load64(buf)
    let len = ae_load64(buf + 8)
    
    // Requires syscall module import which we added to lib.aether
    // But this file imports std, and std imports lib.aether... circular?
    // No, compiler/native/*.aether are part of compiler module
    // We should call file_write_all directly if available
    
    // Let's assume syscall module functions are available via lib import
    file_write_all(filename, data, len)
    
    // Return size
    len
}

