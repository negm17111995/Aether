// AETHER NATIVE COMPILER - MAIN DRIVER
// 100% Native - NO C DEPENDENCY
// Compiles Aether source to native machine code directly

import std
import aether_compiler.native.syscall

// ============================================================================
// HELPER FUNCTIONS (defined first to avoid forward references)
// ============================================================================

func native_write_file_simple(path: Int, data: Int, len: Int) {
    file_write_all(path, data, len)
}

func write_cstr(s: Int) {
    let len = ae_strlen(s)
    native_write(1, s, len)
}

func make_banner() -> Int {
    let s = ae_malloc(32)
    // "Aether Native Compiler 1.0\n"
    ae_store8(s, 65) ae_store8(s+1, 101) ae_store8(s+2, 116) ae_store8(s+3, 104)
    ae_store8(s+4, 101) ae_store8(s+5, 114) ae_store8(s+6, 32) ae_store8(s+7, 78)
    ae_store8(s+8, 97) ae_store8(s+9, 116) ae_store8(s+10, 105) ae_store8(s+11, 118)
    ae_store8(s+12, 101) ae_store8(s+13, 32) ae_store8(s+14, 67) ae_store8(s+15, 111)
    ae_store8(s+16, 109) ae_store8(s+17, 112) ae_store8(s+18, 105) ae_store8(s+19, 108)
    ae_store8(s+20, 101) ae_store8(s+21, 114) ae_store8(s+22, 32) ae_store8(s+23, 49)
    ae_store8(s+24, 46) ae_store8(s+25, 48) ae_store8(s+26, 10) ae_store8(s+27, 0)
    s
}

func make_usage() -> Int {
    let s = ae_malloc(40)
    // "Usage: aetherc_native <file.aether>\n"
    ae_store8(s, 85) ae_store8(s+1, 115) ae_store8(s+2, 97) ae_store8(s+3, 103)
    ae_store8(s+4, 101) ae_store8(s+5, 58) ae_store8(s+6, 32) ae_store8(s+7, 97)
    ae_store8(s+8, 101) ae_store8(s+9, 116) ae_store8(s+10, 104) ae_store8(s+11, 101)
    ae_store8(s+12, 114) ae_store8(s+13, 99) ae_store8(s+14, 95) ae_store8(s+15, 110)
    ae_store8(s+16, 97) ae_store8(s+17, 116) ae_store8(s+18, 105) ae_store8(s+19, 118)
    ae_store8(s+20, 101) ae_store8(s+21, 32) ae_store8(s+22, 60) ae_store8(s+23, 102)
    ae_store8(s+24, 105) ae_store8(s+25, 108) ae_store8(s+26, 101) ae_store8(s+27, 46)
    ae_store8(s+28, 97) ae_store8(s+29, 101) ae_store8(s+30, 116) ae_store8(s+31, 104)
    ae_store8(s+32, 101) ae_store8(s+33, 114) ae_store8(s+34, 62) ae_store8(s+35, 10)
    ae_store8(s+36, 0)
    s
}

func make_error_msg() -> Int {
    let s = ae_malloc(32)
    // "Error: Could not read file\n"
    ae_store8(s, 69) ae_store8(s+1, 114) ae_store8(s+2, 114) ae_store8(s+3, 111)
    ae_store8(s+4, 114) ae_store8(s+5, 58) ae_store8(s+6, 32) ae_store8(s+7, 67)
    ae_store8(s+8, 111) ae_store8(s+9, 117) ae_store8(s+10, 108) ae_store8(s+11, 100)
    ae_store8(s+12, 32) ae_store8(s+13, 110) ae_store8(s+14, 111) ae_store8(s+15, 116)
    ae_store8(s+16, 32) ae_store8(s+17, 114) ae_store8(s+18, 101) ae_store8(s+19, 97)
    ae_store8(s+20, 100) ae_store8(s+21, 32) ae_store8(s+22, 102) ae_store8(s+23, 105)
    ae_store8(s+24, 108) ae_store8(s+25, 101) ae_store8(s+26, 10) ae_store8(s+27, 0)
    s
}

func make_success_msg() -> Int {
    let s = ae_malloc(26)
    // "Success! Generated a.out\n"
    ae_store8(s, 83) ae_store8(s+1, 117) ae_store8(s+2, 99) ae_store8(s+3, 99)
    ae_store8(s+4, 101) ae_store8(s+5, 115) ae_store8(s+6, 115) ae_store8(s+7, 33)
    ae_store8(s+8, 32) ae_store8(s+9, 71) ae_store8(s+10, 101) ae_store8(s+11, 110)
    ae_store8(s+12, 101) ae_store8(s+13, 114) ae_store8(s+14, 97) ae_store8(s+15, 116)
    ae_store8(s+16, 101) ae_store8(s+17, 100) ae_store8(s+18, 32) ae_store8(s+19, 97)
    ae_store8(s+20, 46) ae_store8(s+21, 111) ae_store8(s+22, 117) ae_store8(s+23, 116)
    ae_store8(s+24, 10) ae_store8(s+25, 0)
    s
}

func make_fail_msg() -> Int {
    let s = ae_malloc(20)
    // "Compilation failed\n"
    ae_store8(s, 67) ae_store8(s+1, 111) ae_store8(s+2, 109) ae_store8(s+3, 112)
    ae_store8(s+4, 105) ae_store8(s+5, 108) ae_store8(s+6, 97) ae_store8(s+7, 116)
    ae_store8(s+8, 105) ae_store8(s+9, 111) ae_store8(s+10, 110) ae_store8(s+11, 32)
    ae_store8(s+12, 102) ae_store8(s+13, 97) ae_store8(s+14, 105) ae_store8(s+15, 108)
    ae_store8(s+16, 101) ae_store8(s+17, 100) ae_store8(s+18, 10) ae_store8(s+19, 0)
    s
}

func make_output_path() -> Int {
    let s = ae_malloc(8)
    // "a.out"
    ae_store8(s, 97) ae_store8(s+1, 46) ae_store8(s+2, 111)
    ae_store8(s+3, 117) ae_store8(s+4, 116) ae_store8(s+5, 0)
    s
}

// ============================================================================
// COMPILATION FUNCTIONS
// ============================================================================

func compile_native_to_disk(module: Int, arch: Int, path: Int) -> Int {
    // Create native code generator
    let ng = nativegen_new(arch)
    
    // Generate code from AST
    ng_emit_module(ng, module)
    
    // Get generated code buffer
    let buf = ng_buf(ng)
    let code = 0
    let code_size = 0
    
    if arch == 0 {
        code = x64_get_code(buf)
        code_size = x64_get_size(buf)
    } else {
        code = arm_get_code(buf)
        code_size = arm_get_size(buf)
    }
    
    // Build Mach-O executable
    let m = macho_build_exe(arch, code, code_size)
    let binary = macho_get_binary(m)
    let binary_size = macho_get_size(m)
    
    // Write to file
    native_write_file_simple(path, binary, binary_size)
    
    binary_size
}

func compile_native_file(source: Int, len: Int, output_path: Int) -> Int {
    // 1. Tokenize
    let lexer = lexer_new(source, len)
    let tokens = vec_new()
    
    // Token collection loop - TOK_EOF is 0
    let tok = lexer_next(lexer)
    while token_type(tok) != 0 {
         vec_push(tokens, tok)
         tok = lexer_next(lexer)
    }
    // Add EOF token
    vec_push(tokens, tok)
    
    // Parse
    let parser = parser_new(tokens)
    let module = parse_module(parser)
    
    // Detect architecture (1 = ARM64 for macOS)
    let arch = 1
    
    let size = compile_native_to_disk(module, arch, output_path)
    size
}

// ============================================================================
// MAIN - ARGV SUPPORTED
// ============================================================================

func str_eq_test(s: Int) -> Int {
    // Check if string equals "--test"
    if ae_load8(s) != 45 { return 0 }  // -
    if ae_load8(s + 1) != 45 { return 0 }  // -
    if ae_load8(s + 2) != 116 { return 0 }  // t
    if ae_load8(s + 3) != 101 { return 0 }  // e
    if ae_load8(s + 4) != 115 { return 0 }  // s
    if ae_load8(s + 5) != 116 { return 0 }  // t
    if ae_load8(s + 6) != 0 { return 0 }  // null
    1
}

func generate_test_binary(output_path: Int) -> Int {
    // Generate hello world using existing function
    let m = macho_hello_arm64()
    let binary = macho_get_binary(m)
    let binary_size = macho_get_size(m)
    
    // Write to file
    native_write_file_simple(output_path, binary, binary_size)
    
    binary_size
}

func main(argc: Int, argv: Int) -> Int {
    // Header
    write_cstr(make_banner())
    
    if argc < 2 {
        write_cstr(make_usage())
        return 1
    }

    let input_path = get_arg_str(argv, 1)
    let output_path = make_output_path()
    let compiled_size = 0
    
    // Check for --test mode
    if str_eq_test(input_path) == 1 {
        compiled_size = generate_test_binary(output_path)
    } else {
        // Read source
        let source = file_read_all(input_path)
        if source == 0 {
            write_cstr(make_error_msg())
            return 1
        }
        
        let source_len = ae_strlen(source)
        
        // Compile
        compiled_size = compile_native_file(source, source_len, output_path)
    }
    
    if compiled_size > 0 {
        write_cstr(make_success_msg())
    } else {
        write_cstr(make_fail_msg())
    }
    
    0
}
