// AETHER SELF-HOSTED COMPILER - BORROW CHECKER
// Simplified Liquid Ownership verification

import std

// ============================================================================
// OWNERSHIP STATES
// ============================================================================

const OWN_OWNED: Int = 1
const OWN_MOVED: Int = 4

// ============================================================================
// OWNERSHIP CONTEXT
// ============================================================================

func ownership_ctx_new(parent: Int) -> Int {
    let ctx = ae_malloc(16)
    ae_store64(ctx, vec_new())
    ae_store64(ctx + 8, parent)
    ctx
}

func ctx_vars_bc(ctx: Int) -> Int { ae_load64(ctx) }
func ctx_parent_bc(ctx: Int) -> Int { ae_load64(ctx + 8) }

func var_state_new_bc(name: Int, state: Int) -> Int {
    let vs = ae_malloc(16)
    ae_store64(vs, name)
    ae_store64(vs + 8, state)
    vs
}

func ctx_add_var_bc(ctx: Int, name: Int) {
    vec_push(ctx_vars_bc(ctx), var_state_new_bc(name, OWN_OWNED))
}

func str_eq_bc(a: Int, b: Int) -> Int {
    if a == 0 || b == 0 { if a == b { return 1 } return 0 }
    let i = 0
    while 1 == 1 {
        let ca = ae_load8(a + i)
        let cb = ae_load8(b + i)
        if ca != cb { return 0 }
        if ca == 0 { return 1 }
        i = i + 1
    }
    0
}

func ctx_find_var_bc(ctx: Int, name: Int) -> Int {
    if ctx == 0 { return 0 }
    let vars = ctx_vars_bc(ctx)
    let i = 0
    while i < vec_len(vars) {
        let vs = vec_get(vars, i)
        if str_eq_bc(ae_load64(vs), name) == 1 { return vs }
        i = i + 1
    }
    ctx_find_var_bc(ctx_parent_bc(ctx), name)
}

// ============================================================================
// OWNERSHIP CHECKING
// ============================================================================

func check_expr_own(ctx: Int, node: Int) -> Int {
    if node == 0 { return 1 }
    let kind = ast_kind(node)
    
    if kind == AST_IDENT {
        let vs = ctx_find_var_bc(ctx, ast_data1(node))
        if vs != 0 {
            if ae_load64(vs + 8) == OWN_MOVED { return 0 }
        }
        return 1
    }
    
    if kind == AST_BINARY {
        if check_expr_own(ctx, ast_data2(node)) < 1 { return 0 }
        if check_expr_own(ctx, ast_data3(node)) < 1 { return 0 }
        return 1
    }
    
    if kind == AST_CALL {
        if check_expr_own(ctx, ast_data1(node)) < 1 { return 0 }
        let args = ast_data2(node)
        let i = 0
        while i < vec_len(args) {
            if check_expr_own(ctx, vec_get(args, i)) < 1 { return 0 }
            i = i + 1
        }
        return 1
    }
    
    1
}

func check_stmt_own(ctx: Int, node: Int) -> Int {
    if node == 0 { return 1 }
    let kind = ast_kind(node)
    
    if kind == AST_LET {
        if check_expr_own(ctx, ast_data3(node)) < 1 { return 0 }
        ctx_add_var_bc(ctx, ast_data1(node))
        return 1
    }
    
    if kind == AST_RETURN { return check_expr_own(ctx, ast_data1(node)) }
    if kind == AST_EXPR_STMT { return check_expr_own(ctx, ast_data1(node)) }
    
    1
}

func check_block_own(ctx: Int, block: Int) -> Int {
    if block == 0 { return 1 }
    let block_ctx = ownership_ctx_new(ctx)
    let stmts = ast_data1(block)
    if stmts == 0 { return 1 }
    let i = 0
    while i < vec_len(stmts) {
        if check_stmt_own(block_ctx, vec_get(stmts, i)) < 1 { return 0 }
        i = i + 1
    }
    1
}

func check_ownership(module: Int) -> Int {
    let decls = ast_data1(module)
    let i = 0
    while i < vec_len(decls) {
        let d = vec_get(decls, i)
        if ast_kind(d) == AST_FUNC {
            let ctx = ownership_ctx_new(0)
            let params = ast_data2(d)
            let j = 0
            while j < vec_len(params) {
                ctx_add_var_bc(ctx, ae_load64(vec_get(params, j)))
                j = j + 1
            }
            if check_block_own(ctx, ast_data4(d)) < 1 { return 0 }
        }
        i = i + 1
    }
    1
}
