// AETHER SELF-HOSTED COMPILER - MAIN ENTRY POINT
// Wires together: lexer -> parser -> typechecker -> codegen -> binary output
// 100% Pure Aether - NO C DEPENDENCIES

import std
import aether_compiler.lexer
import aether_compiler.parser
import aether_compiler.ast
import aether_compiler.typechecker
import aether_compiler.native.codegen
import aether_compiler.native.arm64
import aether_compiler.native.x86_64
import aether_compiler.native.macho
import aether_compiler.native.elf
import aether_compiler.native.pe
import aether_compiler.native.syscall

// ============================================================================
// TARGET PLATFORM CONSTANTS
// ============================================================================

const TARGET_MACOS_ARM64: Int = 0
const TARGET_MACOS_X64: Int = 1
const TARGET_LINUX_ARM64: Int = 2
const TARGET_LINUX_X64: Int = 3
const TARGET_WINDOWS_X64: Int = 4

// ============================================================================
// COMPILATION PIPELINE
// ============================================================================

func lex_source(source: Int, len: Int) -> Int {
    tokenize(source, len)
}

func parse_tokens(tokens: Int) -> Int {
    let p = parser_new(tokens)
    parse_module(p)
}

func typecheck_module(module: Int) -> Int {
    check_module(module)
    module
}

// ============================================================================
// NATIVE CODE GENERATION - ALL TARGETS
// ============================================================================

func compile_macos_arm64(module: Int, output: Int) -> Int {
    let ng = nativegen_new(1)  // 1 = ARM64
    ng_emit_module(ng, module)
    let buf = ng_buf(ng)
    let code = arm_get_code(buf)
    let code_size = arm_get_size(buf)
    let m = macho_build_exe(1, code, code_size)
    macho_write_file(m, output)
    macho_get_size(m)
}

func compile_macos_x64(module: Int, output: Int) -> Int {
    let ng = nativegen_new(0)  // 0 = x64
    ng_emit_module(ng, module)
    let buf = ng_buf(ng)
    let code = x64_get_code(buf)
    let code_size = x64_get_size(buf)
    let m = macho_build_exe(0, code, code_size)
    macho_write_file(m, output)
    macho_get_size(m)
}

func compile_linux_arm64(module: Int, output: Int) -> Int {
    let ng = nativegen_new(1)
    ng_emit_module(ng, module)
    let buf = ng_buf(ng)
    let code = arm_get_code(buf)
    let code_size = arm_get_size(buf)
    let e = elf_build_exe(1, code, code_size)
    elf_write_file(e, output)
    elf_pos(e)
}

func compile_linux_x64(module: Int, output: Int) -> Int {
    let ng = nativegen_new(0)
    ng_emit_module(ng, module)
    let buf = ng_buf(ng)
    let code = x64_get_code(buf)
    let code_size = x64_get_size(buf)
    let e = elf_build_exe(0, code, code_size)
    elf_write_file(e, output)
    elf_pos(e)
}

func compile_windows_x64(module: Int, output: Int) -> Int {
    let ng = nativegen_new(0)
    ng_emit_module(ng, module)
    let buf = ng_buf(ng)
    let code = x64_get_code(buf)
    let code_size = x64_get_size(buf)
    let p = pe_build_exe(code, code_size)
    pe_write_file(p, output)
    pe_get_size(p)
}

func compile_native(module: Int, target: Int, output: Int) -> Int {
    if target == TARGET_MACOS_ARM64 { return compile_macos_arm64(module, output) }
    if target == TARGET_MACOS_X64 { return compile_macos_x64(module, output) }
    if target == TARGET_LINUX_ARM64 { return compile_linux_arm64(module, output) }
    if target == TARGET_LINUX_X64 { return compile_linux_x64(module, output) }
    if target == TARGET_WINDOWS_X64 { return compile_windows_x64(module, output) }
    0
}

// ============================================================================
// FULL COMPILATION FLOW
// ============================================================================

func compile(source: Int, source_len: Int, target: Int, output: Int) -> Int {
    // 1. Lex
    let tokens = lex_source(source, source_len)
    if tokens == 0 { return 1 }
    
    // 2. Parse
    let ast = parse_tokens(tokens)
    if ast == 0 { return 2 }
    
    // 3. Typecheck
    let typed = typecheck_module(ast)
    if typed == 0 { return 3 }
    
    // 4. Generate native code
    let code = compile_native(typed, target, output)
    if code == 0 { return 4 }
    
    0  // Success
}

// ============================================================================
// PLATFORM DETECTION
// ============================================================================

func detect_target() -> Int {
    // Default to macOS ARM64 (compile-time constant)
    TARGET_MACOS_ARM64
}

// ============================================================================
// STRING UTILITIES
// ============================================================================

func str_eq_main(a: Int, b: Int) -> Int {
    let i = 0
    while 1 == 1 {
        let ca = ae_load8(a + i)
        let cb = ae_load8(b + i)
        if ca != cb { return 0 }
        if ca == 0 { return 1 }
        i = i + 1
    }
    0
}

func str_len_main(s: Int) -> Int {
    let i = 0
    while ae_load8(s + i) != 0 { i = i + 1 }
    i
}

// ============================================================================
// FILE I/O
// ============================================================================

func read_file(path: Int) -> Int {
    let fd = __builtin_open(path, 0)
    if fd < 0 { return 0 }
    let size = __builtin_seek(fd, 0, 2)
    __builtin_seek(fd, 0, 0)
    let buf = ae_malloc(size + 1)
    __builtin_read(fd, buf, size)
    ae_store8(buf + size, 0)
    __builtin_close(fd)
    buf
}

// ============================================================================
// MAIN
// ============================================================================

func main() -> Int {
    // Print compiler banner
    print(65)   // A
    print(69)   // E
    print(84)   // T
    print(72)   // H
    print(69)   // E
    print(82)   // R
    print(67)   // C
    print(10)   // newline
    
    0
}
