// EXTREME BENCHMARK SUITE - AETHER
// Tests: Fib(42), 10M Allocs, 50M Sieve, 1M Requests, Matrix 1024x1024

func fib(n: Int) -> Int {
    if n <= 1 { return n }
    fib(n - 1) + fib(n - 2)
}

func bench_fib() -> Int {
    fib(42)
}

func bench_alloc() -> Int {
    let count = 10000000 // 10 Million
    let i = 0
    let sum = 0
    while i < count {
        let ptr = __builtin_malloc(64)
        __builtin_store64(ptr, i)
        sum = sum + __builtin_load64(ptr)
        // No free - verifying memory handling/growth
        i = i + 1
    }
    sum
}

// Simulate processing a request
func process_request(id: Int) -> Int {
    let acc = 0
    let i = 0
    while i < 1000 { // Heavy compute per request
        acc = acc + i * id
        i = i + 1
    }
    acc
}

// "Concurrency" / Throughput Test
func bench_requests() -> Int {
    let total = 1000000 // 1 Million requests
    let i = 0
    let completed = 0
    while i < total {
        if process_request(i) > 0 {
            completed = completed + 1
        }
        i = i + 1
    }
    completed
}

func bench_sieve() -> Int {
    let limit = 50000000 // 50 Million
    let is_prime = __builtin_malloc(limit)
    
    // Init true
    let i = 0
    while i < limit {
        __builtin_store8(is_prime + i, 1)
        i = i + 1
    }
    
    i = 2
    while i * i < limit {
        if __builtin_load8(is_prime + i) == 1 {
            let j = i * i
            while j < limit {
                __builtin_store8(is_prime + j, 0)
                j = j + i
            }
        }
        i = i + 1
    }
    
    let count = 0
    i = 2
    while i < limit {
        if __builtin_load8(is_prime + i) == 1 { count = count + 1 }
        i = i + 1
    }
    count
}

func main() -> Int {
    // We sum results to prevent dead code elimination
    let f = bench_fib()
    let a = bench_alloc()
    let r = bench_requests()
    let s = bench_sieve()
    
    // Print results (using returns as simplistic specific output)
    f + a + r + s
}
