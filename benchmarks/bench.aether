// AETHER Heavy Benchmark - CPU Intensive
// Tests: Prime calculation, memory allocation

func is_prime(n: Int) -> Int {
    if n < 2 { return 0 }
    if n == 2 { return 1 }
    if n % 2 == 0 { return 0 }
    let i = 3
    while i * i <= n {
        if n % i == 0 { return 0 }
        i = i + 2
    }
    1
}

func count_primes(limit: Int) -> Int {
    let count = 0
    let i = 2
    while i < limit {
        count = count + is_prime(i)
        i = i + 1
    }
    count
}

func memory_stress(allocs: Int) -> Int {
    let total = 0
    let i = 0
    while i < allocs {
        let ptr = __builtin_malloc(1024)
        __builtin_store64(ptr, i)
        total = total + __builtin_load64(ptr)
        i = i + 1
    }
    total
}

func fib(n: Int) -> Int {
    if n <= 1 { return n }
    let a = 0
    let b = 1
    let i = 2
    while i <= n {
        let c = a + b
        a = b
        b = c
        i = i + 1
    }
    b
}

func main() -> Int {
    // CPU Test: Count primes to 100000
    let primes = count_primes(100000)
    
    // Memory Test: 10000 allocations
    let mem = memory_stress(10000)
    
    // Compute Test: Fibonacci
    let f = fib(40)
    
    primes + mem + f
}
