; LLVM IR generated by Aether Compiler
target triple = "arm64-apple-macosx14.0.0"

declare i8* @malloc(i64)
declare void @free(i8*)
declare i64 @write(i32, i8*, i64)
declare i64 @read(i32, i8*, i64)
declare i64 @open(i8*, i32, i32)
declare i64 @close(i32)
declare i8* @mmap(i8*, i64, i32, i32, i32, i64)
declare i32 @pthread_create(i64*, i8*, i8* (i8*)*, i8*)
declare i32 @pthread_join(i64, i8**)

define i64 @is_prime(i64 %n) {
entry:
  %n.addr = alloca i64
  store i64 %n, i64* %n.addr
  %t0 = load i64, i64* %n.addr
  %t1 = icmp slt i64 %t0, 2
  %t2 = zext i1 %t1 to i64
  %t3 = icmp ne i64 %t2, 0
  br i1 %t3, label %L0, label %L1
L0:
  ret i64 0
  br label %L2
L1:
  br label %L2
L2:
  %t4 = load i64, i64* %n.addr
  %t5 = icmp eq i64 %t4, 2
  %t6 = zext i1 %t5 to i64
  %t7 = icmp ne i64 %t6, 0
  br i1 %t7, label %L3, label %L4
L3:
  ret i64 1
  br label %L5
L4:
  br label %L5
L5:
  %t8 = load i64, i64* %n.addr
  %t9 = srem i64 %t8, 2
  %t10 = icmp eq i64 %t9, 0
  %t11 = zext i1 %t10 to i64
  %t12 = icmp ne i64 %t11, 0
  br i1 %t12, label %L6, label %L7
L6:
  ret i64 0
  br label %L8
L7:
  br label %L8
L8:
  %i.addr = alloca i64
  store i64 3, i64* %i.addr
  br label %L9
L9:
  %t13 = load i64, i64* %i.addr
  %t14 = load i64, i64* %i.addr
  %t15 = mul i64 %t13, %t14
  %t16 = load i64, i64* %n.addr
  %t17 = icmp sle i64 %t15, %t16
  %t18 = zext i1 %t17 to i64
  %t19 = icmp ne i64 %t18, 0
  br i1 %t19, label %L10, label %L11
L10:
  %t20 = load i64, i64* %n.addr
  %t21 = load i64, i64* %i.addr
  %t22 = srem i64 %t20, %t21
  %t23 = icmp eq i64 %t22, 0
  %t24 = zext i1 %t23 to i64
  %t25 = icmp ne i64 %t24, 0
  br i1 %t25, label %L12, label %L13
L12:
  ret i64 0
  br label %L14
L13:
  br label %L14
L14:
  %t26 = load i64, i64* %i.addr
  %t27 = add i64 %t26, 2
  store i64 %t27, i64* %i.addr
  br label %L9
L11:
  ret i64 0
}

define i64 @count_primes(i64 %limit) {
entry:
  %limit.addr = alloca i64
  store i64 %limit, i64* %limit.addr
  %count.addr = alloca i64
  store i64 0, i64* %count.addr
  %i.addr = alloca i64
  store i64 2, i64* %i.addr
  br label %L15
L15:
  %t0 = load i64, i64* %i.addr
  %t1 = load i64, i64* %limit.addr
  %t2 = icmp slt i64 %t0, %t1
  %t3 = zext i1 %t2 to i64
  %t4 = icmp ne i64 %t3, 0
  br i1 %t4, label %L16, label %L17
L16:
  %t5 = load i64, i64* %count.addr
  %t6 = load i64, i64* %i.addr
  %t7 = call i64 @is_prime(i64 %t6)
  %t8 = add i64 %t5, %t7
  store i64 %t8, i64* %count.addr
  %t9 = load i64, i64* %i.addr
  %t10 = add i64 %t9, 1
  store i64 %t10, i64* %i.addr
  br label %L15
L17:
  %t11 = load i64, i64* %count.addr
  ret i64 0
}

define i64 @memory_stress(i64 %allocs) {
entry:
  %allocs.addr = alloca i64
  store i64 %allocs, i64* %allocs.addr
  %total.addr = alloca i64
  store i64 0, i64* %total.addr
  %i.addr = alloca i64
  store i64 0, i64* %i.addr
  br label %L18
L18:
  %t0 = load i64, i64* %i.addr
  %t1 = load i64, i64* %allocs.addr
  %t2 = icmp slt i64 %t0, %t1
  %t3 = zext i1 %t2 to i64
  %t4 = icmp ne i64 %t3, 0
  br i1 %t4, label %L19, label %L20
L19:
  %ptr.addr = alloca i64
  %t5 = call i8* @malloc(i64 1024)
  %t6 = ptrtoint i8* %t5 to i64
  store i64 %t6, i64* %ptr.addr
  %t7 = load i64, i64* %ptr.addr
  %t8 = load i64, i64* %i.addr
  %t9 = inttoptr i64 %t7 to i64*
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %total.addr
  %t11 = load i64, i64* %ptr.addr
  %t12 = inttoptr i64 %t11 to i64*
  %t13 = load i64, i64* %t12
  %t14 = add i64 %t10, %t13
  store i64 %t14, i64* %total.addr
  %t15 = load i64, i64* %i.addr
  %t16 = add i64 %t15, 1
  store i64 %t16, i64* %i.addr
  br label %L18
L20:
  %t17 = load i64, i64* %total.addr
  ret i64 0
}

define i64 @fib(i64 %n) {
entry:
  %n.addr = alloca i64
  store i64 %n, i64* %n.addr
  %t0 = load i64, i64* %n.addr
  %t1 = icmp sle i64 %t0, 1
  %t2 = zext i1 %t1 to i64
  %t3 = icmp ne i64 %t2, 0
  br i1 %t3, label %L21, label %L22
L21:
  %t4 = load i64, i64* %n.addr
  ret i64 %t4
  br label %L23
L22:
  br label %L23
L23:
  %a.addr = alloca i64
  store i64 0, i64* %a.addr
  %b.addr = alloca i64
  store i64 1, i64* %b.addr
  %i.addr = alloca i64
  store i64 2, i64* %i.addr
  br label %L24
L24:
  %t5 = load i64, i64* %i.addr
  %t6 = load i64, i64* %n.addr
  %t7 = icmp sle i64 %t5, %t6
  %t8 = zext i1 %t7 to i64
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %L25, label %L26
L25:
  %c.addr = alloca i64
  %t10 = load i64, i64* %a.addr
  %t11 = load i64, i64* %b.addr
  %t12 = add i64 %t10, %t11
  store i64 %t12, i64* %c.addr
  %t13 = load i64, i64* %b.addr
  store i64 %t13, i64* %a.addr
  %t14 = load i64, i64* %c.addr
  store i64 %t14, i64* %b.addr
  %t15 = load i64, i64* %i.addr
  %t16 = add i64 %t15, 1
  store i64 %t16, i64* %i.addr
  br label %L24
L26:
  %t17 = load i64, i64* %b.addr
  ret i64 0
}

define i64 @main() {
entry:
  %primes.addr = alloca i64
  %t0 = call i64 @count_primes(i64 100000)
  store i64 %t0, i64* %primes.addr
  %mem.addr = alloca i64
  %t1 = call i64 @memory_stress(i64 10000)
  store i64 %t1, i64* %mem.addr
  %f.addr = alloca i64
  %t2 = call i64 @fib(i64 40)
  store i64 %t2, i64* %f.addr
  %t3 = load i64, i64* %primes.addr
  %t4 = load i64, i64* %mem.addr
  %t5 = add i64 %t3, %t4
  %t6 = load i64, i64* %f.addr
  %t7 = add i64 %t5, %t6
  ret i64 0
}

