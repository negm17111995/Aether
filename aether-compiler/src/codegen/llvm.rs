//! LLVM IR Code Generator for Aether
//! Generates LLVM IR that LLVM can optimize to C-level performance
//! 
//! This module produces LLVM IR text format (.ll files) that can be:
//! - Optimized with `opt -O3`
//! - Compiled with `llc` to native code
//! - Linked with `clang`

use std::collections::HashMap;

/// LLVM IR Generator
pub struct LLVMCodeGen {
    /// Generated IR
    ir: String,
    /// Function declarations
    functions: Vec<String>,
    /// Local variable counter for SSA
    var_counter: usize,
    /// Local variable map (name -> SSA name)
    locals: HashMap<String, String>,
    /// Label counter
    label_counter: usize,
    /// Current function return type
    current_ret_type: String,
}

impl LLVMCodeGen {
    pub fn new() -> Self {
        LLVMCodeGen {
            ir: String::new(),
            functions: Vec::new(),
            var_counter: 0,
            locals: HashMap::new(),
            label_counter: 0,
            current_ret_type: "i64".to_string(),
        }
    }
    
    /// Generate a new SSA variable name
    fn new_var(&mut self) -> String {
        let v = format!("%t{}", self.var_counter);
        self.var_counter += 1;
        v
    }
    
    /// Generate a new label
    fn new_label(&mut self) -> String {
        let l = format!("L{}", self.label_counter);
        self.label_counter += 1;
        l
    }
    
    /// Emit LLVM IR line
    fn emit(&mut self, line: &str) {
        self.ir.push_str("  ");
        self.ir.push_str(line);
        self.ir.push('\n');
    }
    
    /// Emit raw line (no indent)
    fn emit_raw(&mut self, line: &str) {
        self.ir.push_str(line);
        self.ir.push('\n');
    }
    
    /// Generate LLVM target and module header
    pub fn emit_header(&mut self) {
        self.emit_raw("; LLVM IR generated by Aether Compiler");
        self.emit_raw("target triple = \"arm64-apple-macosx14.0.0\"");
        self.emit_raw("");
        
        // Declare external functions
        self.emit_raw("declare i8* @malloc(i64)");
        self.emit_raw("declare void @free(i8*)");
        self.emit_raw("declare i64 @write(i32, i8*, i64)");
        self.emit_raw("declare i64 @read(i32, i8*, i64)");
        self.emit_raw("declare i64 @open(i8*, i32, i32)");
        self.emit_raw("declare i64 @close(i32)");
        self.emit_raw("declare i8* @mmap(i8*, i64, i32, i32, i32, i64)");
        self.emit_raw("declare i32 @pthread_create(i64*, i8*, i8* (i8*)*, i8*)");
        self.emit_raw("declare i32 @pthread_join(i64, i8**)");
        self.emit_raw("");
    }
    
    /// Generate function start
    pub fn emit_func_start(&mut self, name: &str, params: &[(&str, &str)], ret_type: &str) {
        self.var_counter = 0;
        self.locals.clear();
        self.current_ret_type = ret_type.to_string();
        
        let params_str: Vec<String> = params.iter()
            .map(|(name, ty)| format!("{} %{}", ty, name))
            .collect();
        
        self.emit_raw(&format!("define {} @{}({}) {{", 
            ret_type, name, params_str.join(", ")));
        self.emit_raw("entry:");
        
        // Allocate space for mutable parameters
        for (name, ty) in params {
            let ptr = format!("%{}.addr", name);
            self.emit(&format!("{} = alloca {}", ptr, ty));
            self.emit(&format!("store {} %{}, {}* {}", ty, name, ty, ptr));
            self.locals.insert(name.to_string(), ptr);
        }
    }
    
    /// Generate function end
    pub fn emit_func_end(&mut self) {
        self.emit_raw("}");
        self.emit_raw("");
    }
    
    /// Generate return statement
    pub fn emit_return(&mut self, value: &str) {
        self.emit(&format!("ret {} {}", self.current_ret_type, value));
    }
    
    /// Generate integer constant
    pub fn emit_const(&mut self, val: i64) -> String {
        val.to_string()
    }
    
    /// Generate add instruction
    pub fn emit_add(&mut self, a: &str, b: &str) -> String {
        let result = self.new_var();
        self.emit(&format!("{} = add i64 {}, {}", result, a, b));
        result
    }
    
    /// Generate sub instruction
    pub fn emit_sub(&mut self, a: &str, b: &str) -> String {
        let result = self.new_var();
        self.emit(&format!("{} = sub i64 {}, {}", result, a, b));
        result
    }
    
    /// Generate mul instruction
    pub fn emit_mul(&mut self, a: &str, b: &str) -> String {
        let result = self.new_var();
        self.emit(&format!("{} = mul i64 {}, {}", result, a, b));
        result
    }
    
    /// Generate load from pointer
    pub fn emit_load(&mut self, ptr: &str, ty: &str) -> String {
        let result = self.new_var();
        self.emit(&format!("{} = load {}, {}* {}", result, ty, ty, ptr));
        result
    }
    
    /// Generate store to pointer
    pub fn emit_store(&mut self, val: &str, ptr: &str, ty: &str) {
        self.emit(&format!("store {} {}, {}* {}", ty, val, ty, ptr));
    }
    
    /// Generate comparison - returns i64 (0 or 1) for type consistency
    pub fn emit_icmp(&mut self, op: &str, a: &str, b: &str) -> String {
        let cmp_result = self.new_var();
        self.emit(&format!("{} = icmp {} i64 {}, {}", cmp_result, op, a, b));
        // Zero-extend i1 to i64 for type consistency
        let result = self.new_var();
        self.emit(&format!("{} = zext i1 {} to i64", result, cmp_result));
        result
    }
    
    /// Generate branch
    pub fn emit_br(&mut self, label: &str) {
        self.emit(&format!("br label %{}", label));
    }
    
    /// Generate conditional branch
    pub fn emit_cond_br(&mut self, cond: &str, then_label: &str, else_label: &str) {
        self.emit(&format!("br i1 {}, label %{}, label %{}", cond, then_label, else_label));
    }
    
    /// Generate label
    pub fn emit_label(&mut self, name: &str) {
        self.emit_raw(&format!("{}:", name));
    }
    
    /// Generate function call
    pub fn emit_call(&mut self, name: &str, args: &[&str], ret_type: &str) -> String {
        let args_str = args.iter()
            .map(|a| format!("i64 {}", a))
            .collect::<Vec<_>>()
            .join(", ");
        
        if ret_type == "void" {
            self.emit(&format!("call void @{}({})", name, args_str));
            "0".to_string()
        } else {
            let result = self.new_var();
            self.emit(&format!("{} = call {} @{}({})", result, ret_type, name, args_str));
            result
        }
    }
    
    /// Generate malloc call
    pub fn emit_malloc(&mut self, size: &str) -> String {
        let result = self.new_var();
        self.emit(&format!("{} = call i8* @malloc(i64 {})", result, size));
        let ptr = self.new_var();
        self.emit(&format!("{} = ptrtoint i8* {} to i64", ptr, result));
        ptr
    }
    
    /// Generate store8
    pub fn emit_store8(&mut self, ptr: &str, val: &str) {
        let ptr_cast = self.new_var();
        self.emit(&format!("{} = inttoptr i64 {} to i8*", ptr_cast, ptr));
        let val_trunc = self.new_var();
        self.emit(&format!("{} = trunc i64 {} to i8", val_trunc, val));
        self.emit(&format!("store i8 {}, i8* {}", val_trunc, ptr_cast));
    }
    
    /// Generate load8
    pub fn emit_load8(&mut self, ptr: &str) -> String {
        let ptr_cast = self.new_var();
        self.emit(&format!("{} = inttoptr i64 {} to i8*", ptr_cast, ptr));
        let val = self.new_var();
        self.emit(&format!("{} = load i8, i8* {}", val, ptr_cast));
        let result = self.new_var();
        self.emit(&format!("{} = zext i8 {} to i64", result, val));
        result
    }
    
    /// Generate store64
    pub fn emit_store64(&mut self, ptr: &str, val: &str) {
        let ptr_cast = self.new_var();
        self.emit(&format!("{} = inttoptr i64 {} to i64*", ptr_cast, ptr));
        self.emit(&format!("store i64 {}, i64* {}", val, ptr_cast));
    }
    
    /// Generate load64
    pub fn emit_load64(&mut self, ptr: &str) -> String {
        let ptr_cast = self.new_var();
        self.emit(&format!("{} = inttoptr i64 {} to i64*", ptr_cast, ptr));
        let result = self.new_var();
        self.emit(&format!("{} = load i64, i64* {}", result, ptr_cast));
        result
    }
    
    /// Generate phi node for loops
    pub fn emit_phi(&mut self, ty: &str, incoming: &[(String, String)]) -> String {
        let result = self.new_var();
        let pairs: Vec<String> = incoming.iter()
            .map(|(val, label)| format!("[{}, %{}]", val, label))
            .collect();
        self.emit(&format!("{} = phi {} {}", result, ty, pairs.join(", ")));
        result
    }
    
    /// Get generated IR
    pub fn get_ir(&self) -> &str {
        &self.ir
    }
    
    /// Allocate a local variable
    pub fn alloc_local(&mut self, name: &str) -> String {
        let ptr = format!("%{}.addr", name);
        self.emit(&format!("{} = alloca i64", ptr));
        self.locals.insert(name.to_string(), ptr.clone());
        ptr
    }
    
    /// Get local variable pointer
    pub fn get_local(&self, name: &str) -> Option<&String> {
        self.locals.get(name)
    }

    /// Generate native thread spawn
    pub fn gen_spawn(&mut self, func_name: &str, arg: &str) -> String {
        // 1. Allocate thread ID
        let tid_ptr = self.new_var();
        self.emit(&format!("{} = alloca i64", tid_ptr));
        
        // 2. Cast thread function to correct signature: i8* (i8*)*
        // Aether functions are i64 (i64), so we need a wrapper or cast
        // For v1, we assume the target function accepts i64 and returns i64
        let func_cast = self.new_var();
        self.emit(&format!("{} = bitcast i64 (i64)* @{} to i8* (i8*)*", func_cast, func_name));
        
        // 3. Cast argument to void* (i8*)
        let arg_cast = self.new_var();
        self.emit(&format!("{} = inttoptr i64 {} to i8*", arg_cast, arg));
        
        // 4. Call pthread_create(tid_ptr, NULL, func, arg)
        let result = self.new_var();
        self.emit(&format!("{} = call i32 @pthread_create(i64* {}, i8* null, i8* (i8*)* {}, i8* {})",
            result, tid_ptr, func_cast, arg_cast));
            
        // Return thread ID
        let tid_load = self.new_var();
        self.emit(&format!("{} = load i64, i64* {}", tid_load, tid_ptr));
        tid_load
    }
}

// ============================================================================
// AST-BASED CODE GENERATION
// ============================================================================

use crate::ast::{Expr, Stmt, Block, BinOp, UnOp, Decl};

impl LLVMCodeGen {
    /// Generate code for expression, returns SSA value
    pub fn gen_expr(&mut self, expr: &Expr) -> String {
        match expr {
            Expr::Int(val, _) => val.to_string(),
            
            Expr::Bool(val, _) => if *val { "1" } else { "0" }.to_string(),
            
            Expr::Ident(name, _) => {
                if let Some(ptr) = self.locals.get(name).cloned() {
                    self.emit_load(&ptr, "i64")
                } else {
                    // Assume it's a parameter
                    format!("%{}", name)
                }
            }
            
            Expr::Binary(op, left, right, _) => {
                let l = self.gen_expr(left);
                let r = self.gen_expr(right);
                match op {
                    BinOp::Add => self.emit_add(&l, &r),
                    BinOp::Sub => self.emit_sub(&l, &r),
                    BinOp::Mul => self.emit_mul(&l, &r),
                    BinOp::Div => {
                        let result = self.new_var();
                        self.emit(&format!("{} = sdiv i64 {}, {}", result, l, r));
                        result
                    }
                    BinOp::Mod => {
                        let result = self.new_var();
                        self.emit(&format!("{} = srem i64 {}, {}", result, l, r));
                        result
                    }
                    BinOp::Lt => self.emit_icmp("slt", &l, &r),
                    BinOp::Le => self.emit_icmp("sle", &l, &r),
                    BinOp::Gt => self.emit_icmp("sgt", &l, &r),
                    BinOp::Ge => self.emit_icmp("sge", &l, &r),
                    BinOp::Eq => self.emit_icmp("eq", &l, &r),
                    BinOp::Ne => self.emit_icmp("ne", &l, &r),
                    BinOp::And => {
                        let result = self.new_var();
                        self.emit(&format!("{} = and i64 {}, {}", result, l, r));
                        result
                    }
                    BinOp::Or => {
                        let result = self.new_var();
                        self.emit(&format!("{} = or i64 {}, {}", result, l, r));
                        result
                    }
                    BinOp::BitAnd => {
                        let result = self.new_var();
                        self.emit(&format!("{} = and i64 {}, {}", result, l, r));
                        result
                    }
                    BinOp::BitOr => {
                        let result = self.new_var();
                        self.emit(&format!("{} = or i64 {}, {}", result, l, r));
                        result
                    }
                    BinOp::BitXor => {
                        let result = self.new_var();
                        self.emit(&format!("{} = xor i64 {}, {}", result, l, r));
                        result
                    }
                }
            }
            
            Expr::Unary(op, inner, _) => {
                let v = self.gen_expr(inner);
                match op {
                    UnOp::Neg => self.emit_sub("0", &v),
                    UnOp::Not => {
                        let result = self.new_var();
                        self.emit(&format!("{} = xor i64 {}, 1", result, v));
                        result
                    }
                    UnOp::BitNot => {
                        let result = self.new_var();
                        self.emit(&format!("{} = xor i64 {}, -1", result, v));
                        result
                    }
                    _ => v,
                }
            }
            
            Expr::Call(func, args, _) => {
                if let Expr::Ident(name, _) = func.as_ref() {
                    // Handle builtins
                    match name.as_str() {
                        "__builtin_malloc" => {
                            let size = self.gen_expr(&args[0]);
                            self.emit_malloc(&size)
                        }
                        "__builtin_store8" => {
                            let ptr = self.gen_expr(&args[0]);
                            let val = self.gen_expr(&args[1]);
                            self.emit_store8(&ptr, &val);
                            "0".to_string()
                        }
                        "__builtin_load8" => {
                            let ptr = self.gen_expr(&args[0]);
                            self.emit_load8(&ptr)
                        }
                        "__builtin_store64" => {
                            let ptr = self.gen_expr(&args[0]);
                            let val = self.gen_expr(&args[1]);
                            self.emit_store64(&ptr, &val);
                            "0".to_string()
                        }
                        "__builtin_load64" => {
                            let ptr = self.gen_expr(&args[0]);
                            self.emit_load64(&ptr)
                        }
                        _ => {
                            // Regular function call
                            let arg_vals: Vec<String> = args.iter()
                                .map(|a| self.gen_expr(a))
                                .collect();
                            let arg_refs: Vec<&str> = arg_vals.iter()
                                .map(|s| s.as_str())
                                .collect();
                            self.emit_call(name, &arg_refs, "i64")
                        }
                    }
                } else {
                    "0".to_string()
                }
            }
            
            Expr::If(cond, then_block, else_block, _) => {
                let cond_val = self.gen_expr(cond);
                let then_label = self.new_label();
                let else_label = self.new_label();
                let end_label = self.new_label();
                
                // Convert to i1
                let cond_i1 = self.new_var();
                self.emit(&format!("{} = icmp ne i64 {}, 0", cond_i1, cond_val));
                self.emit_cond_br(&cond_i1, &then_label, &else_label);
                
                // Then block
                self.emit_label(&then_label);
                let then_val = self.gen_block(then_block);
                self.emit_br(&end_label);
                
                // Else block  
                self.emit_label(&else_label);
                let else_val = if let Some(eb) = else_block {
                    self.gen_block(eb)
                } else {
                    "0".to_string()
                };
                self.emit_br(&end_label);
                
                // End
                self.emit_label(&end_label);
                then_val
            }
            
            Expr::Spawn(func, args, _) => {
                if let Expr::Ident(name, _) = func.as_ref() {
                    // Currently assume single argument for v1 simple spawn
                    let arg_val = if !args.is_empty() {
                        self.gen_expr(&args[0])
                    } else {
                        "0".to_string()
                    };
                    
                    self.gen_spawn(name, &arg_val)
                } else {
                    "0".to_string()
                }
            }
            
            _ => "0".to_string(),
        }
    }
    
    /// Generate code for block, returns last expression value
    pub fn gen_block(&mut self, block: &Block) -> String {
        let mut last = "0".to_string();
        for stmt in &block.stmts {
            last = self.gen_stmt(stmt);
        }
        last
    }
    
    /// Generate code for statement
    pub fn gen_stmt(&mut self, stmt: &Stmt) -> String {
        match stmt {
            Stmt::Let { name, init, .. } => {
                let ptr = self.alloc_local(name);
                if let Some(expr) = init {
                    let val = self.gen_expr(expr);
                    self.emit_store(&val, &ptr, "i64");
                }
                "0".to_string()
            }
            
            Stmt::Assign(target, value, _) => {
                if let Expr::Ident(name, _) = target {
                    if let Some(ptr) = self.locals.get(name).cloned() {
                        let val = self.gen_expr(value);
                        self.emit_store(&val, &ptr, "i64");
                    }
                }
                "0".to_string()
            }
            
            Stmt::Return(expr, _) => {
                if let Some(e) = expr {
                    let val = self.gen_expr(e);
                    self.emit_return(&val);
                } else {
                    self.emit_return("0");
                }
                "0".to_string()
            }
            
            Stmt::If(cond, then_block, else_block, _) => {
                let cond_val = self.gen_expr(cond);
                let then_label = self.new_label();
                let else_label = self.new_label();
                let end_label = self.new_label();
                
                let cond_i1 = self.new_var();
                self.emit(&format!("{} = icmp ne i64 {}, 0", cond_i1, cond_val));
                self.emit_cond_br(&cond_i1, &then_label, &else_label);
                
                self.emit_label(&then_label);
                self.gen_block(then_block);
                self.emit_br(&end_label);
                
                self.emit_label(&else_label);
                if let Some(eb) = else_block {
                    self.gen_block(eb);
                }
                self.emit_br(&end_label);
                
                self.emit_label(&end_label);
                "0".to_string()
            }
            
            Stmt::While(cond, body, _) => {
                let start_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                self.emit_br(&start_label);
                self.emit_label(&start_label);
                
                let cond_val = self.gen_expr(cond);
                let cond_i1 = self.new_var();
                self.emit(&format!("{} = icmp ne i64 {}, 0", cond_i1, cond_val));
                self.emit_cond_br(&cond_i1, &body_label, &end_label);
                
                self.emit_label(&body_label);
                self.gen_block(body);
                self.emit_br(&start_label);
                
                self.emit_label(&end_label);
                "0".to_string()
            }
            
            Stmt::Expr(expr, _) => self.gen_expr(expr),
            
            Stmt::Break(_) => {
                // Need loop context
                "0".to_string()
            }
            
            Stmt::Continue(_) => {
                // Need loop context
                "0".to_string()
            }
            
            Stmt::Block(block, _) => self.gen_block(block),
            
            Stmt::For(var, iter, body, _) => {
                // Simplified: assume iter is a range
                "0".to_string()
            }
        }
    }
    
    /// Generate full function from Decl
    pub fn gen_function(&mut self, decl: &Decl) {
        if let Decl::Func { name, params, body, ret, .. } = decl {
            // Reset state
            self.var_counter = 0;
            self.locals.clear();
            
            // Build params list
            let params_vec: Vec<(&str, &str)> = params.iter()
                .map(|p| (p.name.as_str(), "i64"))
                .collect();
            
            self.emit_func_start(name, &params_vec, "i64");
            
            // Generate body
            self.gen_block(body);
            
            // Default return if needed
            self.emit_return("0");
            self.emit_func_end();
        }
    }
}

// ============================================================================
// LOOP UNROLLING HELPER
// ============================================================================

/// Generate unrolled loop (factor of 4)
pub fn emit_unrolled_loop(
    gen: &mut LLVMCodeGen,
    init: i64,
    limit: &str,
    body: impl Fn(&mut LLVMCodeGen, &str) -> String,
) -> String {
    let loop_start = gen.new_label();
    let loop_body = gen.new_label();
    let loop_end = gen.new_label();
    let unroll_body = gen.new_label();
    let cleanup = gen.new_label();
    
    // Initialize loop counter
    let counter_ptr = gen.new_var();
    gen.emit(&format!("{} = alloca i64", counter_ptr));
    gen.emit(&format!("store i64 {}, i64* {}", init, counter_ptr));
    
    gen.emit_br(&loop_start);
    gen.emit_label(&loop_start);
    
    // Check if we can do 4 iterations
    let counter = gen.emit_load(&counter_ptr, "i64");
    let remaining = gen.emit_sub(limit, &counter);
    let can_unroll = gen.emit_icmp("sge", &remaining, "4");
    gen.emit_cond_br(&can_unroll, &unroll_body, &cleanup);
    
    // Unrolled body (4 iterations)
    gen.emit_label(&unroll_body);
    for i in 0..4 {
        let idx = if i == 0 {
            counter.clone()
        } else {
            gen.emit_add(&counter, &i.to_string())
        };
        body(gen, &idx);
    }
    let new_counter = gen.emit_add(&counter, "4");
    gen.emit_store(&new_counter, &counter_ptr, "i64");
    gen.emit_br(&loop_start);
    
    // Cleanup loop for remaining iterations
    gen.emit_label(&cleanup);
    let counter2 = gen.emit_load(&counter_ptr, "i64");
    let done = gen.emit_icmp("sge", &counter2, limit);
    gen.emit_cond_br(&done, &loop_end, &loop_body);
    
    gen.emit_label(&loop_body);
    body(gen, &counter2);
    let inc_counter = gen.emit_add(&counter2, "1");
    gen.emit_store(&inc_counter, &counter_ptr, "i64");
    gen.emit_br(&cleanup);
    
    gen.emit_label(&loop_end);
    gen.emit_load(&counter_ptr, "i64")
}

// ============================================================================
// SIMD VECTORIZATION HELPER
// ============================================================================

/// Generate vectorized add (4 elements at once using NEON)
pub fn emit_vector_add(
    gen: &mut LLVMCodeGen,
    a_ptr: &str,
    b_ptr: &str,
    c_ptr: &str,
    offset: &str,
) {
    // Cast to vector pointers
    let a_base = gen.emit_add(a_ptr, offset);
    let b_base = gen.emit_add(b_ptr, offset);
    let c_base = gen.emit_add(c_ptr, offset);
    
    let a_vptr = gen.new_var();
    gen.emit(&format!("{} = inttoptr i64 {} to <4 x i64>*", a_vptr, a_base));
    
    let b_vptr = gen.new_var();
    gen.emit(&format!("{} = inttoptr i64 {} to <4 x i64>*", b_vptr, b_base));
    
    let c_vptr = gen.new_var();
    gen.emit(&format!("{} = inttoptr i64 {} to <4 x i64>*", c_vptr, c_base));
    
    // Load vectors
    let a_vec = gen.new_var();
    gen.emit(&format!("{} = load <4 x i64>, <4 x i64>* {}", a_vec, a_vptr));
    
    let b_vec = gen.new_var();
    gen.emit(&format!("{} = load <4 x i64>, <4 x i64>* {}", b_vec, b_vptr));
    
    // Vector add
    let c_vec = gen.new_var();
    gen.emit(&format!("{} = add <4 x i64> {}, {}", c_vec, a_vec, b_vec));
    
    // Store result
    gen.emit(&format!("store <4 x i64> {}, <4 x i64>* {}", c_vec, c_vptr));
}
